#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu May 10 13:17:28 2012 by generateDS.py version 2.6a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class application(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, appName=None, report=None, prompt=None, page=None):
        self.appName = _cast(None, appName)
        self.report = report
        self.prompt = prompt
        self.page = page
    def factory(*args_, **kwargs_):
        if application.subclass:
            return application.subclass(*args_, **kwargs_)
        else:
            return application(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_report(self): return self.report
    def set_report(self, report): self.report = report
    def get_prompt(self): return self.prompt
    def set_prompt(self, prompt): self.prompt = prompt
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def get_appName(self): return self.appName
    def set_appName(self, appName): self.appName = appName
    def export(self, outfile, level, namespace_='', name_='application', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='application')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='application'):
        if self.appName is not None and 'appName' not in already_processed:
            already_processed.append('appName')
            outfile.write(' appName=%s' % (self.gds_format_string(quote_attrib(self.appName).encode(ExternalEncoding), input_name='appName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='application', fromsubclass_=False):
        if self.report:
            self.report.export(outfile, level, namespace_, name_='report')
        if self.prompt:
            self.prompt.export(outfile, level, namespace_, name_='prompt')
        if self.page:
            self.page.export(outfile, level, namespace_, name_='page')
    def hasContent_(self):
        if (
            self.report is not None or
            self.prompt is not None or
            self.page is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='application'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.appName is not None and 'appName' not in already_processed:
            already_processed.append('appName')
            showIndent(outfile, level)
            outfile.write('appName = "%s",\n' % (self.appName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.report is not None:
            showIndent(outfile, level)
            outfile.write('report=model_.report(\n')
            self.report.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.prompt is not None:
            showIndent(outfile, level)
            outfile.write('prompt=model_.prompt(\n')
            self.prompt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.page is not None:
            showIndent(outfile, level)
            outfile.write('page=model_.page(\n')
            self.page.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('appName', node)
        if value is not None and 'appName' not in already_processed:
            already_processed.append('appName')
            self.appName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'report':
            obj_ = report.factory()
            obj_.build(child_)
            self.set_report(obj_)
        elif nodeName_ == 'prompt':
            obj_ = prompt.factory()
            obj_.build(child_)
            self.set_prompt(obj_)
        elif nodeName_ == 'page':
            obj_ = page.factory()
            obj_.build(child_)
            self.set_page(obj_)
# end class application


class prompt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scope=None, promptFilter=None):
        self.scope = _cast(None, scope)
        if promptFilter is None:
            self.promptFilter = []
        else:
            self.promptFilter = promptFilter
    def factory(*args_, **kwargs_):
        if prompt.subclass:
            return prompt.subclass(*args_, **kwargs_)
        else:
            return prompt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_promptFilter(self): return self.promptFilter
    def set_promptFilter(self, promptFilter): self.promptFilter = promptFilter
    def add_promptFilter(self, value): self.promptFilter.append(value)
    def insert_promptFilter(self, index, value): self.promptFilter[index] = value
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def export(self, outfile, level, namespace_='', name_='prompt', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='prompt')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='prompt'):
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.append('scope')
            outfile.write(' scope=%s' % (self.gds_format_string(quote_attrib(self.scope).encode(ExternalEncoding), input_name='scope'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='prompt', fromsubclass_=False):
        for promptFilter_ in self.promptFilter:
            promptFilter_.export(outfile, level, namespace_, name_='promptFilter')
    def hasContent_(self):
        if (
            self.promptFilter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='prompt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.append('scope')
            showIndent(outfile, level)
            outfile.write('scope = "%s",\n' % (self.scope,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('promptFilter=[\n')
        level += 1
        for promptFilter_ in self.promptFilter:
            showIndent(outfile, level)
            outfile.write('model_.promptFilterType(\n')
            promptFilter_.exportLiteral(outfile, level, name_='promptFilterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.append('scope')
            self.scope = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'promptFilter':
            obj_ = promptFilterType.factory()
            obj_.build(child_)
            self.promptFilter.append(obj_)
# end class prompt


class column(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, interaction=None, columnId=None, columName=None, suppress=None, tableName=None, visibility=None, edgeSeq=None, measurePosition=None, formula=None, aggRule=None, type_=None, dataFormat=None, navigation=None, columnHeading=None, drillColumn=None):
        self.interaction = _cast(None, interaction)
        self.columnId = _cast(None, columnId)
        self.columName = _cast(None, columName)
        self.suppress = _cast(None, suppress)
        self.tableName = _cast(None, tableName)
        self.visibility = _cast(None, visibility)
        self.edgeSeq = _cast(None, edgeSeq)
        self.measurePosition = _cast(None, measurePosition)
        self.formula = _cast(None, formula)
        self.aggRule = _cast(None, aggRule)
        self.type_ = _cast(None, type_)
        self.dataFormat = dataFormat
        if navigation is None:
            self.navigation = []
        else:
            self.navigation = navigation
        self.columnHeading = columnHeading
        if drillColumn is None:
            self.drillColumn = []
        else:
            self.drillColumn = drillColumn
    def factory(*args_, **kwargs_):
        if column.subclass:
            return column.subclass(*args_, **kwargs_)
        else:
            return column(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataFormat(self): return self.dataFormat
    def set_dataFormat(self, dataFormat): self.dataFormat = dataFormat
    def get_navigation(self): return self.navigation
    def set_navigation(self, navigation): self.navigation = navigation
    def add_navigation(self, value): self.navigation.append(value)
    def insert_navigation(self, index, value): self.navigation[index] = value
    def get_columnHeading(self): return self.columnHeading
    def set_columnHeading(self, columnHeading): self.columnHeading = columnHeading
    def get_drillColumn(self): return self.drillColumn
    def set_drillColumn(self, drillColumn): self.drillColumn = drillColumn
    def add_drillColumn(self, value): self.drillColumn.append(value)
    def insert_drillColumn(self, index, value): self.drillColumn[index] = value
    def get_interaction(self): return self.interaction
    def set_interaction(self, interaction): self.interaction = interaction
    def get_columnId(self): return self.columnId
    def set_columnId(self, columnId): self.columnId = columnId
    def get_columName(self): return self.columName
    def set_columName(self, columName): self.columName = columName
    def get_suppress(self): return self.suppress
    def set_suppress(self, suppress): self.suppress = suppress
    def get_tableName(self): return self.tableName
    def set_tableName(self, tableName): self.tableName = tableName
    def get_visibility(self): return self.visibility
    def set_visibility(self, visibility): self.visibility = visibility
    def get_edgeSeq(self): return self.edgeSeq
    def set_edgeSeq(self, edgeSeq): self.edgeSeq = edgeSeq
    def get_measurePosition(self): return self.measurePosition
    def set_measurePosition(self, measurePosition): self.measurePosition = measurePosition
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_aggRule(self): return self.aggRule
    def set_aggRule(self, aggRule): self.aggRule = aggRule
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='column', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='column')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='column'):
        if self.interaction is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            outfile.write(' interaction=%s' % (self.gds_format_string(quote_attrib(self.interaction).encode(ExternalEncoding), input_name='interaction'), ))
        if self.columnId is not None and 'columnId' not in already_processed:
            already_processed.append('columnId')
            outfile.write(' columnId=%s' % (self.gds_format_string(quote_attrib(self.columnId).encode(ExternalEncoding), input_name='columnId'), ))
        if self.columName is not None and 'columName' not in already_processed:
            already_processed.append('columName')
            outfile.write(' columName=%s' % (self.gds_format_string(quote_attrib(self.columName).encode(ExternalEncoding), input_name='columName'), ))
        if self.suppress is not None and 'suppress' not in already_processed:
            already_processed.append('suppress')
            outfile.write(' suppress=%s' % (self.gds_format_string(quote_attrib(self.suppress).encode(ExternalEncoding), input_name='suppress'), ))
        if self.tableName is not None and 'tableName' not in already_processed:
            already_processed.append('tableName')
            outfile.write(' tableName=%s' % (self.gds_format_string(quote_attrib(self.tableName).encode(ExternalEncoding), input_name='tableName'), ))
        if self.visibility is not None and 'visibility' not in already_processed:
            already_processed.append('visibility')
            outfile.write(' visibility=%s' % (self.gds_format_string(quote_attrib(self.visibility).encode(ExternalEncoding), input_name='visibility'), ))
        if self.edgeSeq is not None and 'edgeSeq' not in already_processed:
            already_processed.append('edgeSeq')
            outfile.write(' edgeSeq=%s' % (self.gds_format_string(quote_attrib(self.edgeSeq).encode(ExternalEncoding), input_name='edgeSeq'), ))
        if self.measurePosition is not None and 'measurePosition' not in already_processed:
            already_processed.append('measurePosition')
            outfile.write(' measurePosition=%s' % (self.gds_format_string(quote_attrib(self.measurePosition).encode(ExternalEncoding), input_name='measurePosition'), ))
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            outfile.write(' formula=%s' % (self.gds_format_string(quote_attrib(self.formula).encode(ExternalEncoding), input_name='formula'), ))
        if self.aggRule is not None and 'aggRule' not in already_processed:
            already_processed.append('aggRule')
            outfile.write(' aggRule=%s' % (self.gds_format_string(quote_attrib(self.aggRule).encode(ExternalEncoding), input_name='aggRule'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='column', fromsubclass_=False):
        if self.dataFormat:
            self.dataFormat.export(outfile, level, namespace_, name_='dataFormat')
        for navigation_ in self.navigation:
            navigation_.export(outfile, level, namespace_, name_='navigation')
        if self.columnHeading:
            self.columnHeading.export(outfile, level, namespace_, name_='columnHeading')
        for drillColumn_ in self.drillColumn:
            drillColumn_.export(outfile, level, namespace_, name_='drillColumn')
    def hasContent_(self):
        if (
            self.dataFormat is not None or
            self.navigation or
            self.columnHeading is not None or
            self.drillColumn
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='column'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interaction is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            showIndent(outfile, level)
            outfile.write('interaction = "%s",\n' % (self.interaction,))
        if self.columnId is not None and 'columnId' not in already_processed:
            already_processed.append('columnId')
            showIndent(outfile, level)
            outfile.write('columnId = "%s",\n' % (self.columnId,))
        if self.columName is not None and 'columName' not in already_processed:
            already_processed.append('columName')
            showIndent(outfile, level)
            outfile.write('columName = "%s",\n' % (self.columName,))
        if self.suppress is not None and 'suppress' not in already_processed:
            already_processed.append('suppress')
            showIndent(outfile, level)
            outfile.write('suppress = "%s",\n' % (self.suppress,))
        if self.tableName is not None and 'tableName' not in already_processed:
            already_processed.append('tableName')
            showIndent(outfile, level)
            outfile.write('tableName = "%s",\n' % (self.tableName,))
        if self.visibility is not None and 'visibility' not in already_processed:
            already_processed.append('visibility')
            showIndent(outfile, level)
            outfile.write('visibility = "%s",\n' % (self.visibility,))
        if self.edgeSeq is not None and 'edgeSeq' not in already_processed:
            already_processed.append('edgeSeq')
            showIndent(outfile, level)
            outfile.write('edgeSeq = "%s",\n' % (self.edgeSeq,))
        if self.measurePosition is not None and 'measurePosition' not in already_processed:
            already_processed.append('measurePosition')
            showIndent(outfile, level)
            outfile.write('measurePosition = "%s",\n' % (self.measurePosition,))
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            showIndent(outfile, level)
            outfile.write('formula = "%s",\n' % (self.formula,))
        if self.aggRule is not None and 'aggRule' not in already_processed:
            already_processed.append('aggRule')
            showIndent(outfile, level)
            outfile.write('aggRule = "%s",\n' % (self.aggRule,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dataFormat is not None:
            showIndent(outfile, level)
            outfile.write('dataFormat=model_.dataFormat(\n')
            self.dataFormat.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('navigation=[\n')
        level += 1
        for navigation_ in self.navigation:
            showIndent(outfile, level)
            outfile.write('model_.nodeType(\n')
            navigation_.exportLiteral(outfile, level, name_='nodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.columnHeading is not None:
            showIndent(outfile, level)
            outfile.write('columnHeading=model_.columnHeadingType(\n')
            self.columnHeading.exportLiteral(outfile, level, name_='columnHeading')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('drillColumn=[\n')
        level += 1
        for drillColumn_ in self.drillColumn:
            showIndent(outfile, level)
            outfile.write('model_.drillColumn(\n')
            drillColumn_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interaction', node)
        if value is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            self.interaction = value
        value = find_attr_value_('columnId', node)
        if value is not None and 'columnId' not in already_processed:
            already_processed.append('columnId')
            self.columnId = value
        value = find_attr_value_('columName', node)
        if value is not None and 'columName' not in already_processed:
            already_processed.append('columName')
            self.columName = value
        value = find_attr_value_('suppress', node)
        if value is not None and 'suppress' not in already_processed:
            already_processed.append('suppress')
            self.suppress = value
        value = find_attr_value_('tableName', node)
        if value is not None and 'tableName' not in already_processed:
            already_processed.append('tableName')
            self.tableName = value
        value = find_attr_value_('visibility', node)
        if value is not None and 'visibility' not in already_processed:
            already_processed.append('visibility')
            self.visibility = value
        value = find_attr_value_('edgeSeq', node)
        if value is not None and 'edgeSeq' not in already_processed:
            already_processed.append('edgeSeq')
            self.edgeSeq = value
        value = find_attr_value_('measurePosition', node)
        if value is not None and 'measurePosition' not in already_processed:
            already_processed.append('measurePosition')
            self.measurePosition = value
        value = find_attr_value_('formula', node)
        if value is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            self.formula = value
        value = find_attr_value_('aggRule', node)
        if value is not None and 'aggRule' not in already_processed:
            already_processed.append('aggRule')
            self.aggRule = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataFormat':
            obj_ = dataFormat.factory()
            obj_.build(child_)
            self.set_dataFormat(obj_)
        elif nodeName_ == 'navigation':
            obj_ = nodeType.factory()
            obj_.build(child_)
            self.navigation.append(obj_)
        elif nodeName_ == 'columnHeading':
            obj_ = columnHeadingType.factory()
            obj_.build(child_)
            self.set_columnHeading(obj_)
        elif nodeName_ == 'drillColumn':
            obj_ = drillColumn.factory()
            obj_.build(child_)
            self.drillColumn.append(obj_)
# end class column


class dataFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, negativeType=None, minDigits=None, type_=None, commas=None, maxDigits=None):
        self.negativeType = _cast(None, negativeType)
        self.minDigits = _cast(None, minDigits)
        self.type_ = _cast(None, type_)
        self.commas = _cast(None, commas)
        self.maxDigits = _cast(None, maxDigits)
        pass
    def factory(*args_, **kwargs_):
        if dataFormat.subclass:
            return dataFormat.subclass(*args_, **kwargs_)
        else:
            return dataFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_negativeType(self): return self.negativeType
    def set_negativeType(self, negativeType): self.negativeType = negativeType
    def get_minDigits(self): return self.minDigits
    def set_minDigits(self, minDigits): self.minDigits = minDigits
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_commas(self): return self.commas
    def set_commas(self, commas): self.commas = commas
    def get_maxDigits(self): return self.maxDigits
    def set_maxDigits(self, maxDigits): self.maxDigits = maxDigits
    def export(self, outfile, level, namespace_='', name_='dataFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dataFormat'):
        if self.negativeType is not None and 'negativeType' not in already_processed:
            already_processed.append('negativeType')
            outfile.write(' negativeType=%s' % (self.gds_format_string(quote_attrib(self.negativeType).encode(ExternalEncoding), input_name='negativeType'), ))
        if self.minDigits is not None and 'minDigits' not in already_processed:
            already_processed.append('minDigits')
            outfile.write(' minDigits=%s' % (self.gds_format_string(quote_attrib(self.minDigits).encode(ExternalEncoding), input_name='minDigits'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.commas is not None and 'commas' not in already_processed:
            already_processed.append('commas')
            outfile.write(' commas=%s' % (self.gds_format_string(quote_attrib(self.commas).encode(ExternalEncoding), input_name='commas'), ))
        if self.maxDigits is not None and 'maxDigits' not in already_processed:
            already_processed.append('maxDigits')
            outfile.write(' maxDigits=%s' % (self.gds_format_string(quote_attrib(self.maxDigits).encode(ExternalEncoding), input_name='maxDigits'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dataFormat', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.negativeType is not None and 'negativeType' not in already_processed:
            already_processed.append('negativeType')
            showIndent(outfile, level)
            outfile.write('negativeType = "%s",\n' % (self.negativeType,))
        if self.minDigits is not None and 'minDigits' not in already_processed:
            already_processed.append('minDigits')
            showIndent(outfile, level)
            outfile.write('minDigits = "%s",\n' % (self.minDigits,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.commas is not None and 'commas' not in already_processed:
            already_processed.append('commas')
            showIndent(outfile, level)
            outfile.write('commas = "%s",\n' % (self.commas,))
        if self.maxDigits is not None and 'maxDigits' not in already_processed:
            already_processed.append('maxDigits')
            showIndent(outfile, level)
            outfile.write('maxDigits = "%s",\n' % (self.maxDigits,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('negativeType', node)
        if value is not None and 'negativeType' not in already_processed:
            already_processed.append('negativeType')
            self.negativeType = value
        value = find_attr_value_('minDigits', node)
        if value is not None and 'minDigits' not in already_processed:
            already_processed.append('minDigits')
            self.minDigits = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('commas', node)
        if value is not None and 'commas' not in already_processed:
            already_processed.append('commas')
            self.commas = value
        value = find_attr_value_('maxDigits', node)
        if value is not None and 'maxDigits' not in already_processed:
            already_processed.append('maxDigits')
            self.maxDigits = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dataFormat


class drillColumn(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, columnName=None, tableName=None, weight=None):
        self.columnName = _cast(None, columnName)
        self.tableName = _cast(None, tableName)
        self.weight = _cast(None, weight)
        pass
    def factory(*args_, **kwargs_):
        if drillColumn.subclass:
            return drillColumn.subclass(*args_, **kwargs_)
        else:
            return drillColumn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_columnName(self): return self.columnName
    def set_columnName(self, columnName): self.columnName = columnName
    def get_tableName(self): return self.tableName
    def set_tableName(self, tableName): self.tableName = tableName
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def export(self, outfile, level, namespace_='', name_='drillColumn', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drillColumn')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drillColumn'):
        if self.columnName is not None and 'columnName' not in already_processed:
            already_processed.append('columnName')
            outfile.write(' columnName=%s' % (self.gds_format_string(quote_attrib(self.columnName).encode(ExternalEncoding), input_name='columnName'), ))
        if self.tableName is not None and 'tableName' not in already_processed:
            already_processed.append('tableName')
            outfile.write(' tableName=%s' % (self.gds_format_string(quote_attrib(self.tableName).encode(ExternalEncoding), input_name='tableName'), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.append('weight')
            outfile.write(' weight=%s' % (self.gds_format_string(quote_attrib(self.weight).encode(ExternalEncoding), input_name='weight'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='drillColumn', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='drillColumn'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.columnName is not None and 'columnName' not in already_processed:
            already_processed.append('columnName')
            showIndent(outfile, level)
            outfile.write('columnName = "%s",\n' % (self.columnName,))
        if self.tableName is not None and 'tableName' not in already_processed:
            already_processed.append('tableName')
            showIndent(outfile, level)
            outfile.write('tableName = "%s",\n' % (self.tableName,))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.append('weight')
            showIndent(outfile, level)
            outfile.write('weight = "%s",\n' % (self.weight,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('columnName', node)
        if value is not None and 'columnName' not in already_processed:
            already_processed.append('columnName')
            self.columnName = value
        value = find_attr_value_('tableName', node)
        if value is not None and 'tableName' not in already_processed:
            already_processed.append('tableName')
            self.tableName = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.append('weight')
            self.weight = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class drillColumn


class columnRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, merge=None, direction=None, total=None, columnID=None):
        self.merge = _cast(None, merge)
        self.direction = _cast(None, direction)
        self.total = _cast(None, total)
        self.columnID = _cast(None, columnID)
        pass
    def factory(*args_, **kwargs_):
        if columnRef.subclass:
            return columnRef.subclass(*args_, **kwargs_)
        else:
            return columnRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_merge(self): return self.merge
    def set_merge(self, merge): self.merge = merge
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_total(self): return self.total
    def set_total(self, total): self.total = total
    def get_columnID(self): return self.columnID
    def set_columnID(self, columnID): self.columnID = columnID
    def export(self, outfile, level, namespace_='', name_='columnRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='columnRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='columnRef'):
        if self.merge is not None and 'merge' not in already_processed:
            already_processed.append('merge')
            outfile.write(' merge=%s' % (self.gds_format_string(quote_attrib(self.merge).encode(ExternalEncoding), input_name='merge'), ))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            outfile.write(' direction=%s' % (self.gds_format_string(quote_attrib(self.direction).encode(ExternalEncoding), input_name='direction'), ))
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            outfile.write(' total=%s' % (self.gds_format_string(quote_attrib(self.total).encode(ExternalEncoding), input_name='total'), ))
        if self.columnID is not None and 'columnID' not in already_processed:
            already_processed.append('columnID')
            outfile.write(' columnID=%s' % (self.gds_format_string(quote_attrib(self.columnID).encode(ExternalEncoding), input_name='columnID'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='columnRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='columnRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.merge is not None and 'merge' not in already_processed:
            already_processed.append('merge')
            showIndent(outfile, level)
            outfile.write('merge = "%s",\n' % (self.merge,))
        if self.direction is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            showIndent(outfile, level)
            outfile.write('direction = "%s",\n' % (self.direction,))
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            showIndent(outfile, level)
            outfile.write('total = "%s",\n' % (self.total,))
        if self.columnID is not None and 'columnID' not in already_processed:
            already_processed.append('columnID')
            showIndent(outfile, level)
            outfile.write('columnID = "%s",\n' % (self.columnID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('merge', node)
        if value is not None and 'merge' not in already_processed:
            already_processed.append('merge')
            self.merge = value
        value = find_attr_value_('direction', node)
        if value is not None and 'direction' not in already_processed:
            already_processed.append('direction')
            self.direction = value
        value = find_attr_value_('total', node)
        if value is not None and 'total' not in already_processed:
            already_processed.append('total')
            self.total = value
        value = find_attr_value_('columnID', node)
        if value is not None and 'columnID' not in already_processed:
            already_processed.append('columnID')
            self.columnID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class columnRef


class expr(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, exprValue=None, exprType=None, op=None, expr=None):
        self.exprValue = _cast(None, exprValue)
        self.exprType = _cast(None, exprType)
        self.op = _cast(None, op)
        if expr is None:
            self.expr = []
        else:
            self.expr = expr
    def factory(*args_, **kwargs_):
        if expr.subclass:
            return expr.subclass(*args_, **kwargs_)
        else:
            return expr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expr(self): return self.expr
    def set_expr(self, expr): self.expr = expr
    def add_expr(self, value): self.expr.append(value)
    def insert_expr(self, index, value): self.expr[index] = value
    def get_exprValue(self): return self.exprValue
    def set_exprValue(self, exprValue): self.exprValue = exprValue
    def get_exprType(self): return self.exprType
    def set_exprType(self, exprType): self.exprType = exprType
    def get_op(self): return self.op
    def set_op(self, op): self.op = op
    def export(self, outfile, level, namespace_='', name_='expr', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='expr')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='expr'):
        if self.exprValue is not None and 'exprValue' not in already_processed:
            already_processed.append('exprValue')
            outfile.write(' exprValue=%s' % (self.gds_format_string(quote_attrib(self.exprValue).encode(ExternalEncoding), input_name='exprValue'), ))
        if self.exprType is not None and 'exprType' not in already_processed:
            already_processed.append('exprType')
            outfile.write(' exprType=%s' % (self.gds_format_string(quote_attrib(self.exprType).encode(ExternalEncoding), input_name='exprType'), ))
        if self.op is not None and 'op' not in already_processed:
            already_processed.append('op')
            outfile.write(' op=%s' % (self.gds_format_string(quote_attrib(self.op).encode(ExternalEncoding), input_name='op'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='expr', fromsubclass_=False):
        for expr_ in self.expr:
            expr_.export(outfile, level, namespace_, name_='expr')
    def hasContent_(self):
        if (
            self.expr
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='expr'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.exprValue is not None and 'exprValue' not in already_processed:
            already_processed.append('exprValue')
            showIndent(outfile, level)
            outfile.write('exprValue = "%s",\n' % (self.exprValue,))
        if self.exprType is not None and 'exprType' not in already_processed:
            already_processed.append('exprType')
            showIndent(outfile, level)
            outfile.write('exprType = "%s",\n' % (self.exprType,))
        if self.op is not None and 'op' not in already_processed:
            already_processed.append('op')
            showIndent(outfile, level)
            outfile.write('op = "%s",\n' % (self.op,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expr=[\n')
        level += 1
        for expr_ in self.expr:
            showIndent(outfile, level)
            outfile.write('model_.expr(\n')
            expr_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exprValue', node)
        if value is not None and 'exprValue' not in already_processed:
            already_processed.append('exprValue')
            self.exprValue = value
        value = find_attr_value_('exprType', node)
        if value is not None and 'exprType' not in already_processed:
            already_processed.append('exprType')
            self.exprType = value
        value = find_attr_value_('op', node)
        if value is not None and 'op' not in already_processed:
            already_processed.append('op')
            self.op = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expr':
            obj_ = expr.factory()
            obj_.build(child_)
            self.expr.append(obj_)
# end class expr


class filter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, expr=None):
        if expr is None:
            self.expr = []
        else:
            self.expr = expr
    def factory(*args_, **kwargs_):
        if filter.subclass:
            return filter.subclass(*args_, **kwargs_)
        else:
            return filter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expr(self): return self.expr
    def set_expr(self, expr): self.expr = expr
    def add_expr(self, value): self.expr.append(value)
    def insert_expr(self, index, value): self.expr[index] = value
    def export(self, outfile, level, namespace_='', name_='filter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='filter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='filter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='filter', fromsubclass_=False):
        for expr_ in self.expr:
            expr_.export(outfile, level, namespace_, name_='expr')
    def hasContent_(self):
        if (
            self.expr
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='filter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expr=[\n')
        level += 1
        for expr_ in self.expr:
            showIndent(outfile, level)
            outfile.write('model_.expr(\n')
            expr_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expr':
            obj_ = expr.factory()
            obj_.build(child_)
            self.expr.append(obj_)
# end class filter


class criteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, schema=None, columns=None, columnOrder=None, filter=None, drillColumns=None, sql=None):
        self.name = _cast(None, name)
        self.schema = _cast(None, schema)
        self.columns = columns
        self.columnOrder = columnOrder
        self.filter = filter
        self.drillColumns = drillColumns
        self.sql = sql
    def factory(*args_, **kwargs_):
        if criteria.subclass:
            return criteria.subclass(*args_, **kwargs_)
        else:
            return criteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_columns(self): return self.columns
    def set_columns(self, columns): self.columns = columns
    def get_columnOrder(self): return self.columnOrder
    def set_columnOrder(self, columnOrder): self.columnOrder = columnOrder
    def get_filter(self): return self.filter
    def set_filter(self, filter): self.filter = filter
    def get_drillColumns(self): return self.drillColumns
    def set_drillColumns(self, drillColumns): self.drillColumns = drillColumns
    def get_sql(self): return self.sql
    def set_sql(self, sql): self.sql = sql
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_schema(self): return self.schema
    def set_schema(self, schema): self.schema = schema
    def export(self, outfile, level, namespace_='', name_='criteria', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='criteria')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='criteria'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.append('schema')
            outfile.write(' schema=%s' % (self.gds_format_string(quote_attrib(self.schema).encode(ExternalEncoding), input_name='schema'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='criteria', fromsubclass_=False):
        if self.columns:
            self.columns.export(outfile, level, namespace_, name_='columns', )
        if self.columnOrder:
            self.columnOrder.export(outfile, level, namespace_, name_='columnOrder')
        if self.filter:
            self.filter.export(outfile, level, namespace_, name_='filter')
        if self.drillColumns:
            self.drillColumns.export(outfile, level, namespace_, name_='drillColumns')
        if self.sql is not None:
            showIndent(outfile, level)
            outfile.write('<%ssql>%s</%ssql>\n' % (namespace_, self.gds_format_string(quote_xml(self.sql).encode(ExternalEncoding), input_name='sql'), namespace_))
    def hasContent_(self):
        if (
            self.columns is not None or
            self.columnOrder is not None or
            self.filter is not None or
            self.drillColumns is not None or
            self.sql is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='criteria'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.append('schema')
            showIndent(outfile, level)
            outfile.write('schema = "%s",\n' % (self.schema,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.columns is not None:
            showIndent(outfile, level)
            outfile.write('columns=model_.columns(\n')
            self.columns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.columnOrder is not None:
            showIndent(outfile, level)
            outfile.write('columnOrder=model_.columnOrder(\n')
            self.columnOrder.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filter is not None:
            showIndent(outfile, level)
            outfile.write('filter=model_.filter(\n')
            self.filter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.drillColumns is not None:
            showIndent(outfile, level)
            outfile.write('drillColumns=model_.drillColumns(\n')
            self.drillColumns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sql is not None:
            showIndent(outfile, level)
            outfile.write('sql=%s,\n' % quote_python(self.sql).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.append('schema')
            self.schema = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'columns':
            obj_ = columns.factory()
            obj_.build(child_)
            self.set_columns(obj_)
        elif nodeName_ == 'columnOrder':
            obj_ = columnOrder.factory()
            obj_.build(child_)
            self.set_columnOrder(obj_)
        elif nodeName_ == 'filter':
            obj_ = filter.factory()
            obj_.build(child_)
            self.set_filter(obj_)
        elif nodeName_ == 'drillColumns':
            obj_ = drillColumns.factory()
            obj_.build(child_)
            self.set_drillColumns(obj_)
        elif nodeName_ == 'sql':
            sql_ = child_.text
            sql_ = self.gds_validate_string(sql_, node, 'sql')
            self.sql = sql_
# end class criteria


class columns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if columns.subclass:
            return columns.subclass(*args_, **kwargs_)
        else:
            return columns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def export(self, outfile, level, namespace_='', name_='columns', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='columns')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='columns'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='columns', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='columns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
# end class columns


class columnOrder(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, columnRef=None):
        if columnRef is None:
            self.columnRef = []
        else:
            self.columnRef = columnRef
    def factory(*args_, **kwargs_):
        if columnOrder.subclass:
            return columnOrder.subclass(*args_, **kwargs_)
        else:
            return columnOrder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_columnRef(self): return self.columnRef
    def set_columnRef(self, columnRef): self.columnRef = columnRef
    def add_columnRef(self, value): self.columnRef.append(value)
    def insert_columnRef(self, index, value): self.columnRef[index] = value
    def export(self, outfile, level, namespace_='', name_='columnOrder', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='columnOrder')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='columnOrder'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='columnOrder', fromsubclass_=False):
        for columnRef_ in self.columnRef:
            columnRef_.export(outfile, level, namespace_, name_='columnRef')
    def hasContent_(self):
        if (
            self.columnRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='columnOrder'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('columnRef=[\n')
        level += 1
        for columnRef_ in self.columnRef:
            showIndent(outfile, level)
            outfile.write('model_.columnRef(\n')
            columnRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'columnRef':
            obj_ = columnRef.factory()
            obj_.build(child_)
            self.columnRef.append(obj_)
# end class columnOrder


class drillColumns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if drillColumns.subclass:
            return drillColumns.subclass(*args_, **kwargs_)
        else:
            return drillColumns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def export(self, outfile, level, namespace_='', name_='drillColumns', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drillColumns')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='drillColumns'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='drillColumns', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='drillColumns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
# end class drillColumns


class sql(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if sql.subclass:
            return sql.subclass(*args_, **kwargs_)
        else:
            return sql(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='sql', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sql')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sql'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sql', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sql'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sql


class views(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, chart=None, pivotTable=None, columnSelector=None, compoundView=None, viewSelector=None, narrativeView=None, tableView=None, spreadsheet=None, mapView=None):
        if chart is None:
            self.chart = []
        else:
            self.chart = chart
        if pivotTable is None:
            self.pivotTable = []
        else:
            self.pivotTable = pivotTable
        if columnSelector is None:
            self.columnSelector = []
        else:
            self.columnSelector = columnSelector
        if compoundView is None:
            self.compoundView = []
        else:
            self.compoundView = compoundView
        if viewSelector is None:
            self.viewSelector = []
        else:
            self.viewSelector = viewSelector
        if narrativeView is None:
            self.narrativeView = []
        else:
            self.narrativeView = narrativeView
        if tableView is None:
            self.tableView = []
        else:
            self.tableView = tableView
        if spreadsheet is None:
            self.spreadsheet = []
        else:
            self.spreadsheet = spreadsheet
        if mapView is None:
            self.mapView = []
        else:
            self.mapView = mapView
    def factory(*args_, **kwargs_):
        if views.subclass:
            return views.subclass(*args_, **kwargs_)
        else:
            return views(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chart(self): return self.chart
    def set_chart(self, chart): self.chart = chart
    def add_chart(self, value): self.chart.append(value)
    def insert_chart(self, index, value): self.chart[index] = value
    def get_pivotTable(self): return self.pivotTable
    def set_pivotTable(self, pivotTable): self.pivotTable = pivotTable
    def add_pivotTable(self, value): self.pivotTable.append(value)
    def insert_pivotTable(self, index, value): self.pivotTable[index] = value
    def get_columnSelector(self): return self.columnSelector
    def set_columnSelector(self, columnSelector): self.columnSelector = columnSelector
    def add_columnSelector(self, value): self.columnSelector.append(value)
    def insert_columnSelector(self, index, value): self.columnSelector[index] = value
    def get_compoundView(self): return self.compoundView
    def set_compoundView(self, compoundView): self.compoundView = compoundView
    def add_compoundView(self, value): self.compoundView.append(value)
    def insert_compoundView(self, index, value): self.compoundView[index] = value
    def get_viewSelector(self): return self.viewSelector
    def set_viewSelector(self, viewSelector): self.viewSelector = viewSelector
    def add_viewSelector(self, value): self.viewSelector.append(value)
    def insert_viewSelector(self, index, value): self.viewSelector[index] = value
    def get_narrativeView(self): return self.narrativeView
    def set_narrativeView(self, narrativeView): self.narrativeView = narrativeView
    def add_narrativeView(self, value): self.narrativeView.append(value)
    def insert_narrativeView(self, index, value): self.narrativeView[index] = value
    def get_tableView(self): return self.tableView
    def set_tableView(self, tableView): self.tableView = tableView
    def add_tableView(self, value): self.tableView.append(value)
    def insert_tableView(self, index, value): self.tableView[index] = value
    def get_spreadsheet(self): return self.spreadsheet
    def set_spreadsheet(self, spreadsheet): self.spreadsheet = spreadsheet
    def add_spreadsheet(self, value): self.spreadsheet.append(value)
    def insert_spreadsheet(self, index, value): self.spreadsheet[index] = value
    def get_mapView(self): return self.mapView
    def set_mapView(self, mapView): self.mapView = mapView
    def add_mapView(self, value): self.mapView.append(value)
    def insert_mapView(self, index, value): self.mapView[index] = value
    def export(self, outfile, level, namespace_='', name_='views', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='views')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='views'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='views', fromsubclass_=False):
        for chart_ in self.chart:
            chart_.export(outfile, level, namespace_, name_='chart')
        for pivotTable_ in self.pivotTable:
            pivotTable_.export(outfile, level, namespace_, name_='pivotTable')
        for columnSelector_ in self.columnSelector:
            columnSelector_.export(outfile, level, namespace_, name_='columnSelector')
        for compoundView_ in self.compoundView:
            compoundView_.export(outfile, level, namespace_, name_='compoundView')
        for viewSelector_ in self.viewSelector:
            viewSelector_.export(outfile, level, namespace_, name_='viewSelector')
        for narrativeView_ in self.narrativeView:
            narrativeView_.export(outfile, level, namespace_, name_='narrativeView')
        for tableView_ in self.tableView:
            tableView_.export(outfile, level, namespace_, name_='tableView')
        for spreadsheet_ in self.spreadsheet:
            spreadsheet_.export(outfile, level, namespace_, name_='spreadsheet')
        for mapView_ in self.mapView:
            mapView_.export(outfile, level, namespace_, name_='mapView')
    def hasContent_(self):
        if (
            self.chart or
            self.pivotTable or
            self.columnSelector or
            self.compoundView or
            self.viewSelector or
            self.narrativeView or
            self.tableView or
            self.spreadsheet or
            self.mapView
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='views'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('chart=[\n')
        level += 1
        for chart_ in self.chart:
            showIndent(outfile, level)
            outfile.write('model_.chart(\n')
            chart_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pivotTable=[\n')
        level += 1
        for pivotTable_ in self.pivotTable:
            showIndent(outfile, level)
            outfile.write('model_.pivotTable(\n')
            pivotTable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('columnSelector=[\n')
        level += 1
        for columnSelector_ in self.columnSelector:
            showIndent(outfile, level)
            outfile.write('model_.columnSelector(\n')
            columnSelector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('compoundView=[\n')
        level += 1
        for compoundView_ in self.compoundView:
            showIndent(outfile, level)
            outfile.write('model_.compoundView(\n')
            compoundView_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('viewSelector=[\n')
        level += 1
        for viewSelector_ in self.viewSelector:
            showIndent(outfile, level)
            outfile.write('model_.viewSelector(\n')
            viewSelector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('narrativeView=[\n')
        level += 1
        for narrativeView_ in self.narrativeView:
            showIndent(outfile, level)
            outfile.write('model_.narrativeView(\n')
            narrativeView_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tableView=[\n')
        level += 1
        for tableView_ in self.tableView:
            showIndent(outfile, level)
            outfile.write('model_.tableView(\n')
            tableView_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spreadsheet=[\n')
        level += 1
        for spreadsheet_ in self.spreadsheet:
            showIndent(outfile, level)
            outfile.write('model_.spreadsheet(\n')
            spreadsheet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('mapView=[\n')
        level += 1
        for mapView_ in self.mapView:
            showIndent(outfile, level)
            outfile.write('model_.mapView(\n')
            mapView_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chart':
            obj_ = chart.factory()
            obj_.build(child_)
            self.chart.append(obj_)
        elif nodeName_ == 'pivotTable':
            obj_ = pivotTable.factory()
            obj_.build(child_)
            self.pivotTable.append(obj_)
        elif nodeName_ == 'columnSelector':
            obj_ = columnSelector.factory()
            obj_.build(child_)
            self.columnSelector.append(obj_)
        elif nodeName_ == 'compoundView':
            obj_ = compoundView.factory()
            obj_.build(child_)
            self.compoundView.append(obj_)
        elif nodeName_ == 'viewSelector':
            obj_ = viewSelector.factory()
            obj_.build(child_)
            self.viewSelector.append(obj_)
        elif nodeName_ == 'narrativeView':
            obj_ = narrativeView.factory()
            obj_.build(child_)
            self.narrativeView.append(obj_)
        elif nodeName_ == 'tableView':
            obj_ = tableView.factory()
            obj_.build(child_)
            self.tableView.append(obj_)
        elif nodeName_ == 'spreadsheet':
            obj_ = spreadsheet.factory()
            obj_.build(child_)
            self.spreadsheet.append(obj_)
        elif nodeName_ == 'mapView':
            obj_ = mapView.factory()
            obj_.build(child_)
            self.mapView.append(obj_)
# end class views


class columnSelector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, name=None, selector=None):
        self.caption = _cast(None, caption)
        self.name = _cast(None, name)
        if selector is None:
            self.selector = []
        else:
            self.selector = selector
    def factory(*args_, **kwargs_):
        if columnSelector.subclass:
            return columnSelector.subclass(*args_, **kwargs_)
        else:
            return columnSelector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_selector(self): return self.selector
    def set_selector(self, selector): self.selector = selector
    def add_selector(self, value): self.selector.append(value)
    def insert_selector(self, index, value): self.selector[index] = value
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='columnSelector', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='columnSelector')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='columnSelector'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='columnSelector', fromsubclass_=False):
        for selector_ in self.selector:
            selector_.export(outfile, level, namespace_, name_='selector')
    def hasContent_(self):
        if (
            self.selector
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='columnSelector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('selector=[\n')
        level += 1
        for selector_ in self.selector:
            showIndent(outfile, level)
            outfile.write('model_.selector(\n')
            selector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'selector':
            obj_ = selector.factory()
            obj_.build(child_)
            self.selector.append(obj_)
# end class columnSelector


class selector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, columnId=None, choice=None):
        self.caption = _cast(None, caption)
        self.columnId = _cast(None, columnId)
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
    def factory(*args_, **kwargs_):
        if selector.subclass:
            return selector.subclass(*args_, **kwargs_)
        else:
            return selector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_choice(self): return self.choice
    def set_choice(self, choice): self.choice = choice
    def add_choice(self, value): self.choice.append(value)
    def insert_choice(self, index, value): self.choice[index] = value
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_columnId(self): return self.columnId
    def set_columnId(self, columnId): self.columnId = columnId
    def export(self, outfile, level, namespace_='', name_='selector', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='selector')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='selector'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.columnId is not None and 'columnId' not in already_processed:
            already_processed.append('columnId')
            outfile.write(' columnId=%s' % (self.gds_format_string(quote_attrib(self.columnId).encode(ExternalEncoding), input_name='columnId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='selector', fromsubclass_=False):
        for choice_ in self.choice:
            choice_.export(outfile, level, namespace_, name_='choice')
    def hasContent_(self):
        if (
            self.choice
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='selector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.columnId is not None and 'columnId' not in already_processed:
            already_processed.append('columnId')
            showIndent(outfile, level)
            outfile.write('columnId = "%s",\n' % (self.columnId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('choice=[\n')
        level += 1
        for choice_ in self.choice:
            showIndent(outfile, level)
            outfile.write('model_.choice(\n')
            choice_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('columnId', node)
        if value is not None and 'columnId' not in already_processed:
            already_processed.append('columnId')
            self.columnId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'choice':
            obj_ = choice.factory()
            obj_.build(child_)
            self.choice.append(obj_)
# end class selector


class choice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, formula=None, interaction=None, suppress=None, navigation=None, columnHeading=None):
        self.formula = _cast(None, formula)
        self.interaction = _cast(None, interaction)
        self.suppress = _cast(None, suppress)
        if navigation is None:
            self.navigation = []
        else:
            self.navigation = navigation
        self.columnHeading = columnHeading
    def factory(*args_, **kwargs_):
        if choice.subclass:
            return choice.subclass(*args_, **kwargs_)
        else:
            return choice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_navigation(self): return self.navigation
    def set_navigation(self, navigation): self.navigation = navigation
    def add_navigation(self, value): self.navigation.append(value)
    def insert_navigation(self, index, value): self.navigation[index] = value
    def get_columnHeading(self): return self.columnHeading
    def set_columnHeading(self, columnHeading): self.columnHeading = columnHeading
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_interaction(self): return self.interaction
    def set_interaction(self, interaction): self.interaction = interaction
    def get_suppress(self): return self.suppress
    def set_suppress(self, suppress): self.suppress = suppress
    def export(self, outfile, level, namespace_='', name_='choice', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='choice')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='choice'):
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            outfile.write(' formula=%s' % (self.gds_format_string(quote_attrib(self.formula).encode(ExternalEncoding), input_name='formula'), ))
        if self.interaction is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            outfile.write(' interaction=%s' % (self.gds_format_string(quote_attrib(self.interaction).encode(ExternalEncoding), input_name='interaction'), ))
        if self.suppress is not None and 'suppress' not in already_processed:
            already_processed.append('suppress')
            outfile.write(' suppress=%s' % (self.gds_format_string(quote_attrib(self.suppress).encode(ExternalEncoding), input_name='suppress'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='choice', fromsubclass_=False):
        for navigation_ in self.navigation:
            navigation_.export(outfile, level, namespace_, name_='navigation')
        if self.columnHeading:
            self.columnHeading.export(outfile, level, namespace_, name_='columnHeading', )
    def hasContent_(self):
        if (
            self.navigation or
            self.columnHeading is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='choice'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            showIndent(outfile, level)
            outfile.write('formula = "%s",\n' % (self.formula,))
        if self.interaction is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            showIndent(outfile, level)
            outfile.write('interaction = "%s",\n' % (self.interaction,))
        if self.suppress is not None and 'suppress' not in already_processed:
            already_processed.append('suppress')
            showIndent(outfile, level)
            outfile.write('suppress = "%s",\n' % (self.suppress,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('navigation=[\n')
        level += 1
        for navigation_ in self.navigation:
            showIndent(outfile, level)
            outfile.write('model_.nodeType(\n')
            navigation_.exportLiteral(outfile, level, name_='nodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.columnHeading is not None:
            showIndent(outfile, level)
            outfile.write('columnHeading=model_.columnHeadingType(\n')
            self.columnHeading.exportLiteral(outfile, level, name_='columnHeading')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('formula', node)
        if value is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            self.formula = value
        value = find_attr_value_('interaction', node)
        if value is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            self.interaction = value
        value = find_attr_value_('suppress', node)
        if value is not None and 'suppress' not in already_processed:
            already_processed.append('suppress')
            self.suppress = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'navigation':
            obj_ = nodeType.factory()
            obj_.build(child_)
            self.navigation.append(obj_)
        elif nodeName_ == 'columnHeading':
            obj_ = columnHeadingType.factory()
            obj_.build(child_)
            self.set_columnHeading(obj_)
# end class choice


class compoundView(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, name=None, cell=None):
        self.caption = _cast(None, caption)
        self.name = _cast(None, name)
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if compoundView.subclass:
            return compoundView.subclass(*args_, **kwargs_)
        else:
            return compoundView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='compoundView', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='compoundView')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='compoundView'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='compoundView', fromsubclass_=False):
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='compoundView'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.cell(\n')
            cell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cell':
            obj_ = cell.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class compoundView


class cell(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, viewType=None, viewName=None):
        self.viewType = _cast(None, viewType)
        self.viewName = _cast(None, viewName)
        pass
    def factory(*args_, **kwargs_):
        if cell.subclass:
            return cell.subclass(*args_, **kwargs_)
        else:
            return cell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewType(self): return self.viewType
    def set_viewType(self, viewType): self.viewType = viewType
    def get_viewName(self): return self.viewName
    def set_viewName(self, viewName): self.viewName = viewName
    def export(self, outfile, level, namespace_='', name_='cell', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cell')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cell'):
        if self.viewType is not None and 'viewType' not in already_processed:
            already_processed.append('viewType')
            outfile.write(' viewType=%s' % (self.gds_format_string(quote_attrib(self.viewType).encode(ExternalEncoding), input_name='viewType'), ))
        if self.viewName is not None and 'viewName' not in already_processed:
            already_processed.append('viewName')
            outfile.write(' viewName=%s' % (self.gds_format_string(quote_attrib(self.viewName).encode(ExternalEncoding), input_name='viewName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cell', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cell'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.viewType is not None and 'viewType' not in already_processed:
            already_processed.append('viewType')
            showIndent(outfile, level)
            outfile.write('viewType = "%s",\n' % (self.viewType,))
        if self.viewName is not None and 'viewName' not in already_processed:
            already_processed.append('viewName')
            showIndent(outfile, level)
            outfile.write('viewName = "%s",\n' % (self.viewName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('viewType', node)
        if value is not None and 'viewType' not in already_processed:
            already_processed.append('viewType')
            self.viewType = value
        value = find_attr_value_('viewName', node)
        if value is not None and 'viewName' not in already_processed:
            already_processed.append('viewName')
            self.viewName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cell


class viewSelector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, name=None, viewItem=None):
        self.caption = _cast(None, caption)
        self.name = _cast(None, name)
        if viewItem is None:
            self.viewItem = []
        else:
            self.viewItem = viewItem
    def factory(*args_, **kwargs_):
        if viewSelector.subclass:
            return viewSelector.subclass(*args_, **kwargs_)
        else:
            return viewSelector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewItem(self): return self.viewItem
    def set_viewItem(self, viewItem): self.viewItem = viewItem
    def add_viewItem(self, value): self.viewItem.append(value)
    def insert_viewItem(self, index, value): self.viewItem[index] = value
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='viewSelector', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewSelector')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='viewSelector'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='viewSelector', fromsubclass_=False):
        for viewItem_ in self.viewItem:
            viewItem_.export(outfile, level, namespace_, name_='viewItem')
    def hasContent_(self):
        if (
            self.viewItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='viewSelector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('viewItem=[\n')
        level += 1
        for viewItem_ in self.viewItem:
            showIndent(outfile, level)
            outfile.write('model_.viewItem(\n')
            viewItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'viewItem':
            obj_ = viewItem.factory()
            obj_.build(child_)
            self.viewItem.append(obj_)
# end class viewSelector


class viewItem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, viewType=None, viewName=None):
        self.caption = _cast(None, caption)
        self.viewType = _cast(None, viewType)
        self.viewName = _cast(None, viewName)
        pass
    def factory(*args_, **kwargs_):
        if viewItem.subclass:
            return viewItem.subclass(*args_, **kwargs_)
        else:
            return viewItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_viewType(self): return self.viewType
    def set_viewType(self, viewType): self.viewType = viewType
    def get_viewName(self): return self.viewName
    def set_viewName(self, viewName): self.viewName = viewName
    def export(self, outfile, level, namespace_='', name_='viewItem', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewItem')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='viewItem'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.viewType is not None and 'viewType' not in already_processed:
            already_processed.append('viewType')
            outfile.write(' viewType=%s' % (self.gds_format_string(quote_attrib(self.viewType).encode(ExternalEncoding), input_name='viewType'), ))
        if self.viewName is not None and 'viewName' not in already_processed:
            already_processed.append('viewName')
            outfile.write(' viewName=%s' % (self.gds_format_string(quote_attrib(self.viewName).encode(ExternalEncoding), input_name='viewName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='viewItem', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='viewItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.viewType is not None and 'viewType' not in already_processed:
            already_processed.append('viewType')
            showIndent(outfile, level)
            outfile.write('viewType = "%s",\n' % (self.viewType,))
        if self.viewName is not None and 'viewName' not in already_processed:
            already_processed.append('viewName')
            showIndent(outfile, level)
            outfile.write('viewName = "%s",\n' % (self.viewName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('viewType', node)
        if value is not None and 'viewType' not in already_processed:
            already_processed.append('viewType')
            self.viewType = value
        value = find_attr_value_('viewName', node)
        if value is not None and 'viewName' not in already_processed:
            already_processed.append('viewName')
            self.viewName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewItem


class narrativeView(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, fmt=None, name=None, prefix=None, narrative=None, rowCount=None, rowSep=None, postfix=None):
        self.caption = _cast(None, caption)
        self.fmt = _cast(None, fmt)
        self.name = _cast(None, name)
        self.prefix = prefix
        self.narrative = narrative
        self.rowCount = rowCount
        self.rowSep = rowSep
        self.postfix = postfix
    def factory(*args_, **kwargs_):
        if narrativeView.subclass:
            return narrativeView.subclass(*args_, **kwargs_)
        else:
            return narrativeView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_narrative(self): return self.narrative
    def set_narrative(self, narrative): self.narrative = narrative
    def get_rowCount(self): return self.rowCount
    def set_rowCount(self, rowCount): self.rowCount = rowCount
    def get_rowSep(self): return self.rowSep
    def set_rowSep(self, rowSep): self.rowSep = rowSep
    def get_postfix(self): return self.postfix
    def set_postfix(self, postfix): self.postfix = postfix
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_fmt(self): return self.fmt
    def set_fmt(self, fmt): self.fmt = fmt
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='narrativeView', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='narrativeView')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='narrativeView'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.fmt is not None and 'fmt' not in already_processed:
            already_processed.append('fmt')
            outfile.write(' fmt=%s' % (self.gds_format_string(quote_attrib(self.fmt).encode(ExternalEncoding), input_name='fmt'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='narrativeView', fromsubclass_=False):
        if self.prefix is not None:
            showIndent(outfile, level)
            outfile.write('<%sprefix>%s</%sprefix>\n' % (namespace_, self.gds_format_string(quote_xml(self.prefix).encode(ExternalEncoding), input_name='prefix'), namespace_))
        if self.narrative is not None:
            showIndent(outfile, level)
            outfile.write('<%snarrative>%s</%snarrative>\n' % (namespace_, self.gds_format_string(quote_xml(self.narrative).encode(ExternalEncoding), input_name='narrative'), namespace_))
        if self.rowCount is not None:
            showIndent(outfile, level)
            outfile.write('<%srowCount>%s</%srowCount>\n' % (namespace_, self.gds_format_string(quote_xml(self.rowCount).encode(ExternalEncoding), input_name='rowCount'), namespace_))
        if self.rowSep is not None:
            showIndent(outfile, level)
            outfile.write('<%srowSep>%s</%srowSep>\n' % (namespace_, self.gds_format_string(quote_xml(self.rowSep).encode(ExternalEncoding), input_name='rowSep'), namespace_))
        if self.postfix is not None:
            showIndent(outfile, level)
            outfile.write('<%spostfix>%s</%spostfix>\n' % (namespace_, self.gds_format_string(quote_xml(self.postfix).encode(ExternalEncoding), input_name='postfix'), namespace_))
    def hasContent_(self):
        if (
            self.prefix is not None or
            self.narrative is not None or
            self.rowCount is not None or
            self.rowSep is not None or
            self.postfix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='narrativeView'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.fmt is not None and 'fmt' not in already_processed:
            already_processed.append('fmt')
            showIndent(outfile, level)
            outfile.write('fmt = "%s",\n' % (self.fmt,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.prefix is not None:
            showIndent(outfile, level)
            outfile.write('prefix=%s,\n' % quote_python(self.prefix).encode(ExternalEncoding))
        if self.narrative is not None:
            showIndent(outfile, level)
            outfile.write('narrative=%s,\n' % quote_python(self.narrative).encode(ExternalEncoding))
        if self.rowCount is not None:
            showIndent(outfile, level)
            outfile.write('rowCount=%s,\n' % quote_python(self.rowCount).encode(ExternalEncoding))
        if self.rowSep is not None:
            showIndent(outfile, level)
            outfile.write('rowSep=%s,\n' % quote_python(self.rowSep).encode(ExternalEncoding))
        if self.postfix is not None:
            showIndent(outfile, level)
            outfile.write('postfix=%s,\n' % quote_python(self.postfix).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('fmt', node)
        if value is not None and 'fmt' not in already_processed:
            already_processed.append('fmt')
            self.fmt = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prefix':
            prefix_ = child_.text
            prefix_ = self.gds_validate_string(prefix_, node, 'prefix')
            self.prefix = prefix_
        elif nodeName_ == 'narrative':
            narrative_ = child_.text
            narrative_ = self.gds_validate_string(narrative_, node, 'narrative')
            self.narrative = narrative_
        elif nodeName_ == 'rowCount':
            rowCount_ = child_.text
            rowCount_ = self.gds_validate_string(rowCount_, node, 'rowCount')
            self.rowCount = rowCount_
        elif nodeName_ == 'rowSep':
            rowSep_ = child_.text
            rowSep_ = self.gds_validate_string(rowSep_, node, 'rowSep')
            self.rowSep = rowSep_
        elif nodeName_ == 'postfix':
            postfix_ = child_.text
            postfix_ = self.gds_validate_string(postfix_, node, 'postfix')
            self.postfix = postfix_
# end class narrativeView


class prefix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if prefix.subclass:
            return prefix.subclass(*args_, **kwargs_)
        else:
            return prefix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='prefix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='prefix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='prefix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='prefix', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='prefix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class prefix


class narrative(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if narrative.subclass:
            return narrative.subclass(*args_, **kwargs_)
        else:
            return narrative(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='narrative', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='narrative')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='narrative'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='narrative', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='narrative'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class narrative


class rowCount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if rowCount.subclass:
            return rowCount.subclass(*args_, **kwargs_)
        else:
            return rowCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='rowCount', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rowCount')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rowCount'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rowCount', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rowCount'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rowCount


class rowSep(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if rowSep.subclass:
            return rowSep.subclass(*args_, **kwargs_)
        else:
            return rowSep(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='rowSep', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rowSep')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rowSep'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='rowSep', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rowSep'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class rowSep


class postfix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if postfix.subclass:
            return postfix.subclass(*args_, **kwargs_)
        else:
            return postfix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='postfix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postfix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='postfix'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='postfix', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='postfix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class postfix


class spreadsheet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, name=None, criteriaName=None, ssCorner=None, ssColumns=None, ssRows=None):
        self.caption = _cast(None, caption)
        self.name = _cast(None, name)
        self.criteriaName = _cast(None, criteriaName)
        self.ssCorner = ssCorner
        self.ssColumns = ssColumns
        self.ssRows = ssRows
    def factory(*args_, **kwargs_):
        if spreadsheet.subclass:
            return spreadsheet.subclass(*args_, **kwargs_)
        else:
            return spreadsheet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ssCorner(self): return self.ssCorner
    def set_ssCorner(self, ssCorner): self.ssCorner = ssCorner
    def get_ssColumns(self): return self.ssColumns
    def set_ssColumns(self, ssColumns): self.ssColumns = ssColumns
    def get_ssRows(self): return self.ssRows
    def set_ssRows(self, ssRows): self.ssRows = ssRows
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_criteriaName(self): return self.criteriaName
    def set_criteriaName(self, criteriaName): self.criteriaName = criteriaName
    def export(self, outfile, level, namespace_='', name_='spreadsheet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='spreadsheet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='spreadsheet'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.criteriaName is not None and 'criteriaName' not in already_processed:
            already_processed.append('criteriaName')
            outfile.write(' criteriaName=%s' % (self.gds_format_string(quote_attrib(self.criteriaName).encode(ExternalEncoding), input_name='criteriaName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='spreadsheet', fromsubclass_=False):
        if self.ssCorner:
            self.ssCorner.export(outfile, level, namespace_, name_='ssCorner')
        if self.ssColumns:
            self.ssColumns.export(outfile, level, namespace_, name_='ssColumns')
        if self.ssRows:
            self.ssRows.export(outfile, level, namespace_, name_='ssRows', )
    def hasContent_(self):
        if (
            self.ssCorner is not None or
            self.ssColumns is not None or
            self.ssRows is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='spreadsheet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.criteriaName is not None and 'criteriaName' not in already_processed:
            already_processed.append('criteriaName')
            showIndent(outfile, level)
            outfile.write('criteriaName = "%s",\n' % (self.criteriaName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ssCorner is not None:
            showIndent(outfile, level)
            outfile.write('ssCorner=model_.ssCorner(\n')
            self.ssCorner.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ssColumns is not None:
            showIndent(outfile, level)
            outfile.write('ssColumns=model_.ssColumns(\n')
            self.ssColumns.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ssRows is not None:
            showIndent(outfile, level)
            outfile.write('ssRows=model_.ssRows(\n')
            self.ssRows.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('criteriaName', node)
        if value is not None and 'criteriaName' not in already_processed:
            already_processed.append('criteriaName')
            self.criteriaName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ssCorner':
            obj_ = ssCorner.factory()
            obj_.build(child_)
            self.set_ssCorner(obj_)
        elif nodeName_ == 'ssColumns':
            obj_ = ssColumns.factory()
            obj_.build(child_)
            self.set_ssColumns(obj_)
        elif nodeName_ == 'ssRows':
            obj_ = ssRows.factory()
            obj_.build(child_)
            self.set_ssRows(obj_)
# end class spreadsheet


class ssCorner(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, entry=None):
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
    def factory(*args_, **kwargs_):
        if ssCorner.subclass:
            return ssCorner.subclass(*args_, **kwargs_)
        else:
            return ssCorner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def add_entry(self, value): self.entry.append(value)
    def insert_entry(self, index, value): self.entry[index] = value
    def export(self, outfile, level, namespace_='', name_='ssCorner', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ssCorner')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ssCorner'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ssCorner', fromsubclass_=False):
        for entry_ in self.entry:
            entry_.export(outfile, level, namespace_, name_='entry')
    def hasContent_(self):
        if (
            self.entry
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ssCorner'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('entry=[\n')
        level += 1
        for entry_ in self.entry:
            showIndent(outfile, level)
            outfile.write('model_.entry(\n')
            entry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entry':
            obj_ = entry.factory()
            obj_.build(child_)
            self.entry.append(obj_)
# end class ssCorner


class ssColumns(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ssColumn=None):
        if ssColumn is None:
            self.ssColumn = []
        else:
            self.ssColumn = ssColumn
    def factory(*args_, **kwargs_):
        if ssColumns.subclass:
            return ssColumns.subclass(*args_, **kwargs_)
        else:
            return ssColumns(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ssColumn(self): return self.ssColumn
    def set_ssColumn(self, ssColumn): self.ssColumn = ssColumn
    def add_ssColumn(self, value): self.ssColumn.append(value)
    def insert_ssColumn(self, index, value): self.ssColumn[index] = value
    def export(self, outfile, level, namespace_='', name_='ssColumns', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ssColumns')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ssColumns'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ssColumns', fromsubclass_=False):
        for ssColumn_ in self.ssColumn:
            ssColumn_.export(outfile, level, namespace_, name_='ssColumn')
    def hasContent_(self):
        if (
            self.ssColumn
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ssColumns'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ssColumn=[\n')
        level += 1
        for ssColumn_ in self.ssColumn:
            showIndent(outfile, level)
            outfile.write('model_.ssColumn(\n')
            ssColumn_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ssColumn':
            obj_ = ssColumn.factory()
            obj_.build(child_)
            self.ssColumn.append(obj_)
# end class ssColumns


class ssRows(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ssRow=None):
        if ssRow is None:
            self.ssRow = []
        else:
            self.ssRow = ssRow
    def factory(*args_, **kwargs_):
        if ssRows.subclass:
            return ssRows.subclass(*args_, **kwargs_)
        else:
            return ssRows(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ssRow(self): return self.ssRow
    def set_ssRow(self, ssRow): self.ssRow = ssRow
    def add_ssRow(self, value): self.ssRow.append(value)
    def insert_ssRow(self, index, value): self.ssRow[index] = value
    def export(self, outfile, level, namespace_='', name_='ssRows', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ssRows')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ssRows'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ssRows', fromsubclass_=False):
        for ssRow_ in self.ssRow:
            ssRow_.export(outfile, level, namespace_, name_='ssRow')
    def hasContent_(self):
        if (
            self.ssRow
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ssRows'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ssRow=[\n')
        level += 1
        for ssRow_ in self.ssRow:
            showIndent(outfile, level)
            outfile.write('model_.ssRow(\n')
            ssRow_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ssRow':
            obj_ = ssRow.factory()
            obj_.build(child_)
            self.ssRow.append(obj_)
# end class ssRows


class simba(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self, style=None, cid=None, application=None):
        self.style = _cast(None, style)
        self.cid = _cast(None, cid)
        self.application = application
    def factory(*args_, **kwargs_):
        if simba.subclass:
            return simba.subclass(*args_, **kwargs_)
        else:
            return simba(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_application(self): return self.application
    def set_application(self, application): self.application = application
    def get_style(self): return self.style
    def set_style(self, style): self.style = style
    def get_cid(self): return self.cid
    def set_cid(self, cid): self.cid = cid
    def export(self, outfile, level, namespace_='', name_='simba', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simba')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='simba'):
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            outfile.write(' style=%s' % (self.gds_format_string(quote_attrib(self.style).encode(ExternalEncoding), input_name='style'), ))
        if self.cid is not None and 'cid' not in already_processed:
            already_processed.append('cid')
            outfile.write(' cid=%s' % (self.gds_format_string(quote_attrib(self.cid).encode(ExternalEncoding), input_name='cid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simba', fromsubclass_=False):
        if self.application:
            self.application.export(outfile, level, namespace_, name_='application', )
    def hasContent_(self):
        if (
            self.application is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simba'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.style is not None and 'style' not in already_processed:
            already_processed.append('style')
            showIndent(outfile, level)
            outfile.write('style = "%s",\n' % (self.style,))
        if self.cid is not None and 'cid' not in already_processed:
            already_processed.append('cid')
            showIndent(outfile, level)
            outfile.write('cid = "%s",\n' % (self.cid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.application is not None:
            showIndent(outfile, level)
            outfile.write('application=model_.application(\n')
            self.application.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.append('style')
            self.style = value
        value = find_attr_value_('cid', node)
        if value is not None and 'cid' not in already_processed:
            already_processed.append('cid')
            self.cid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'application':
            obj_ = application.factory()
            obj_.build(child_)
            self.set_application(obj_)
# end class simba


class chart(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, chartPosition=None, name=None, subType=None, chartSize=None, caption=None, gaugeLegendLoc=None, gaugeDataLables=None, chartType=None, categories=None, interaction=None, axesFormats=None, measures=None, seriesGenerators=None, gaugePointers=None, gaugeTitles=None, gaugeScale=None, gaugeRanges=None, gaugeTypeFormat=None):
        self.chartPosition = _cast(None, chartPosition)
        self.name = _cast(None, name)
        self.subType = _cast(None, subType)
        self.chartSize = _cast(None, chartSize)
        self.caption = _cast(None, caption)
        self.gaugeLegendLoc = _cast(None, gaugeLegendLoc)
        self.gaugeDataLables = _cast(None, gaugeDataLables)
        self.chartType = _cast(None, chartType)
        self.categories = categories
        self.interaction = interaction
        self.axesFormats = axesFormats
        self.measures = measures
        self.seriesGenerators = seriesGenerators
        self.gaugePointers = gaugePointers
        self.gaugeTitles = gaugeTitles
        self.gaugeScale = gaugeScale
        self.gaugeRanges = gaugeRanges
        self.gaugeTypeFormat = gaugeTypeFormat
    def factory(*args_, **kwargs_):
        if chart.subclass:
            return chart.subclass(*args_, **kwargs_)
        else:
            return chart(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_categories(self): return self.categories
    def set_categories(self, categories): self.categories = categories
    def get_interaction(self): return self.interaction
    def set_interaction(self, interaction): self.interaction = interaction
    def get_axesFormats(self): return self.axesFormats
    def set_axesFormats(self, axesFormats): self.axesFormats = axesFormats
    def get_measures(self): return self.measures
    def set_measures(self, measures): self.measures = measures
    def get_seriesGenerators(self): return self.seriesGenerators
    def set_seriesGenerators(self, seriesGenerators): self.seriesGenerators = seriesGenerators
    def get_gaugePointers(self): return self.gaugePointers
    def set_gaugePointers(self, gaugePointers): self.gaugePointers = gaugePointers
    def get_gaugeTitles(self): return self.gaugeTitles
    def set_gaugeTitles(self, gaugeTitles): self.gaugeTitles = gaugeTitles
    def get_gaugeScale(self): return self.gaugeScale
    def set_gaugeScale(self, gaugeScale): self.gaugeScale = gaugeScale
    def get_gaugeRanges(self): return self.gaugeRanges
    def set_gaugeRanges(self, gaugeRanges): self.gaugeRanges = gaugeRanges
    def get_gaugeTypeFormat(self): return self.gaugeTypeFormat
    def set_gaugeTypeFormat(self, gaugeTypeFormat): self.gaugeTypeFormat = gaugeTypeFormat
    def get_chartPosition(self): return self.chartPosition
    def set_chartPosition(self, chartPosition): self.chartPosition = chartPosition
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_subType(self): return self.subType
    def set_subType(self, subType): self.subType = subType
    def get_chartSize(self): return self.chartSize
    def set_chartSize(self, chartSize): self.chartSize = chartSize
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_gaugeLegendLoc(self): return self.gaugeLegendLoc
    def set_gaugeLegendLoc(self, gaugeLegendLoc): self.gaugeLegendLoc = gaugeLegendLoc
    def get_gaugeDataLables(self): return self.gaugeDataLables
    def set_gaugeDataLables(self, gaugeDataLables): self.gaugeDataLables = gaugeDataLables
    def get_chartType(self): return self.chartType
    def set_chartType(self, chartType): self.chartType = chartType
    def export(self, outfile, level, namespace_='', name_='chart', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chart')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='chart'):
        if self.chartPosition is not None and 'chartPosition' not in already_processed:
            already_processed.append('chartPosition')
            outfile.write(' chartPosition=%s' % (self.gds_format_string(quote_attrib(self.chartPosition).encode(ExternalEncoding), input_name='chartPosition'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.subType is not None and 'subType' not in already_processed:
            already_processed.append('subType')
            outfile.write(' subType=%s' % (self.gds_format_string(quote_attrib(self.subType).encode(ExternalEncoding), input_name='subType'), ))
        if self.chartSize is not None and 'chartSize' not in already_processed:
            already_processed.append('chartSize')
            outfile.write(' chartSize=%s' % (self.gds_format_string(quote_attrib(self.chartSize).encode(ExternalEncoding), input_name='chartSize'), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.gaugeLegendLoc is not None and 'gaugeLegendLoc' not in already_processed:
            already_processed.append('gaugeLegendLoc')
            outfile.write(' gaugeLegendLoc=%s' % (self.gds_format_string(quote_attrib(self.gaugeLegendLoc).encode(ExternalEncoding), input_name='gaugeLegendLoc'), ))
        if self.gaugeDataLables is not None and 'gaugeDataLables' not in already_processed:
            already_processed.append('gaugeDataLables')
            outfile.write(' gaugeDataLables=%s' % (self.gds_format_string(quote_attrib(self.gaugeDataLables).encode(ExternalEncoding), input_name='gaugeDataLables'), ))
        if self.chartType is not None and 'chartType' not in already_processed:
            already_processed.append('chartType')
            outfile.write(' chartType=%s' % (self.gds_format_string(quote_attrib(self.chartType).encode(ExternalEncoding), input_name='chartType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='chart', fromsubclass_=False):
        if self.categories:
            self.categories.export(outfile, level, namespace_, name_='categories')
        if self.interaction:
            self.interaction.export(outfile, level, namespace_, name_='interaction')
        if self.axesFormats:
            self.axesFormats.export(outfile, level, namespace_, name_='axesFormats')
        if self.measures:
            self.measures.export(outfile, level, namespace_, name_='measures')
        if self.seriesGenerators:
            self.seriesGenerators.export(outfile, level, namespace_, name_='seriesGenerators')
        if self.gaugePointers:
            self.gaugePointers.export(outfile, level, namespace_, name_='gaugePointers')
        if self.gaugeTitles:
            self.gaugeTitles.export(outfile, level, namespace_, name_='gaugeTitles')
        if self.gaugeScale:
            self.gaugeScale.export(outfile, level, namespace_, name_='gaugeScale')
        if self.gaugeRanges:
            self.gaugeRanges.export(outfile, level, namespace_, name_='gaugeRanges')
        if self.gaugeTypeFormat:
            self.gaugeTypeFormat.export(outfile, level, namespace_, name_='gaugeTypeFormat')
    def hasContent_(self):
        if (
            self.categories is not None or
            self.interaction is not None or
            self.axesFormats is not None or
            self.measures is not None or
            self.seriesGenerators is not None or
            self.gaugePointers is not None or
            self.gaugeTitles is not None or
            self.gaugeScale is not None or
            self.gaugeRanges is not None or
            self.gaugeTypeFormat is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='chart'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.chartPosition is not None and 'chartPosition' not in already_processed:
            already_processed.append('chartPosition')
            showIndent(outfile, level)
            outfile.write('chartPosition = "%s",\n' % (self.chartPosition,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.subType is not None and 'subType' not in already_processed:
            already_processed.append('subType')
            showIndent(outfile, level)
            outfile.write('subType = "%s",\n' % (self.subType,))
        if self.chartSize is not None and 'chartSize' not in already_processed:
            already_processed.append('chartSize')
            showIndent(outfile, level)
            outfile.write('chartSize = "%s",\n' % (self.chartSize,))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.gaugeLegendLoc is not None and 'gaugeLegendLoc' not in already_processed:
            already_processed.append('gaugeLegendLoc')
            showIndent(outfile, level)
            outfile.write('gaugeLegendLoc = "%s",\n' % (self.gaugeLegendLoc,))
        if self.gaugeDataLables is not None and 'gaugeDataLables' not in already_processed:
            already_processed.append('gaugeDataLables')
            showIndent(outfile, level)
            outfile.write('gaugeDataLables = "%s",\n' % (self.gaugeDataLables,))
        if self.chartType is not None and 'chartType' not in already_processed:
            already_processed.append('chartType')
            showIndent(outfile, level)
            outfile.write('chartType = "%s",\n' % (self.chartType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.categories is not None:
            showIndent(outfile, level)
            outfile.write('categories=model_.categories(\n')
            self.categories.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.interaction is not None:
            showIndent(outfile, level)
            outfile.write('interaction=model_.interaction(\n')
            self.interaction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.axesFormats is not None:
            showIndent(outfile, level)
            outfile.write('axesFormats=model_.axesFormats(\n')
            self.axesFormats.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.measures is not None:
            showIndent(outfile, level)
            outfile.write('measures=model_.measures(\n')
            self.measures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seriesGenerators is not None:
            showIndent(outfile, level)
            outfile.write('seriesGenerators=model_.seriesGenerators(\n')
            self.seriesGenerators.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gaugePointers is not None:
            showIndent(outfile, level)
            outfile.write('gaugePointers=model_.gaugePointers(\n')
            self.gaugePointers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gaugeTitles is not None:
            showIndent(outfile, level)
            outfile.write('gaugeTitles=model_.gaugeTitles(\n')
            self.gaugeTitles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gaugeScale is not None:
            showIndent(outfile, level)
            outfile.write('gaugeScale=model_.gaugeScale(\n')
            self.gaugeScale.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gaugeRanges is not None:
            showIndent(outfile, level)
            outfile.write('gaugeRanges=model_.gaugeRanges(\n')
            self.gaugeRanges.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.gaugeTypeFormat is not None:
            showIndent(outfile, level)
            outfile.write('gaugeTypeFormat=model_.gaugeTypeFormat(\n')
            self.gaugeTypeFormat.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('chartPosition', node)
        if value is not None and 'chartPosition' not in already_processed:
            already_processed.append('chartPosition')
            self.chartPosition = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('subType', node)
        if value is not None and 'subType' not in already_processed:
            already_processed.append('subType')
            self.subType = value
        value = find_attr_value_('chartSize', node)
        if value is not None and 'chartSize' not in already_processed:
            already_processed.append('chartSize')
            self.chartSize = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('gaugeLegendLoc', node)
        if value is not None and 'gaugeLegendLoc' not in already_processed:
            already_processed.append('gaugeLegendLoc')
            self.gaugeLegendLoc = value
        value = find_attr_value_('gaugeDataLables', node)
        if value is not None and 'gaugeDataLables' not in already_processed:
            already_processed.append('gaugeDataLables')
            self.gaugeDataLables = value
        value = find_attr_value_('chartType', node)
        if value is not None and 'chartType' not in already_processed:
            already_processed.append('chartType')
            self.chartType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'categories':
            obj_ = categories.factory()
            obj_.build(child_)
            self.set_categories(obj_)
        elif nodeName_ == 'interaction':
            obj_ = interaction.factory()
            obj_.build(child_)
            self.set_interaction(obj_)
        elif nodeName_ == 'axesFormats':
            obj_ = axesFormats.factory()
            obj_.build(child_)
            self.set_axesFormats(obj_)
        elif nodeName_ == 'measures':
            obj_ = measures.factory()
            obj_.build(child_)
            self.set_measures(obj_)
        elif nodeName_ == 'seriesGenerators':
            obj_ = seriesGenerators.factory()
            obj_.build(child_)
            self.set_seriesGenerators(obj_)
        elif nodeName_ == 'gaugePointers':
            obj_ = gaugePointers.factory()
            obj_.build(child_)
            self.set_gaugePointers(obj_)
        elif nodeName_ == 'gaugeTitles':
            obj_ = gaugeTitles.factory()
            obj_.build(child_)
            self.set_gaugeTitles(obj_)
        elif nodeName_ == 'gaugeScale':
            obj_ = gaugeScale.factory()
            obj_.build(child_)
            self.set_gaugeScale(obj_)
        elif nodeName_ == 'gaugeRanges':
            obj_ = gaugeRanges.factory()
            obj_.build(child_)
            self.set_gaugeRanges(obj_)
        elif nodeName_ == 'gaugeTypeFormat':
            obj_ = gaugeTypeFormat.factory()
            obj_.build(child_)
            self.set_gaugeTypeFormat(obj_)
# end class chart


class categories(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, category=None):
        if category is None:
            self.category = []
        else:
            self.category = category
    def factory(*args_, **kwargs_):
        if categories.subclass:
            return categories.subclass(*args_, **kwargs_)
        else:
            return categories(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def export(self, outfile, level, namespace_='', name_='categories', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='categories')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='categories'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='categories', fromsubclass_=False):
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category')
    def hasContent_(self):
        if (
            self.category
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='categories'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.category(\n')
            category_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = category.factory()
            obj_.build(child_)
            self.category.append(obj_)
# end class categories


class category(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, position=None, constant=None, column=None):
        self.position = _cast(None, position)
        self.constant = _cast(None, constant)
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if category.subclass:
            return category.subclass(*args_, **kwargs_)
        else:
            return category(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def export(self, outfile, level, namespace_='', name_='category', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='category')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='category'):
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            outfile.write(' position=%s' % (self.gds_format_string(quote_attrib(self.position).encode(ExternalEncoding), input_name='position'), ))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            outfile.write(' constant=%s' % (self.gds_format_string(quote_attrib(self.constant).encode(ExternalEncoding), input_name='constant'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='category', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='category'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            showIndent(outfile, level)
            outfile.write('position = "%s",\n' % (self.position,))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            showIndent(outfile, level)
            outfile.write('constant = "%s",\n' % (self.constant,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.append('position')
            self.position = value
        value = find_attr_value_('constant', node)
        if value is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            self.constant = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
# end class category


class interaction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, interactiontType=None, navigation=None):
        self.interactiontType = _cast(None, interactiontType)
        if navigation is None:
            self.navigation = []
        else:
            self.navigation = navigation
    def factory(*args_, **kwargs_):
        if interaction.subclass:
            return interaction.subclass(*args_, **kwargs_)
        else:
            return interaction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_navigation(self): return self.navigation
    def set_navigation(self, navigation): self.navigation = navigation
    def add_navigation(self, value): self.navigation.append(value)
    def insert_navigation(self, index, value): self.navigation[index] = value
    def get_interactiontType(self): return self.interactiontType
    def set_interactiontType(self, interactiontType): self.interactiontType = interactiontType
    def export(self, outfile, level, namespace_='', name_='interaction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interaction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interaction'):
        if self.interactiontType is not None and 'interactiontType' not in already_processed:
            already_processed.append('interactiontType')
            outfile.write(' interactiontType=%s' % (self.gds_format_string(quote_attrib(self.interactiontType).encode(ExternalEncoding), input_name='interactiontType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='interaction', fromsubclass_=False):
        for navigation_ in self.navigation:
            navigation_.export(outfile, level, namespace_, name_='navigation')
    def hasContent_(self):
        if (
            self.navigation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='interaction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interactiontType is not None and 'interactiontType' not in already_processed:
            already_processed.append('interactiontType')
            showIndent(outfile, level)
            outfile.write('interactiontType = "%s",\n' % (self.interactiontType,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('navigation=[\n')
        level += 1
        for navigation_ in self.navigation:
            showIndent(outfile, level)
            outfile.write('model_.nodeType(\n')
            navigation_.exportLiteral(outfile, level, name_='nodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interactiontType', node)
        if value is not None and 'interactiontType' not in already_processed:
            already_processed.append('interactiontType')
            self.interactiontType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'navigation':
            obj_ = nodeType.factory()
            obj_.build(child_)
            self.navigation.append(obj_)
# end class interaction


class axesFormats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, axisFormat=None):
        if axisFormat is None:
            self.axisFormat = []
        else:
            self.axisFormat = axisFormat
    def factory(*args_, **kwargs_):
        if axesFormats.subclass:
            return axesFormats.subclass(*args_, **kwargs_)
        else:
            return axesFormats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_axisFormat(self): return self.axisFormat
    def set_axisFormat(self, axisFormat): self.axisFormat = axisFormat
    def add_axisFormat(self, value): self.axisFormat.append(value)
    def insert_axisFormat(self, index, value): self.axisFormat[index] = value
    def export(self, outfile, level, namespace_='', name_='axesFormats', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='axesFormats')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='axesFormats'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='axesFormats', fromsubclass_=False):
        for axisFormat_ in self.axisFormat:
            axisFormat_.export(outfile, level, namespace_, name_='axisFormat')
    def hasContent_(self):
        if (
            self.axisFormat
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='axesFormats'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('axisFormat=[\n')
        level += 1
        for axisFormat_ in self.axisFormat:
            showIndent(outfile, level)
            outfile.write('model_.axisFormat(\n')
            axisFormat_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'axisFormat':
            obj_ = axisFormat.factory()
            obj_.build(child_)
            self.axisFormat.append(obj_)
# end class axesFormats


class axisFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, axis=None, labels=None):
        self.axis = _cast(None, axis)
        self.labels = labels
    def factory(*args_, **kwargs_):
        if axisFormat.subclass:
            return axisFormat.subclass(*args_, **kwargs_)
        else:
            return axisFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_labels(self): return self.labels
    def set_labels(self, labels): self.labels = labels
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def export(self, outfile, level, namespace_='', name_='axisFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='axisFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='axisFormat'):
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.append('axis')
            outfile.write(' axis=%s' % (self.gds_format_string(quote_attrib(self.axis).encode(ExternalEncoding), input_name='axis'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='axisFormat', fromsubclass_=False):
        if self.labels is not None:
            showIndent(outfile, level)
            outfile.write('<%slabels>%s</%slabels>\n' % (namespace_, self.gds_format_string(quote_xml(self.labels).encode(ExternalEncoding), input_name='labels'), namespace_))
    def hasContent_(self):
        if (
            self.labels is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='axisFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.append('axis')
            showIndent(outfile, level)
            outfile.write('axis = "%s",\n' % (self.axis,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.labels is not None:
            showIndent(outfile, level)
            outfile.write('labels=%s,\n' % quote_python(self.labels).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.append('axis')
            self.axis = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'labels':
            labels_ = child_.text
            labels_ = self.gds_validate_string(labels_, node, 'labels')
            self.labels = labels_
# end class axisFormat


class labels(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if labels.subclass:
            return labels.subclass(*args_, **kwargs_)
        else:
            return labels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='labels', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='labels')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='labels'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='labels', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='labels'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class labels


class measures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if measures.subclass:
            return measures.subclass(*args_, **kwargs_)
        else:
            return measures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def export(self, outfile, level, namespace_='', name_='measures', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measures')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='measures'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='measures', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='measures'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
# end class measures


class seriesGenerators(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if seriesGenerators.subclass:
            return seriesGenerators.subclass(*args_, **kwargs_)
        else:
            return seriesGenerators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def export(self, outfile, level, namespace_='', name_='seriesGenerators', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='seriesGenerators')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='seriesGenerators'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='seriesGenerators', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='seriesGenerators'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
# end class seriesGenerators


class gaugePointers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pointer=None):
        if pointer is None:
            self.pointer = []
        else:
            self.pointer = pointer
    def factory(*args_, **kwargs_):
        if gaugePointers.subclass:
            return gaugePointers.subclass(*args_, **kwargs_)
        else:
            return gaugePointers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pointer(self): return self.pointer
    def set_pointer(self, pointer): self.pointer = pointer
    def add_pointer(self, value): self.pointer.append(value)
    def insert_pointer(self, index, value): self.pointer[index] = value
    def export(self, outfile, level, namespace_='', name_='gaugePointers', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gaugePointers')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gaugePointers'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='gaugePointers', fromsubclass_=False):
        for pointer_ in self.pointer:
            pointer_.export(outfile, level, namespace_, name_='pointer')
    def hasContent_(self):
        if (
            self.pointer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gaugePointers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pointer=[\n')
        level += 1
        for pointer_ in self.pointer:
            showIndent(outfile, level)
            outfile.write('model_.pointer(\n')
            pointer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pointer':
            obj_ = pointer.factory()
            obj_.build(child_)
            self.pointer.append(obj_)
# end class gaugePointers


class pointer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, color=None, needleStyle=None, column=None):
        self.color = _cast(None, color)
        self.needleStyle = _cast(None, needleStyle)
        self.column = column
    def factory(*args_, **kwargs_):
        if pointer.subclass:
            return pointer.subclass(*args_, **kwargs_)
        else:
            return pointer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_needleStyle(self): return self.needleStyle
    def set_needleStyle(self, needleStyle): self.needleStyle = needleStyle
    def export(self, outfile, level, namespace_='', name_='pointer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pointer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pointer'):
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            outfile.write(' color=%s' % (self.gds_format_string(quote_attrib(self.color).encode(ExternalEncoding), input_name='color'), ))
        if self.needleStyle is not None and 'needleStyle' not in already_processed:
            already_processed.append('needleStyle')
            outfile.write(' needleStyle=%s' % (self.gds_format_string(quote_attrib(self.needleStyle).encode(ExternalEncoding), input_name='needleStyle'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pointer', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column', )
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pointer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            showIndent(outfile, level)
            outfile.write('color = "%s",\n' % (self.color,))
        if self.needleStyle is not None and 'needleStyle' not in already_processed:
            already_processed.append('needleStyle')
            showIndent(outfile, level)
            outfile.write('needleStyle = "%s",\n' % (self.needleStyle,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.append('color')
            self.color = value
        value = find_attr_value_('needleStyle', node)
        if value is not None and 'needleStyle' not in already_processed:
            already_processed.append('needleStyle')
            self.needleStyle = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class pointer


class gaugeTitles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, secFooter=None, footer=None, subTitle=None, title=None, column=None):
        self.secFooter = _cast(None, secFooter)
        self.footer = _cast(None, footer)
        self.subTitle = _cast(None, subTitle)
        self.title = _cast(None, title)
        if column is None:
            self.column = []
        else:
            self.column = column
    def factory(*args_, **kwargs_):
        if gaugeTitles.subclass:
            return gaugeTitles.subclass(*args_, **kwargs_)
        else:
            return gaugeTitles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def get_secFooter(self): return self.secFooter
    def set_secFooter(self, secFooter): self.secFooter = secFooter
    def get_footer(self): return self.footer
    def set_footer(self, footer): self.footer = footer
    def get_subTitle(self): return self.subTitle
    def set_subTitle(self, subTitle): self.subTitle = subTitle
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def export(self, outfile, level, namespace_='', name_='gaugeTitles', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gaugeTitles')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gaugeTitles'):
        if self.secFooter is not None and 'secFooter' not in already_processed:
            already_processed.append('secFooter')
            outfile.write(' secFooter=%s' % (self.gds_format_string(quote_attrib(self.secFooter).encode(ExternalEncoding), input_name='secFooter'), ))
        if self.footer is not None and 'footer' not in already_processed:
            already_processed.append('footer')
            outfile.write(' footer=%s' % (self.gds_format_string(quote_attrib(self.footer).encode(ExternalEncoding), input_name='footer'), ))
        if self.subTitle is not None and 'subTitle' not in already_processed:
            already_processed.append('subTitle')
            outfile.write(' subTitle=%s' % (self.gds_format_string(quote_attrib(self.subTitle).encode(ExternalEncoding), input_name='subTitle'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='gaugeTitles', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gaugeTitles'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.secFooter is not None and 'secFooter' not in already_processed:
            already_processed.append('secFooter')
            showIndent(outfile, level)
            outfile.write('secFooter = "%s",\n' % (self.secFooter,))
        if self.footer is not None and 'footer' not in already_processed:
            already_processed.append('footer')
            showIndent(outfile, level)
            outfile.write('footer = "%s",\n' % (self.footer,))
        if self.subTitle is not None and 'subTitle' not in already_processed:
            already_processed.append('subTitle')
            showIndent(outfile, level)
            outfile.write('subTitle = "%s",\n' % (self.subTitle,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('secFooter', node)
        if value is not None and 'secFooter' not in already_processed:
            already_processed.append('secFooter')
            self.secFooter = value
        value = find_attr_value_('footer', node)
        if value is not None and 'footer' not in already_processed:
            already_processed.append('footer')
            self.footer = value
        value = find_attr_value_('subTitle', node)
        if value is not None and 'subTitle' not in already_processed:
            already_processed.append('subTitle')
            self.subTitle = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
# end class gaugeTitles


class gaugeScale(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, labelsDisplay=None, scaleMin=None, scaleMax=None):
        self.labelsDisplay = _cast(None, labelsDisplay)
        self.scaleMin = scaleMin
        self.scaleMax = scaleMax
    def factory(*args_, **kwargs_):
        if gaugeScale.subclass:
            return gaugeScale.subclass(*args_, **kwargs_)
        else:
            return gaugeScale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scaleMin(self): return self.scaleMin
    def set_scaleMin(self, scaleMin): self.scaleMin = scaleMin
    def get_scaleMax(self): return self.scaleMax
    def set_scaleMax(self, scaleMax): self.scaleMax = scaleMax
    def get_labelsDisplay(self): return self.labelsDisplay
    def set_labelsDisplay(self, labelsDisplay): self.labelsDisplay = labelsDisplay
    def export(self, outfile, level, namespace_='', name_='gaugeScale', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gaugeScale')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gaugeScale'):
        if self.labelsDisplay is not None and 'labelsDisplay' not in already_processed:
            already_processed.append('labelsDisplay')
            outfile.write(' labelsDisplay=%s' % (self.gds_format_string(quote_attrib(self.labelsDisplay).encode(ExternalEncoding), input_name='labelsDisplay'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='gaugeScale', fromsubclass_=False):
        if self.scaleMin:
            self.scaleMin.export(outfile, level, namespace_, name_='scaleMin', )
        if self.scaleMax:
            self.scaleMax.export(outfile, level, namespace_, name_='scaleMax', )
    def hasContent_(self):
        if (
            self.scaleMin is not None or
            self.scaleMax is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gaugeScale'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.labelsDisplay is not None and 'labelsDisplay' not in already_processed:
            already_processed.append('labelsDisplay')
            showIndent(outfile, level)
            outfile.write('labelsDisplay = "%s",\n' % (self.labelsDisplay,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.scaleMin is not None:
            showIndent(outfile, level)
            outfile.write('scaleMin=model_.scaleMin(\n')
            self.scaleMin.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.scaleMax is not None:
            showIndent(outfile, level)
            outfile.write('scaleMax=model_.scaleMax(\n')
            self.scaleMax.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('labelsDisplay', node)
        if value is not None and 'labelsDisplay' not in already_processed:
            already_processed.append('labelsDisplay')
            self.labelsDisplay = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scaleMin':
            obj_ = scaleMin.factory()
            obj_.build(child_)
            self.set_scaleMin(obj_)
        elif nodeName_ == 'scaleMax':
            obj_ = scaleMax.factory()
            obj_.build(child_)
            self.set_scaleMax(obj_)
# end class gaugeScale


class scaleMin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, type_=None, value=None, column=None):
        self.default = _cast(None, default)
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.column = column
    def factory(*args_, **kwargs_):
        if scaleMin.subclass:
            return scaleMin.subclass(*args_, **kwargs_)
        else:
            return scaleMin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='scaleMin', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scaleMin')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scaleMin'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='scaleMin', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scaleMin'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class scaleMin


class scaleMax(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, type_=None, value=None, column=None):
        self.default = _cast(None, default)
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.column = column
    def factory(*args_, **kwargs_):
        if scaleMax.subclass:
            return scaleMax.subclass(*args_, **kwargs_)
        else:
            return scaleMax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='scaleMax', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scaleMax')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scaleMax'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='scaleMax', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scaleMax'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class scaleMax


class gaugeRanges(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gaugeRange=None):
        if gaugeRange is None:
            self.gaugeRange = []
        else:
            self.gaugeRange = gaugeRange
    def factory(*args_, **kwargs_):
        if gaugeRanges.subclass:
            return gaugeRanges.subclass(*args_, **kwargs_)
        else:
            return gaugeRanges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gaugeRange(self): return self.gaugeRange
    def set_gaugeRange(self, gaugeRange): self.gaugeRange = gaugeRange
    def add_gaugeRange(self, value): self.gaugeRange.append(value)
    def insert_gaugeRange(self, index, value): self.gaugeRange[index] = value
    def export(self, outfile, level, namespace_='', name_='gaugeRanges', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gaugeRanges')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gaugeRanges'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='gaugeRanges', fromsubclass_=False):
        for gaugeRange_ in self.gaugeRange:
            gaugeRange_.export(outfile, level, namespace_, name_='gaugeRange')
    def hasContent_(self):
        if (
            self.gaugeRange
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gaugeRanges'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('gaugeRange=[\n')
        level += 1
        for gaugeRange_ in self.gaugeRange:
            showIndent(outfile, level)
            outfile.write('model_.gaugeRange(\n')
            gaugeRange_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gaugeRange':
            obj_ = gaugeRange.factory()
            obj_.build(child_)
            self.gaugeRange.append(obj_)
# end class gaugeRanges


class gaugeRange(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, color=None, caption=None, type_=None, rangeLow=None, rangeHigh=None):
        self.color = _cast(None, color)
        self.caption = _cast(None, caption)
        self.type_ = _cast(None, type_)
        self.rangeLow = rangeLow
        self.rangeHigh = rangeHigh
    def factory(*args_, **kwargs_):
        if gaugeRange.subclass:
            return gaugeRange.subclass(*args_, **kwargs_)
        else:
            return gaugeRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rangeLow(self): return self.rangeLow
    def set_rangeLow(self, rangeLow): self.rangeLow = rangeLow
    def get_rangeHigh(self): return self.rangeHigh
    def set_rangeHigh(self, rangeHigh): self.rangeHigh = rangeHigh
    def get_color(self): return self.color
    def set_color(self, color): self.color = color
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='gaugeRange', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gaugeRange')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gaugeRange'):
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            outfile.write(' color=%s' % (self.gds_format_string(quote_attrib(self.color).encode(ExternalEncoding), input_name='color'), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='gaugeRange', fromsubclass_=False):
        if self.rangeLow:
            self.rangeLow.export(outfile, level, namespace_, name_='rangeLow', )
        if self.rangeHigh:
            self.rangeHigh.export(outfile, level, namespace_, name_='rangeHigh', )
    def hasContent_(self):
        if (
            self.rangeLow is not None or
            self.rangeHigh is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gaugeRange'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.color is not None and 'color' not in already_processed:
            already_processed.append('color')
            showIndent(outfile, level)
            outfile.write('color = "%s",\n' % (self.color,))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.rangeLow is not None:
            showIndent(outfile, level)
            outfile.write('rangeLow=model_.rangeLow(\n')
            self.rangeLow.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rangeHigh is not None:
            showIndent(outfile, level)
            outfile.write('rangeHigh=model_.rangeHigh(\n')
            self.rangeHigh.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.append('color')
            self.color = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rangeLow':
            obj_ = rangeLow.factory()
            obj_.build(child_)
            self.set_rangeLow(obj_)
        elif nodeName_ == 'rangeHigh':
            obj_ = rangeHigh.factory()
            obj_.build(child_)
            self.set_rangeHigh(obj_)
# end class gaugeRange


class rangeLow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, type_=None, value=None, column=None):
        self.default = _cast(None, default)
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.column = column
    def factory(*args_, **kwargs_):
        if rangeLow.subclass:
            return rangeLow.subclass(*args_, **kwargs_)
        else:
            return rangeLow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='rangeLow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rangeLow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rangeLow'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='rangeLow', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rangeLow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class rangeLow


class rangeHigh(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, type_=None, value=None, column=None):
        self.default = _cast(None, default)
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        self.column = column
    def factory(*args_, **kwargs_):
        if rangeHigh.subclass:
            return rangeHigh.subclass(*args_, **kwargs_)
        else:
            return rangeHigh(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='rangeHigh', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rangeHigh')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rangeHigh'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='rangeHigh', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column')
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='rangeHigh'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class rangeHigh


class gaugeTypeFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, arcLength=None, thickness=None):
        self.type_ = _cast(None, type_)
        self.arcLength = _cast(None, arcLength)
        self.thickness = _cast(None, thickness)
        pass
    def factory(*args_, **kwargs_):
        if gaugeTypeFormat.subclass:
            return gaugeTypeFormat.subclass(*args_, **kwargs_)
        else:
            return gaugeTypeFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_arcLength(self): return self.arcLength
    def set_arcLength(self, arcLength): self.arcLength = arcLength
    def get_thickness(self): return self.thickness
    def set_thickness(self, thickness): self.thickness = thickness
    def export(self, outfile, level, namespace_='', name_='gaugeTypeFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='gaugeTypeFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='gaugeTypeFormat'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.arcLength is not None and 'arcLength' not in already_processed:
            already_processed.append('arcLength')
            outfile.write(' arcLength=%s' % (self.gds_format_string(quote_attrib(self.arcLength).encode(ExternalEncoding), input_name='arcLength'), ))
        if self.thickness is not None and 'thickness' not in already_processed:
            already_processed.append('thickness')
            outfile.write(' thickness=%s' % (self.gds_format_string(quote_attrib(self.thickness).encode(ExternalEncoding), input_name='thickness'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='gaugeTypeFormat', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gaugeTypeFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.arcLength is not None and 'arcLength' not in already_processed:
            already_processed.append('arcLength')
            showIndent(outfile, level)
            outfile.write('arcLength = "%s",\n' % (self.arcLength,))
        if self.thickness is not None and 'thickness' not in already_processed:
            already_processed.append('thickness')
            showIndent(outfile, level)
            outfile.write('thickness = "%s",\n' % (self.thickness,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('arcLength', node)
        if value is not None and 'arcLength' not in already_processed:
            already_processed.append('arcLength')
            self.arcLength = value
        value = find_attr_value_('thickness', node)
        if value is not None and 'thickness' not in already_processed:
            already_processed.append('thickness')
            self.thickness = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class gaugeTypeFormat


class tableView(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, grandTotal=None, name=None, columnRef=None):
        self.caption = _cast(None, caption)
        self.grandTotal = _cast(None, grandTotal)
        self.name = _cast(None, name)
        if columnRef is None:
            self.columnRef = []
        else:
            self.columnRef = columnRef
    def factory(*args_, **kwargs_):
        if tableView.subclass:
            return tableView.subclass(*args_, **kwargs_)
        else:
            return tableView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_columnRef(self): return self.columnRef
    def set_columnRef(self, columnRef): self.columnRef = columnRef
    def add_columnRef(self, value): self.columnRef.append(value)
    def insert_columnRef(self, index, value): self.columnRef[index] = value
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_grandTotal(self): return self.grandTotal
    def set_grandTotal(self, grandTotal): self.grandTotal = grandTotal
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='tableView', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tableView')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tableView'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.grandTotal is not None and 'grandTotal' not in already_processed:
            already_processed.append('grandTotal')
            outfile.write(' grandTotal=%s' % (self.gds_format_string(quote_attrib(self.grandTotal).encode(ExternalEncoding), input_name='grandTotal'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tableView', fromsubclass_=False):
        for columnRef_ in self.columnRef:
            columnRef_.export(outfile, level, namespace_, name_='columnRef')
    def hasContent_(self):
        if (
            self.columnRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='tableView'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.grandTotal is not None and 'grandTotal' not in already_processed:
            already_processed.append('grandTotal')
            showIndent(outfile, level)
            outfile.write('grandTotal = "%s",\n' % (self.grandTotal,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('columnRef=[\n')
        level += 1
        for columnRef_ in self.columnRef:
            showIndent(outfile, level)
            outfile.write('model_.columnRef(\n')
            columnRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('grandTotal', node)
        if value is not None and 'grandTotal' not in already_processed:
            already_processed.append('grandTotal')
            self.grandTotal = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'columnRef':
            obj_ = columnRef.factory()
            obj_.build(child_)
            self.columnRef.append(obj_)
# end class tableView


class reportPrompt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, promptFilter=None):
        if promptFilter is None:
            self.promptFilter = []
        else:
            self.promptFilter = promptFilter
    def factory(*args_, **kwargs_):
        if reportPrompt.subclass:
            return reportPrompt.subclass(*args_, **kwargs_)
        else:
            return reportPrompt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_promptFilter(self): return self.promptFilter
    def set_promptFilter(self, promptFilter): self.promptFilter = promptFilter
    def add_promptFilter(self, value): self.promptFilter.append(value)
    def insert_promptFilter(self, index, value): self.promptFilter[index] = value
    def export(self, outfile, level, namespace_='', name_='reportPrompt', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reportPrompt')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reportPrompt'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reportPrompt', fromsubclass_=False):
        for promptFilter_ in self.promptFilter:
            promptFilter_.export(outfile, level, namespace_, name_='promptFilter')
    def hasContent_(self):
        if (
            self.promptFilter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reportPrompt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('promptFilter=[\n')
        level += 1
        for promptFilter_ in self.promptFilter:
            showIndent(outfile, level)
            outfile.write('model_.promptFilterType(\n')
            promptFilter_.exportLiteral(outfile, level, name_='promptFilterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'promptFilter':
            obj_ = promptFilterType.factory()
            obj_.build(child_)
            self.promptFilter.append(obj_)
# end class reportPrompt


class report(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, criteria=None, views=None, reportPrompt=None):
        if criteria is None:
            self.criteria = []
        else:
            self.criteria = criteria
        self.views = views
        self.reportPrompt = reportPrompt
    def factory(*args_, **kwargs_):
        if report.subclass:
            return report.subclass(*args_, **kwargs_)
        else:
            return report(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_criteria(self): return self.criteria
    def set_criteria(self, criteria): self.criteria = criteria
    def add_criteria(self, value): self.criteria.append(value)
    def insert_criteria(self, index, value): self.criteria[index] = value
    def get_views(self): return self.views
    def set_views(self, views): self.views = views
    def get_reportPrompt(self): return self.reportPrompt
    def set_reportPrompt(self, reportPrompt): self.reportPrompt = reportPrompt
    def export(self, outfile, level, namespace_='', name_='report', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='report')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='report'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='report', fromsubclass_=False):
        for criteria_ in self.criteria:
            criteria_.export(outfile, level, namespace_, name_='criteria')
        if self.views:
            self.views.export(outfile, level, namespace_, name_='views')
        if self.reportPrompt:
            self.reportPrompt.export(outfile, level, namespace_, name_='reportPrompt')
    def hasContent_(self):
        if (
            self.criteria or
            self.views is not None or
            self.reportPrompt is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='report'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('criteria=[\n')
        level += 1
        for criteria_ in self.criteria:
            showIndent(outfile, level)
            outfile.write('model_.criteria(\n')
            criteria_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.views is not None:
            showIndent(outfile, level)
            outfile.write('views=model_.views(\n')
            self.views.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reportPrompt is not None:
            showIndent(outfile, level)
            outfile.write('reportPrompt=model_.reportPrompt(\n')
            self.reportPrompt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'criteria':
            obj_ = criteria.factory()
            obj_.build(child_)
            self.criteria.append(obj_)
        elif nodeName_ == 'views':
            obj_ = views.factory()
            obj_.build(child_)
            self.set_views(obj_)
        elif nodeName_ == 'reportPrompt':
            obj_ = reportPrompt.factory()
            obj_.build(child_)
            self.set_reportPrompt(obj_)
# end class report


class nodeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, display=None, cid=None):
        self.caption = _cast(None, caption)
        self.display = _cast(None, display)
        self.cid = _cast(None, cid)
        pass
    def factory(*args_, **kwargs_):
        if nodeType.subclass:
            return nodeType.subclass(*args_, **kwargs_)
        else:
            return nodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_display(self): return self.display
    def set_display(self, display): self.display = display
    def get_cid(self): return self.cid
    def set_cid(self, cid): self.cid = cid
    def export(self, outfile, level, namespace_='', name_='nodeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nodeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nodeType'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            outfile.write(' display=%s' % (self.gds_format_string(quote_attrib(self.display).encode(ExternalEncoding), input_name='display'), ))
        if self.cid is not None and 'cid' not in already_processed:
            already_processed.append('cid')
            outfile.write(' cid=%s' % (self.gds_format_string(quote_attrib(self.cid).encode(ExternalEncoding), input_name='cid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='nodeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nodeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.display is not None and 'display' not in already_processed:
            already_processed.append('display')
            showIndent(outfile, level)
            outfile.write('display = "%s",\n' % (self.display,))
        if self.cid is not None and 'cid' not in already_processed:
            already_processed.append('cid')
            showIndent(outfile, level)
            outfile.write('cid = "%s",\n' % (self.cid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('display', node)
        if value is not None and 'display' not in already_processed:
            already_processed.append('display')
            self.display = value
        value = find_attr_value_('cid', node)
        if value is not None and 'cid' not in already_processed:
            already_processed.append('cid')
            self.cid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nodeType


class promptFilterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, control=None, setVariable=None, default=None, constrainChoices=None, defaultValue=None, setVariableValue=None, defaultValue2=None, includeAllChoices=None, caption=None, values=None, formula=None, schema=None, type_=None, op=None):
        self.control = _cast(None, control)
        self.setVariable = _cast(None, setVariable)
        self.default = _cast(None, default)
        self.constrainChoices = _cast(None, constrainChoices)
        self.defaultValue = _cast(None, defaultValue)
        self.setVariableValue = _cast(None, setVariableValue)
        self.defaultValue2 = _cast(None, defaultValue2)
        self.includeAllChoices = _cast(None, includeAllChoices)
        self.caption = _cast(None, caption)
        self.values = _cast(None, values)
        self.formula = _cast(None, formula)
        self.schema = _cast(None, schema)
        self.type_ = _cast(None, type_)
        self.op = _cast(None, op)
        pass
    def factory(*args_, **kwargs_):
        if promptFilterType.subclass:
            return promptFilterType.subclass(*args_, **kwargs_)
        else:
            return promptFilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_control(self): return self.control
    def set_control(self, control): self.control = control
    def get_setVariable(self): return self.setVariable
    def set_setVariable(self, setVariable): self.setVariable = setVariable
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_constrainChoices(self): return self.constrainChoices
    def set_constrainChoices(self, constrainChoices): self.constrainChoices = constrainChoices
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_setVariableValue(self): return self.setVariableValue
    def set_setVariableValue(self, setVariableValue): self.setVariableValue = setVariableValue
    def get_defaultValue2(self): return self.defaultValue2
    def set_defaultValue2(self, defaultValue2): self.defaultValue2 = defaultValue2
    def get_includeAllChoices(self): return self.includeAllChoices
    def set_includeAllChoices(self, includeAllChoices): self.includeAllChoices = includeAllChoices
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_values(self): return self.values
    def set_values(self, values): self.values = values
    def get_formula(self): return self.formula
    def set_formula(self, formula): self.formula = formula
    def get_schema(self): return self.schema
    def set_schema(self, schema): self.schema = schema
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_op(self): return self.op
    def set_op(self, op): self.op = op
    def export(self, outfile, level, namespace_='', name_='promptFilterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='promptFilterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='promptFilterType'):
        if self.control is not None and 'control' not in already_processed:
            already_processed.append('control')
            outfile.write(' control=%s' % (self.gds_format_string(quote_attrib(self.control).encode(ExternalEncoding), input_name='control'), ))
        if self.setVariable is not None and 'setVariable' not in already_processed:
            already_processed.append('setVariable')
            outfile.write(' setVariable=%s' % (self.gds_format_string(quote_attrib(self.setVariable).encode(ExternalEncoding), input_name='setVariable'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (self.gds_format_string(quote_attrib(self.default).encode(ExternalEncoding), input_name='default'), ))
        if self.constrainChoices is not None and 'constrainChoices' not in already_processed:
            already_processed.append('constrainChoices')
            outfile.write(' constrainChoices=%s' % (self.gds_format_string(quote_attrib(self.constrainChoices).encode(ExternalEncoding), input_name='constrainChoices'), ))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.append('defaultValue')
            outfile.write(' defaultValue=%s' % (self.gds_format_string(quote_attrib(self.defaultValue).encode(ExternalEncoding), input_name='defaultValue'), ))
        if self.setVariableValue is not None and 'setVariableValue' not in already_processed:
            already_processed.append('setVariableValue')
            outfile.write(' setVariableValue=%s' % (self.gds_format_string(quote_attrib(self.setVariableValue).encode(ExternalEncoding), input_name='setVariableValue'), ))
        if self.defaultValue2 is not None and 'defaultValue2' not in already_processed:
            already_processed.append('defaultValue2')
            outfile.write(' defaultValue2=%s' % (self.gds_format_string(quote_attrib(self.defaultValue2).encode(ExternalEncoding), input_name='defaultValue2'), ))
        if self.includeAllChoices is not None and 'includeAllChoices' not in already_processed:
            already_processed.append('includeAllChoices')
            outfile.write(' includeAllChoices=%s' % (self.gds_format_string(quote_attrib(self.includeAllChoices).encode(ExternalEncoding), input_name='includeAllChoices'), ))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.values is not None and 'values' not in already_processed:
            already_processed.append('values')
            outfile.write(' values=%s' % (self.gds_format_string(quote_attrib(self.values).encode(ExternalEncoding), input_name='values'), ))
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            outfile.write(' formula=%s' % (self.gds_format_string(quote_attrib(self.formula).encode(ExternalEncoding), input_name='formula'), ))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.append('schema')
            outfile.write(' schema=%s' % (self.gds_format_string(quote_attrib(self.schema).encode(ExternalEncoding), input_name='schema'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.op is not None and 'op' not in already_processed:
            already_processed.append('op')
            outfile.write(' op=%s' % (self.gds_format_string(quote_attrib(self.op).encode(ExternalEncoding), input_name='op'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='promptFilterType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='promptFilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.control is not None and 'control' not in already_processed:
            already_processed.append('control')
            showIndent(outfile, level)
            outfile.write('control = "%s",\n' % (self.control,))
        if self.setVariable is not None and 'setVariable' not in already_processed:
            already_processed.append('setVariable')
            showIndent(outfile, level)
            outfile.write('setVariable = "%s",\n' % (self.setVariable,))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.constrainChoices is not None and 'constrainChoices' not in already_processed:
            already_processed.append('constrainChoices')
            showIndent(outfile, level)
            outfile.write('constrainChoices = "%s",\n' % (self.constrainChoices,))
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.append('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue = "%s",\n' % (self.defaultValue,))
        if self.setVariableValue is not None and 'setVariableValue' not in already_processed:
            already_processed.append('setVariableValue')
            showIndent(outfile, level)
            outfile.write('setVariableValue = "%s",\n' % (self.setVariableValue,))
        if self.defaultValue2 is not None and 'defaultValue2' not in already_processed:
            already_processed.append('defaultValue2')
            showIndent(outfile, level)
            outfile.write('defaultValue2 = "%s",\n' % (self.defaultValue2,))
        if self.includeAllChoices is not None and 'includeAllChoices' not in already_processed:
            already_processed.append('includeAllChoices')
            showIndent(outfile, level)
            outfile.write('includeAllChoices = "%s",\n' % (self.includeAllChoices,))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.values is not None and 'values' not in already_processed:
            already_processed.append('values')
            showIndent(outfile, level)
            outfile.write('values = "%s",\n' % (self.values,))
        if self.formula is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            showIndent(outfile, level)
            outfile.write('formula = "%s",\n' % (self.formula,))
        if self.schema is not None and 'schema' not in already_processed:
            already_processed.append('schema')
            showIndent(outfile, level)
            outfile.write('schema = "%s",\n' % (self.schema,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.op is not None and 'op' not in already_processed:
            already_processed.append('op')
            showIndent(outfile, level)
            outfile.write('op = "%s",\n' % (self.op,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('control', node)
        if value is not None and 'control' not in already_processed:
            already_processed.append('control')
            self.control = value
        value = find_attr_value_('setVariable', node)
        if value is not None and 'setVariable' not in already_processed:
            already_processed.append('setVariable')
            self.setVariable = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('constrainChoices', node)
        if value is not None and 'constrainChoices' not in already_processed:
            already_processed.append('constrainChoices')
            self.constrainChoices = value
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.append('defaultValue')
            self.defaultValue = value
        value = find_attr_value_('setVariableValue', node)
        if value is not None and 'setVariableValue' not in already_processed:
            already_processed.append('setVariableValue')
            self.setVariableValue = value
        value = find_attr_value_('defaultValue2', node)
        if value is not None and 'defaultValue2' not in already_processed:
            already_processed.append('defaultValue2')
            self.defaultValue2 = value
        value = find_attr_value_('includeAllChoices', node)
        if value is not None and 'includeAllChoices' not in already_processed:
            already_processed.append('includeAllChoices')
            self.includeAllChoices = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('values', node)
        if value is not None and 'values' not in already_processed:
            already_processed.append('values')
            self.values = value
        value = find_attr_value_('formula', node)
        if value is not None and 'formula' not in already_processed:
            already_processed.append('formula')
            self.formula = value
        value = find_attr_value_('schema', node)
        if value is not None and 'schema' not in already_processed:
            already_processed.append('schema')
            self.schema = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('op', node)
        if value is not None and 'op' not in already_processed:
            already_processed.append('op')
            self.op = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class promptFilterType


class columnHeadingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, captionText=None, interaction=None, navigation=None):
        self.captionText = _cast(None, captionText)
        self.interaction = _cast(None, interaction)
        if navigation is None:
            self.navigation = []
        else:
            self.navigation = navigation
    def factory(*args_, **kwargs_):
        if columnHeadingType.subclass:
            return columnHeadingType.subclass(*args_, **kwargs_)
        else:
            return columnHeadingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_navigation(self): return self.navigation
    def set_navigation(self, navigation): self.navigation = navigation
    def add_navigation(self, value): self.navigation.append(value)
    def insert_navigation(self, index, value): self.navigation[index] = value
    def get_captionText(self): return self.captionText
    def set_captionText(self, captionText): self.captionText = captionText
    def get_interaction(self): return self.interaction
    def set_interaction(self, interaction): self.interaction = interaction
    def export(self, outfile, level, namespace_='', name_='columnHeadingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='columnHeadingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='columnHeadingType'):
        if self.captionText is not None and 'captionText' not in already_processed:
            already_processed.append('captionText')
            outfile.write(' captionText=%s' % (self.gds_format_string(quote_attrib(self.captionText).encode(ExternalEncoding), input_name='captionText'), ))
        if self.interaction is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            outfile.write(' interaction=%s' % (self.gds_format_string(quote_attrib(self.interaction).encode(ExternalEncoding), input_name='interaction'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='columnHeadingType', fromsubclass_=False):
        for navigation_ in self.navigation:
            navigation_.export(outfile, level, namespace_, name_='navigation')
    def hasContent_(self):
        if (
            self.navigation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='columnHeadingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.captionText is not None and 'captionText' not in already_processed:
            already_processed.append('captionText')
            showIndent(outfile, level)
            outfile.write('captionText = "%s",\n' % (self.captionText,))
        if self.interaction is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            showIndent(outfile, level)
            outfile.write('interaction = "%s",\n' % (self.interaction,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('navigation=[\n')
        level += 1
        for navigation_ in self.navigation:
            showIndent(outfile, level)
            outfile.write('model_.nodeType(\n')
            navigation_.exportLiteral(outfile, level, name_='nodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('captionText', node)
        if value is not None and 'captionText' not in already_processed:
            already_processed.append('captionText')
            self.captionText = value
        value = find_attr_value_('interaction', node)
        if value is not None and 'interaction' not in already_processed:
            already_processed.append('interaction')
            self.interaction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'navigation':
            obj_ = nodeType.factory()
            obj_.build(child_)
            self.navigation.append(obj_)
# end class columnHeadingType


class pivotTable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, name=None, edge=None, chart=None):
        self.caption = _cast(None, caption)
        self.name = _cast(None, name)
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
        self.chart = chart
    def factory(*args_, **kwargs_):
        if pivotTable.subclass:
            return pivotTable.subclass(*args_, **kwargs_)
        else:
            return pivotTable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def get_chart(self): return self.chart
    def set_chart(self, chart): self.chart = chart
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='pivotTable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pivotTable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pivotTable'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pivotTable', fromsubclass_=False):
        for edge_ in self.edge:
            edge_.export(outfile, level, namespace_, name_='edge')
        if self.chart:
            self.chart.export(outfile, level, namespace_, name_='chart')
    def hasContent_(self):
        if (
            self.edge or
            self.chart is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pivotTable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('edge=[\n')
        level += 1
        for edge_ in self.edge:
            showIndent(outfile, level)
            outfile.write('model_.edge(\n')
            edge_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.chart is not None:
            showIndent(outfile, level)
            outfile.write('chart=model_.chart(\n')
            self.chart.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'edge':
            obj_ = edge.factory()
            obj_.build(child_)
            self.edge.append(obj_)
        elif nodeName_ == 'chart':
            obj_ = chart.factory()
            obj_.build(child_)
            self.set_chart(obj_)
# end class pivotTable


class edge(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, totalLabel=None, total=None, axis=None, column=None, measureLabels=None):
        self.totalLabel = _cast(None, totalLabel)
        self.total = _cast(None, total)
        self.axis = _cast(None, axis)
        if column is None:
            self.column = []
        else:
            self.column = column
        self.measureLabels = measureLabels
    def factory(*args_, **kwargs_):
        if edge.subclass:
            return edge.subclass(*args_, **kwargs_)
        else:
            return edge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def add_column(self, value): self.column.append(value)
    def insert_column(self, index, value): self.column[index] = value
    def get_measureLabels(self): return self.measureLabels
    def set_measureLabels(self, measureLabels): self.measureLabels = measureLabels
    def get_totalLabel(self): return self.totalLabel
    def set_totalLabel(self, totalLabel): self.totalLabel = totalLabel
    def get_total(self): return self.total
    def set_total(self, total): self.total = total
    def get_axis(self): return self.axis
    def set_axis(self, axis): self.axis = axis
    def export(self, outfile, level, namespace_='', name_='edge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='edge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='edge'):
        if self.totalLabel is not None and 'totalLabel' not in already_processed:
            already_processed.append('totalLabel')
            outfile.write(' totalLabel=%s' % (self.gds_format_string(quote_attrib(self.totalLabel).encode(ExternalEncoding), input_name='totalLabel'), ))
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            outfile.write(' total=%s' % (self.gds_format_string(quote_attrib(self.total).encode(ExternalEncoding), input_name='total'), ))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.append('axis')
            outfile.write(' axis=%s' % (self.gds_format_string(quote_attrib(self.axis).encode(ExternalEncoding), input_name='axis'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='edge', fromsubclass_=False):
        for column_ in self.column:
            column_.export(outfile, level, namespace_, name_='column')
        if self.measureLabels:
            self.measureLabels.export(outfile, level, namespace_, name_='measureLabels')
    def hasContent_(self):
        if (
            self.column or
            self.measureLabels is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='edge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.totalLabel is not None and 'totalLabel' not in already_processed:
            already_processed.append('totalLabel')
            showIndent(outfile, level)
            outfile.write('totalLabel = "%s",\n' % (self.totalLabel,))
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            showIndent(outfile, level)
            outfile.write('total = "%s",\n' % (self.total,))
        if self.axis is not None and 'axis' not in already_processed:
            already_processed.append('axis')
            showIndent(outfile, level)
            outfile.write('axis = "%s",\n' % (self.axis,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('column=[\n')
        level += 1
        for column_ in self.column:
            showIndent(outfile, level)
            outfile.write('model_.column(\n')
            column_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.measureLabels is not None:
            showIndent(outfile, level)
            outfile.write('measureLabels=model_.measureLabels(\n')
            self.measureLabels.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('totalLabel', node)
        if value is not None and 'totalLabel' not in already_processed:
            already_processed.append('totalLabel')
            self.totalLabel = value
        value = find_attr_value_('total', node)
        if value is not None and 'total' not in already_processed:
            already_processed.append('total')
            self.total = value
        value = find_attr_value_('axis', node)
        if value is not None and 'axis' not in already_processed:
            already_processed.append('axis')
            self.axis = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.column.append(obj_)
        elif nodeName_ == 'measureLabels':
            obj_ = measureLabels.factory()
            obj_.build(child_)
            self.set_measureLabels(obj_)
# end class edge


class measureLabels(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, total=None, edgeSeq=None):
        self.total = _cast(None, total)
        self.edgeSeq = _cast(None, edgeSeq)
        pass
    def factory(*args_, **kwargs_):
        if measureLabels.subclass:
            return measureLabels.subclass(*args_, **kwargs_)
        else:
            return measureLabels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_total(self): return self.total
    def set_total(self, total): self.total = total
    def get_edgeSeq(self): return self.edgeSeq
    def set_edgeSeq(self, edgeSeq): self.edgeSeq = edgeSeq
    def export(self, outfile, level, namespace_='', name_='measureLabels', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measureLabels')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='measureLabels'):
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            outfile.write(' total=%s' % (self.gds_format_string(quote_attrib(self.total).encode(ExternalEncoding), input_name='total'), ))
        if self.edgeSeq is not None and 'edgeSeq' not in already_processed:
            already_processed.append('edgeSeq')
            outfile.write(' edgeSeq=%s' % (self.gds_format_string(quote_attrib(self.edgeSeq).encode(ExternalEncoding), input_name='edgeSeq'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='measureLabels', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='measureLabels'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.total is not None and 'total' not in already_processed:
            already_processed.append('total')
            showIndent(outfile, level)
            outfile.write('total = "%s",\n' % (self.total,))
        if self.edgeSeq is not None and 'edgeSeq' not in already_processed:
            already_processed.append('edgeSeq')
            showIndent(outfile, level)
            outfile.write('edgeSeq = "%s",\n' % (self.edgeSeq,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('total', node)
        if value is not None and 'total' not in already_processed:
            already_processed.append('total')
            self.total = value
        value = find_attr_value_('edgeSeq', node)
        if value is not None and 'edgeSeq' not in already_processed:
            already_processed.append('edgeSeq')
            self.edgeSeq = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class measureLabels


class page(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pageName=None, section=None):
        self.pageName = _cast(None, pageName)
        if section is None:
            self.section = []
        else:
            self.section = section
    def factory(*args_, **kwargs_):
        if page.subclass:
            return page.subclass(*args_, **kwargs_)
        else:
            return page(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_section(self): return self.section
    def set_section(self, section): self.section = section
    def add_section(self, value): self.section.append(value)
    def insert_section(self, index, value): self.section[index] = value
    def get_pageName(self): return self.pageName
    def set_pageName(self, pageName): self.pageName = pageName
    def export(self, outfile, level, namespace_='', name_='page', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='page')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='page'):
        if self.pageName is not None and 'pageName' not in already_processed:
            already_processed.append('pageName')
            outfile.write(' pageName=%s' % (self.gds_format_string(quote_attrib(self.pageName).encode(ExternalEncoding), input_name='pageName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='page', fromsubclass_=False):
        for section_ in self.section:
            section_.export(outfile, level, namespace_, name_='section')
    def hasContent_(self):
        if (
            self.section
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='page'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pageName is not None and 'pageName' not in already_processed:
            already_processed.append('pageName')
            showIndent(outfile, level)
            outfile.write('pageName = "%s",\n' % (self.pageName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('section=[\n')
        level += 1
        for section_ in self.section:
            showIndent(outfile, level)
            outfile.write('model_.section(\n')
            section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pageName', node)
        if value is not None and 'pageName' not in already_processed:
            already_processed.append('pageName')
            self.pageName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'section':
            obj_ = section.factory()
            obj_.build(child_)
            self.section.append(obj_)
# end class page


class section(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, name=None, pagePrompt=None, pageReport=None, pageLink=None, pageNavReport=None, pageHtml=None):
        self.caption = _cast(None, caption)
        self.name = _cast(None, name)
        if pagePrompt is None:
            self.pagePrompt = []
        else:
            self.pagePrompt = pagePrompt
        if pageReport is None:
            self.pageReport = []
        else:
            self.pageReport = pageReport
        if pageLink is None:
            self.pageLink = []
        else:
            self.pageLink = pageLink
        self.pageNavReport = pageNavReport
        if pageHtml is None:
            self.pageHtml = []
        else:
            self.pageHtml = pageHtml
    def factory(*args_, **kwargs_):
        if section.subclass:
            return section.subclass(*args_, **kwargs_)
        else:
            return section(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pagePrompt(self): return self.pagePrompt
    def set_pagePrompt(self, pagePrompt): self.pagePrompt = pagePrompt
    def add_pagePrompt(self, value): self.pagePrompt.append(value)
    def insert_pagePrompt(self, index, value): self.pagePrompt[index] = value
    def get_pageReport(self): return self.pageReport
    def set_pageReport(self, pageReport): self.pageReport = pageReport
    def add_pageReport(self, value): self.pageReport.append(value)
    def insert_pageReport(self, index, value): self.pageReport[index] = value
    def get_pageLink(self): return self.pageLink
    def set_pageLink(self, pageLink): self.pageLink = pageLink
    def add_pageLink(self, value): self.pageLink.append(value)
    def insert_pageLink(self, index, value): self.pageLink[index] = value
    def get_pageNavReport(self): return self.pageNavReport
    def set_pageNavReport(self, pageNavReport): self.pageNavReport = pageNavReport
    def get_pageHtml(self): return self.pageHtml
    def set_pageHtml(self, pageHtml): self.pageHtml = pageHtml
    def add_pageHtml(self, value): self.pageHtml.append(value)
    def insert_pageHtml(self, index, value): self.pageHtml[index] = value
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='section', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='section')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='section'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='section', fromsubclass_=False):
        for pagePrompt_ in self.pagePrompt:
            pagePrompt_.export(outfile, level, namespace_, name_='pagePrompt')
        for pageReport_ in self.pageReport:
            pageReport_.export(outfile, level, namespace_, name_='pageReport')
        for pageLink_ in self.pageLink:
            pageLink_.export(outfile, level, namespace_, name_='pageLink')
        if self.pageNavReport:
            self.pageNavReport.export(outfile, level, namespace_, name_='pageNavReport')
        for pageHtml_ in self.pageHtml:
            showIndent(outfile, level)
            outfile.write('<%spageHtml>%s</%spageHtml>\n' % (namespace_, self.gds_format_string(quote_xml(pageHtml_).encode(ExternalEncoding), input_name='pageHtml'), namespace_))
    def hasContent_(self):
        if (
            self.pagePrompt or
            self.pageReport or
            self.pageLink or
            self.pageNavReport is not None or
            self.pageHtml
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='section'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('pagePrompt=[\n')
        level += 1
        for pagePrompt_ in self.pagePrompt:
            showIndent(outfile, level)
            outfile.write('model_.nodeType(\n')
            pagePrompt_.exportLiteral(outfile, level, name_='nodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pageReport=[\n')
        level += 1
        for pageReport_ in self.pageReport:
            showIndent(outfile, level)
            outfile.write('model_.nodeType(\n')
            pageReport_.exportLiteral(outfile, level, name_='nodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('pageLink=[\n')
        level += 1
        for pageLink_ in self.pageLink:
            showIndent(outfile, level)
            outfile.write('model_.pageLink(\n')
            pageLink_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.pageNavReport is not None:
            showIndent(outfile, level)
            outfile.write('pageNavReport=model_.pageNavReport(\n')
            self.pageNavReport.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('pageHtml=[\n')
        level += 1
        for pageHtml_ in self.pageHtml:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(pageHtml_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pagePrompt':
            obj_ = nodeType.factory()
            obj_.build(child_)
            self.pagePrompt.append(obj_)
        elif nodeName_ == 'pageReport':
            obj_ = nodeType.factory()
            obj_.build(child_)
            self.pageReport.append(obj_)
        elif nodeName_ == 'pageLink':
            obj_ = pageLink.factory()
            obj_.build(child_)
            self.pageLink.append(obj_)
        elif nodeName_ == 'pageNavReport':
            obj_ = pageNavReport.factory()
            obj_.build(child_)
            self.set_pageNavReport(obj_)
        elif nodeName_ == 'pageHtml':
            pageHtml_ = child_.text
            pageHtml_ = self.gds_validate_string(pageHtml_, node, 'pageHtml')
            self.pageHtml.append(pageHtml_)
# end class section


class pageLink(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, controllerId=None, destination=None, type_=None, name=None, navReport=None):
        self.caption = _cast(None, caption)
        self.controllerId = _cast(None, controllerId)
        self.destination = _cast(None, destination)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.navReport = navReport
    def factory(*args_, **kwargs_):
        if pageLink.subclass:
            return pageLink.subclass(*args_, **kwargs_)
        else:
            return pageLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_navReport(self): return self.navReport
    def set_navReport(self, navReport): self.navReport = navReport
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_controllerId(self): return self.controllerId
    def set_controllerId(self, controllerId): self.controllerId = controllerId
    def get_destination(self): return self.destination
    def set_destination(self, destination): self.destination = destination
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='pageLink', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pageLink')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pageLink'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.controllerId is not None and 'controllerId' not in already_processed:
            already_processed.append('controllerId')
            outfile.write(' controllerId=%s' % (self.gds_format_string(quote_attrib(self.controllerId).encode(ExternalEncoding), input_name='controllerId'), ))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            outfile.write(' destination=%s' % (self.gds_format_string(quote_attrib(self.destination).encode(ExternalEncoding), input_name='destination'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pageLink', fromsubclass_=False):
        if self.navReport:
            self.navReport.export(outfile, level, namespace_, name_='navReport')
    def hasContent_(self):
        if (
            self.navReport is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pageLink'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.controllerId is not None and 'controllerId' not in already_processed:
            already_processed.append('controllerId')
            showIndent(outfile, level)
            outfile.write('controllerId = "%s",\n' % (self.controllerId,))
        if self.destination is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            showIndent(outfile, level)
            outfile.write('destination = "%s",\n' % (self.destination,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.navReport is not None:
            showIndent(outfile, level)
            outfile.write('navReport=model_.navReport(\n')
            self.navReport.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('controllerId', node)
        if value is not None and 'controllerId' not in already_processed:
            already_processed.append('controllerId')
            self.controllerId = value
        value = find_attr_value_('destination', node)
        if value is not None and 'destination' not in already_processed:
            already_processed.append('destination')
            self.destination = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'navReport':
            obj_ = navReport.factory()
            obj_.build(child_)
            self.set_navReport(obj_)
# end class pageLink


class navReport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, path=None, condition=None):
        self.path = _cast(None, path)
        self.condition = _cast(None, condition)
        pass
    def factory(*args_, **kwargs_):
        if navReport.subclass:
            return navReport.subclass(*args_, **kwargs_)
        else:
            return navReport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def export(self, outfile, level, namespace_='', name_='navReport', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='navReport')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='navReport'):
        if self.path is not None and 'path' not in already_processed:
            already_processed.append('path')
            outfile.write(' path=%s' % (self.gds_format_string(quote_attrib(self.path).encode(ExternalEncoding), input_name='path'), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            outfile.write(' condition=%s' % (self.gds_format_string(quote_attrib(self.condition).encode(ExternalEncoding), input_name='condition'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='navReport', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='navReport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.path is not None and 'path' not in already_processed:
            already_processed.append('path')
            showIndent(outfile, level)
            outfile.write('path = "%s",\n' % (self.path,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            showIndent(outfile, level)
            outfile.write('condition = "%s",\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.append('path')
            self.path = value
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            self.condition = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class navReport


class pageNavReport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, path=None, condition=None):
        self.path = _cast(None, path)
        self.condition = _cast(None, condition)
        pass
    def factory(*args_, **kwargs_):
        if pageNavReport.subclass:
            return pageNavReport.subclass(*args_, **kwargs_)
        else:
            return pageNavReport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def export(self, outfile, level, namespace_='', name_='pageNavReport', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pageNavReport')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pageNavReport'):
        if self.path is not None and 'path' not in already_processed:
            already_processed.append('path')
            outfile.write(' path=%s' % (self.gds_format_string(quote_attrib(self.path).encode(ExternalEncoding), input_name='path'), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            outfile.write(' condition=%s' % (self.gds_format_string(quote_attrib(self.condition).encode(ExternalEncoding), input_name='condition'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pageNavReport', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pageNavReport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.path is not None and 'path' not in already_processed:
            already_processed.append('path')
            showIndent(outfile, level)
            outfile.write('path = "%s",\n' % (self.path,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            showIndent(outfile, level)
            outfile.write('condition = "%s",\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.append('path')
            self.path = value
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            self.condition = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pageNavReport


class pageHtml(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if pageHtml.subclass:
            return pageHtml.subclass(*args_, **kwargs_)
        else:
            return pageHtml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='pageHtml', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pageHtml')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pageHtml'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='pageHtml', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='pageHtml'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pageHtml


class entry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cell=None):
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if entry.subclass:
            return entry.subclass(*args_, **kwargs_)
        else:
            return entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile, level, namespace_='', name_='entry', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entry')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='entry', fromsubclass_=False):
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='entry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.cell(\n')
            cell_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cell':
            obj_ = cell.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class entry


class ssColumn(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, headerName=None, parentGroup=None, group=None, headerValue=None):
        self.headerName = _cast(None, headerName)
        self.parentGroup = _cast(None, parentGroup)
        self.group = _cast(None, group)
        self.headerValue = _cast(None, headerValue)
        pass
    def factory(*args_, **kwargs_):
        if ssColumn.subclass:
            return ssColumn.subclass(*args_, **kwargs_)
        else:
            return ssColumn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_headerName(self): return self.headerName
    def set_headerName(self, headerName): self.headerName = headerName
    def get_parentGroup(self): return self.parentGroup
    def set_parentGroup(self, parentGroup): self.parentGroup = parentGroup
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_headerValue(self): return self.headerValue
    def set_headerValue(self, headerValue): self.headerValue = headerValue
    def export(self, outfile, level, namespace_='', name_='ssColumn', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ssColumn')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ssColumn'):
        if self.headerName is not None and 'headerName' not in already_processed:
            already_processed.append('headerName')
            outfile.write(' headerName=%s' % (self.gds_format_string(quote_attrib(self.headerName).encode(ExternalEncoding), input_name='headerName'), ))
        if self.parentGroup is not None and 'parentGroup' not in already_processed:
            already_processed.append('parentGroup')
            outfile.write(' parentGroup=%s' % (self.gds_format_string(quote_attrib(self.parentGroup).encode(ExternalEncoding), input_name='parentGroup'), ))
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            outfile.write(' group=%s' % (self.gds_format_string(quote_attrib(self.group).encode(ExternalEncoding), input_name='group'), ))
        if self.headerValue is not None and 'headerValue' not in already_processed:
            already_processed.append('headerValue')
            outfile.write(' headerValue=%s' % (self.gds_format_string(quote_attrib(self.headerValue).encode(ExternalEncoding), input_name='headerValue'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ssColumn', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ssColumn'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.headerName is not None and 'headerName' not in already_processed:
            already_processed.append('headerName')
            showIndent(outfile, level)
            outfile.write('headerName = "%s",\n' % (self.headerName,))
        if self.parentGroup is not None and 'parentGroup' not in already_processed:
            already_processed.append('parentGroup')
            showIndent(outfile, level)
            outfile.write('parentGroup = "%s",\n' % (self.parentGroup,))
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            showIndent(outfile, level)
            outfile.write('group = "%s",\n' % (self.group,))
        if self.headerValue is not None and 'headerValue' not in already_processed:
            already_processed.append('headerValue')
            showIndent(outfile, level)
            outfile.write('headerValue = "%s",\n' % (self.headerValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('headerName', node)
        if value is not None and 'headerName' not in already_processed:
            already_processed.append('headerName')
            self.headerName = value
        value = find_attr_value_('parentGroup', node)
        if value is not None and 'parentGroup' not in already_processed:
            already_processed.append('parentGroup')
            self.parentGroup = value
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.append('group')
            self.group = value
        value = find_attr_value_('headerValue', node)
        if value is not None and 'headerValue' not in already_processed:
            already_processed.append('headerValue')
            self.headerValue = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ssColumn


class ssRow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, headerName=None, parentGroup=None, group=None, headerValue=None, entry=None):
        self.headerName = _cast(None, headerName)
        self.parentGroup = _cast(None, parentGroup)
        self.group = _cast(None, group)
        self.headerValue = _cast(None, headerValue)
        self.entry = entry
    def factory(*args_, **kwargs_):
        if ssRow.subclass:
            return ssRow.subclass(*args_, **kwargs_)
        else:
            return ssRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def get_headerName(self): return self.headerName
    def set_headerName(self, headerName): self.headerName = headerName
    def get_parentGroup(self): return self.parentGroup
    def set_parentGroup(self, parentGroup): self.parentGroup = parentGroup
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_headerValue(self): return self.headerValue
    def set_headerValue(self, headerValue): self.headerValue = headerValue
    def export(self, outfile, level, namespace_='', name_='ssRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ssRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ssRow'):
        if self.headerName is not None and 'headerName' not in already_processed:
            already_processed.append('headerName')
            outfile.write(' headerName=%s' % (self.gds_format_string(quote_attrib(self.headerName).encode(ExternalEncoding), input_name='headerName'), ))
        if self.parentGroup is not None and 'parentGroup' not in already_processed:
            already_processed.append('parentGroup')
            outfile.write(' parentGroup=%s' % (self.gds_format_string(quote_attrib(self.parentGroup).encode(ExternalEncoding), input_name='parentGroup'), ))
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            outfile.write(' group=%s' % (self.gds_format_string(quote_attrib(self.group).encode(ExternalEncoding), input_name='group'), ))
        if self.headerValue is not None and 'headerValue' not in already_processed:
            already_processed.append('headerValue')
            outfile.write(' headerValue=%s' % (self.gds_format_string(quote_attrib(self.headerValue).encode(ExternalEncoding), input_name='headerValue'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ssRow', fromsubclass_=False):
        if self.entry:
            self.entry.export(outfile, level, namespace_, name_='entry')
    def hasContent_(self):
        if (
            self.entry is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ssRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.headerName is not None and 'headerName' not in already_processed:
            already_processed.append('headerName')
            showIndent(outfile, level)
            outfile.write('headerName = "%s",\n' % (self.headerName,))
        if self.parentGroup is not None and 'parentGroup' not in already_processed:
            already_processed.append('parentGroup')
            showIndent(outfile, level)
            outfile.write('parentGroup = "%s",\n' % (self.parentGroup,))
        if self.group is not None and 'group' not in already_processed:
            already_processed.append('group')
            showIndent(outfile, level)
            outfile.write('group = "%s",\n' % (self.group,))
        if self.headerValue is not None and 'headerValue' not in already_processed:
            already_processed.append('headerValue')
            showIndent(outfile, level)
            outfile.write('headerValue = "%s",\n' % (self.headerValue,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.entry is not None:
            showIndent(outfile, level)
            outfile.write('entry=model_.entry(\n')
            self.entry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('headerName', node)
        if value is not None and 'headerName' not in already_processed:
            already_processed.append('headerName')
            self.headerName = value
        value = find_attr_value_('parentGroup', node)
        if value is not None and 'parentGroup' not in already_processed:
            already_processed.append('parentGroup')
            self.parentGroup = value
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.append('group')
            self.group = value
        value = find_attr_value_('headerValue', node)
        if value is not None and 'headerValue' not in already_processed:
            already_processed.append('headerValue')
            self.headerValue = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entry':
            obj_ = entry.factory()
            obj_.build(child_)
            self.set_entry(obj_)
# end class ssRow


class mapView(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, caption=None, centerLongitude=None, name=None, geocodeSource=None, centerLatitude=None, latitude=None, longitude=None, seriesGenerators=None, location=None):
        self.caption = _cast(None, caption)
        self.centerLongitude = _cast(None, centerLongitude)
        self.name = _cast(None, name)
        self.geocodeSource = _cast(None, geocodeSource)
        self.centerLatitude = _cast(None, centerLatitude)
        self.latitude = latitude
        self.longitude = longitude
        self.seriesGenerators = seriesGenerators
        self.location = location
    def factory(*args_, **kwargs_):
        if mapView.subclass:
            return mapView.subclass(*args_, **kwargs_)
        else:
            return mapView(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def get_seriesGenerators(self): return self.seriesGenerators
    def set_seriesGenerators(self, seriesGenerators): self.seriesGenerators = seriesGenerators
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_caption(self): return self.caption
    def set_caption(self, caption): self.caption = caption
    def get_centerLongitude(self): return self.centerLongitude
    def set_centerLongitude(self, centerLongitude): self.centerLongitude = centerLongitude
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_geocodeSource(self): return self.geocodeSource
    def set_geocodeSource(self, geocodeSource): self.geocodeSource = geocodeSource
    def get_centerLatitude(self): return self.centerLatitude
    def set_centerLatitude(self, centerLatitude): self.centerLatitude = centerLatitude
    def export(self, outfile, level, namespace_='', name_='mapView', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mapView')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mapView'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            outfile.write(' caption=%s' % (self.gds_format_string(quote_attrib(self.caption).encode(ExternalEncoding), input_name='caption'), ))
        if self.centerLongitude is not None and 'centerLongitude' not in already_processed:
            already_processed.append('centerLongitude')
            outfile.write(' centerLongitude=%s' % (self.gds_format_string(quote_attrib(self.centerLongitude).encode(ExternalEncoding), input_name='centerLongitude'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.geocodeSource is not None and 'geocodeSource' not in already_processed:
            already_processed.append('geocodeSource')
            outfile.write(' geocodeSource=%s' % (self.gds_format_string(quote_attrib(self.geocodeSource).encode(ExternalEncoding), input_name='geocodeSource'), ))
        if self.centerLatitude is not None and 'centerLatitude' not in already_processed:
            already_processed.append('centerLatitude')
            outfile.write(' centerLatitude=%s' % (self.gds_format_string(quote_attrib(self.centerLatitude).encode(ExternalEncoding), input_name='centerLatitude'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mapView', fromsubclass_=False):
        if self.latitude:
            self.latitude.export(outfile, level, namespace_, name_='latitude')
        if self.longitude:
            self.longitude.export(outfile, level, namespace_, name_='longitude')
        if self.seriesGenerators:
            self.seriesGenerators.export(outfile, level, namespace_, name_='seriesGenerators', )
        if self.location:
            self.location.export(outfile, level, namespace_, name_='location')
    def hasContent_(self):
        if (
            self.latitude is not None or
            self.longitude is not None or
            self.seriesGenerators is not None or
            self.location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mapView'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            showIndent(outfile, level)
            outfile.write('caption = "%s",\n' % (self.caption,))
        if self.centerLongitude is not None and 'centerLongitude' not in already_processed:
            already_processed.append('centerLongitude')
            showIndent(outfile, level)
            outfile.write('centerLongitude = "%s",\n' % (self.centerLongitude,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.geocodeSource is not None and 'geocodeSource' not in already_processed:
            already_processed.append('geocodeSource')
            showIndent(outfile, level)
            outfile.write('geocodeSource = "%s",\n' % (self.geocodeSource,))
        if self.centerLatitude is not None and 'centerLatitude' not in already_processed:
            already_processed.append('centerLatitude')
            showIndent(outfile, level)
            outfile.write('centerLatitude = "%s",\n' % (self.centerLatitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.latitude is not None:
            showIndent(outfile, level)
            outfile.write('latitude=model_.latitude(\n')
            self.latitude.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.longitude is not None:
            showIndent(outfile, level)
            outfile.write('longitude=model_.longitude(\n')
            self.longitude.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seriesGenerators is not None:
            showIndent(outfile, level)
            outfile.write('seriesGenerators=model_.seriesGenerators(\n')
            self.seriesGenerators.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.location(\n')
            self.location.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.append('caption')
            self.caption = value
        value = find_attr_value_('centerLongitude', node)
        if value is not None and 'centerLongitude' not in already_processed:
            already_processed.append('centerLongitude')
            self.centerLongitude = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('geocodeSource', node)
        if value is not None and 'geocodeSource' not in already_processed:
            already_processed.append('geocodeSource')
            self.geocodeSource = value
        value = find_attr_value_('centerLatitude', node)
        if value is not None and 'centerLatitude' not in already_processed:
            already_processed.append('centerLatitude')
            self.centerLatitude = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'latitude':
            obj_ = latitude.factory()
            obj_.build(child_)
            self.set_latitude(obj_)
        elif nodeName_ == 'longitude':
            obj_ = longitude.factory()
            obj_.build(child_)
            self.set_longitude(obj_)
        elif nodeName_ == 'seriesGenerators':
            obj_ = seriesGenerators.factory()
            obj_.build(child_)
            self.set_seriesGenerators(obj_)
        elif nodeName_ == 'location':
            obj_ = location.factory()
            obj_.build(child_)
            self.set_location(obj_)
# end class mapView


class latitude(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        self.column = column
    def factory(*args_, **kwargs_):
        if latitude.subclass:
            return latitude.subclass(*args_, **kwargs_)
        else:
            return latitude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def export(self, outfile, level, namespace_='', name_='latitude', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='latitude')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='latitude'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='latitude', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column', )
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='latitude'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class latitude


class longitude(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        self.column = column
    def factory(*args_, **kwargs_):
        if longitude.subclass:
            return longitude.subclass(*args_, **kwargs_)
        else:
            return longitude(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def export(self, outfile, level, namespace_='', name_='longitude', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='longitude')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='longitude'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='longitude', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column', )
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='longitude'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class longitude


class location(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, column=None):
        self.column = column
    def factory(*args_, **kwargs_):
        if location.subclass:
            return location.subclass(*args_, **kwargs_)
        else:
            return location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_column(self): return self.column
    def set_column(self, column): self.column = column
    def export(self, outfile, level, namespace_='', name_='location', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='location', fromsubclass_=False):
        if self.column:
            self.column.export(outfile, level, namespace_, name_='column', )
    def hasContent_(self):
        if (
            self.column is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='location'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.column is not None:
            showIndent(outfile, level)
            outfile.write('column=model_.column(\n')
            self.column.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'column':
            obj_ = column.factory()
            obj_.build(child_)
            self.set_column(obj_)
# end class location


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'application'
        rootClass = application
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'application'
        rootClass = application
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="application",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'application'
        rootClass = application
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from simbaStruct import *\n\n')
    sys.stdout.write('import simbaStruct as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "application",
    "axesFormats",
    "axisFormat",
    "categories",
    "category",
    "cell",
    "chart",
    "choice",
    "column",
    "columnHeadingType",
    "columnOrder",
    "columnRef",
    "columnSelector",
    "columns",
    "compoundView",
    "criteria",
    "dataFormat",
    "drillColumn",
    "drillColumns",
    "edge",
    "entry",
    "expr",
    "filter",
    "gaugePointers",
    "gaugeRange",
    "gaugeRanges",
    "gaugeScale",
    "gaugeTitles",
    "gaugeTypeFormat",
    "interaction",
    "labels",
    "latitude",
    "location",
    "longitude",
    "mapView",
    "measureLabels",
    "measures",
    "narrative",
    "narrativeView",
    "navReport",
    "nodeType",
    "page",
    "pageHtml",
    "pageLink",
    "pageNavReport",
    "pivotTable",
    "pointer",
    "postfix",
    "prefix",
    "prompt",
    "promptFilterType",
    "rangeHigh",
    "rangeLow",
    "report",
    "reportPrompt",
    "rowCount",
    "rowSep",
    "scaleMax",
    "scaleMin",
    "section",
    "selector",
    "seriesGenerators",
    "simba",
    "spreadsheet",
    "sql",
    "ssColumn",
    "ssColumns",
    "ssCorner",
    "ssRow",
    "ssRows",
    "tableView",
    "viewItem",
    "viewSelector",
    "views"
    ]
