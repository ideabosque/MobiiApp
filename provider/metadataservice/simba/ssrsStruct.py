#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Jan 04 17:08:30 2012 by generateDS.py version 2.6a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Report(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Description=None, Author=None, AutoRefresh=None, DataSources=None, DataSets=None, Body=None, ReportParameters=None, Code=None, Width=None, Page=None, EmbeddedImages=None, Language=None, CodeModules=None, Classes=None, CustomProperties=None, Variables=None, DeferVariableEvaluation=None, ConsumeContainerWhitespace=None, DataTransform=None, DataSchema=None, DataElementName=None, DataElementStyle=None):
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Author is None:
            self.Author = []
        else:
            self.Author = Author
        if AutoRefresh is None:
            self.AutoRefresh = []
        else:
            self.AutoRefresh = AutoRefresh
        if DataSources is None:
            self.DataSources = []
        else:
            self.DataSources = DataSources
        if DataSets is None:
            self.DataSets = []
        else:
            self.DataSets = DataSets
        if Body is None:
            self.Body = []
        else:
            self.Body = Body
        if ReportParameters is None:
            self.ReportParameters = []
        else:
            self.ReportParameters = ReportParameters
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if Page is None:
            self.Page = []
        else:
            self.Page = Page
        if EmbeddedImages is None:
            self.EmbeddedImages = []
        else:
            self.EmbeddedImages = EmbeddedImages
        if Language is None:
            self.Language = []
        else:
            self.Language = Language
        if CodeModules is None:
            self.CodeModules = []
        else:
            self.CodeModules = CodeModules
        if Classes is None:
            self.Classes = []
        else:
            self.Classes = Classes
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if Variables is None:
            self.Variables = []
        else:
            self.Variables = Variables
        if DeferVariableEvaluation is None:
            self.DeferVariableEvaluation = []
        else:
            self.DeferVariableEvaluation = DeferVariableEvaluation
        if ConsumeContainerWhitespace is None:
            self.ConsumeContainerWhitespace = []
        else:
            self.ConsumeContainerWhitespace = ConsumeContainerWhitespace
        if DataTransform is None:
            self.DataTransform = []
        else:
            self.DataTransform = DataTransform
        if DataSchema is None:
            self.DataSchema = []
        else:
            self.DataSchema = DataSchema
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementStyle is None:
            self.DataElementStyle = []
        else:
            self.DataElementStyle = DataElementStyle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Report.subclass:
            return Report.subclass(*args_, **kwargs_)
        else:
            return Report(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description(self, index, value): self.Description[index] = value
    def get_Author(self): return self.Author
    def set_Author(self, Author): self.Author = Author
    def add_Author(self, value): self.Author.append(value)
    def insert_Author(self, index, value): self.Author[index] = value
    def get_AutoRefresh(self): return self.AutoRefresh
    def set_AutoRefresh(self, AutoRefresh): self.AutoRefresh = AutoRefresh
    def add_AutoRefresh(self, value): self.AutoRefresh.append(value)
    def insert_AutoRefresh(self, index, value): self.AutoRefresh[index] = value
    def get_DataSources(self): return self.DataSources
    def set_DataSources(self, DataSources): self.DataSources = DataSources
    def add_DataSources(self, value): self.DataSources.append(value)
    def insert_DataSources(self, index, value): self.DataSources[index] = value
    def get_DataSets(self): return self.DataSets
    def set_DataSets(self, DataSets): self.DataSets = DataSets
    def add_DataSets(self, value): self.DataSets.append(value)
    def insert_DataSets(self, index, value): self.DataSets[index] = value
    def get_Body(self): return self.Body
    def set_Body(self, Body): self.Body = Body
    def add_Body(self, value): self.Body.append(value)
    def insert_Body(self, index, value): self.Body[index] = value
    def get_ReportParameters(self): return self.ReportParameters
    def set_ReportParameters(self, ReportParameters): self.ReportParameters = ReportParameters
    def add_ReportParameters(self, value): self.ReportParameters.append(value)
    def insert_ReportParameters(self, index, value): self.ReportParameters[index] = value
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code(self, index, value): self.Code[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Page(self): return self.Page
    def set_Page(self, Page): self.Page = Page
    def add_Page(self, value): self.Page.append(value)
    def insert_Page(self, index, value): self.Page[index] = value
    def get_EmbeddedImages(self): return self.EmbeddedImages
    def set_EmbeddedImages(self, EmbeddedImages): self.EmbeddedImages = EmbeddedImages
    def add_EmbeddedImages(self, value): self.EmbeddedImages.append(value)
    def insert_EmbeddedImages(self, index, value): self.EmbeddedImages[index] = value
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def add_Language(self, value): self.Language.append(value)
    def insert_Language(self, index, value): self.Language[index] = value
    def get_CodeModules(self): return self.CodeModules
    def set_CodeModules(self, CodeModules): self.CodeModules = CodeModules
    def add_CodeModules(self, value): self.CodeModules.append(value)
    def insert_CodeModules(self, index, value): self.CodeModules[index] = value
    def get_Classes(self): return self.Classes
    def set_Classes(self, Classes): self.Classes = Classes
    def add_Classes(self, value): self.Classes.append(value)
    def insert_Classes(self, index, value): self.Classes[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_Variables(self): return self.Variables
    def set_Variables(self, Variables): self.Variables = Variables
    def add_Variables(self, value): self.Variables.append(value)
    def insert_Variables(self, index, value): self.Variables[index] = value
    def get_DeferVariableEvaluation(self): return self.DeferVariableEvaluation
    def set_DeferVariableEvaluation(self, DeferVariableEvaluation): self.DeferVariableEvaluation = DeferVariableEvaluation
    def add_DeferVariableEvaluation(self, value): self.DeferVariableEvaluation.append(value)
    def insert_DeferVariableEvaluation(self, index, value): self.DeferVariableEvaluation[index] = value
    def get_ConsumeContainerWhitespace(self): return self.ConsumeContainerWhitespace
    def set_ConsumeContainerWhitespace(self, ConsumeContainerWhitespace): self.ConsumeContainerWhitespace = ConsumeContainerWhitespace
    def add_ConsumeContainerWhitespace(self, value): self.ConsumeContainerWhitespace.append(value)
    def insert_ConsumeContainerWhitespace(self, index, value): self.ConsumeContainerWhitespace[index] = value
    def get_DataTransform(self): return self.DataTransform
    def set_DataTransform(self, DataTransform): self.DataTransform = DataTransform
    def add_DataTransform(self, value): self.DataTransform.append(value)
    def insert_DataTransform(self, index, value): self.DataTransform[index] = value
    def get_DataSchema(self): return self.DataSchema
    def set_DataSchema(self, DataSchema): self.DataSchema = DataSchema
    def add_DataSchema(self, value): self.DataSchema.append(value)
    def insert_DataSchema(self, index, value): self.DataSchema[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementStyle(self): return self.DataElementStyle
    def set_DataElementStyle(self, DataElementStyle): self.DataElementStyle = DataElementStyle
    def add_DataElementStyle(self, value): self.DataElementStyle.append(value)
    def insert_DataElementStyle(self, index, value): self.DataElementStyle[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='Report', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Report')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Report'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Report', fromsubclass_=False):
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description')
        for Author_ in self.Author:
            showIndent(outfile, level)
            outfile.write('<%sAuthor>%s</%sAuthor>\n' % (namespace_, self.gds_format_string(quote_xml(Author_).encode(ExternalEncoding), input_name='Author'), namespace_))
        for AutoRefresh_ in self.AutoRefresh:
            showIndent(outfile, level)
            outfile.write('<%sAutoRefresh>%s</%sAutoRefresh>\n' % (namespace_, self.gds_format_integer(AutoRefresh_, input_name='AutoRefresh'), namespace_))
        for DataSources_ in self.DataSources:
            DataSources_.export(outfile, level, namespace_, name_='DataSources')
        for DataSets_ in self.DataSets:
            DataSets_.export(outfile, level, namespace_, name_='DataSets')
        for Body_ in self.Body:
            Body_.export(outfile, level, namespace_, name_='Body')
        for ReportParameters_ in self.ReportParameters:
            ReportParameters_.export(outfile, level, namespace_, name_='ReportParameters')
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('<%sCode>%s</%sCode>\n' % (namespace_, self.gds_format_string(quote_xml(Code_).encode(ExternalEncoding), input_name='Code'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for Page_ in self.Page:
            Page_.export(outfile, level, namespace_, name_='Page')
        for EmbeddedImages_ in self.EmbeddedImages:
            EmbeddedImages_.export(outfile, level, namespace_, name_='EmbeddedImages')
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('<%sLanguage>%s</%sLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(Language_).encode(ExternalEncoding), input_name='Language'), namespace_))
        for CodeModules_ in self.CodeModules:
            CodeModules_.export(outfile, level, namespace_, name_='CodeModules')
        for Classes_ in self.Classes:
            Classes_.export(outfile, level, namespace_, name_='Classes')
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for Variables_ in self.Variables:
            Variables_.export(outfile, level, namespace_, name_='Variables')
        for DeferVariableEvaluation_ in self.DeferVariableEvaluation:
            showIndent(outfile, level)
            outfile.write('<%sDeferVariableEvaluation>%s</%sDeferVariableEvaluation>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(DeferVariableEvaluation_)), input_name='DeferVariableEvaluation'), namespace_))
        for ConsumeContainerWhitespace_ in self.ConsumeContainerWhitespace:
            showIndent(outfile, level)
            outfile.write('<%sConsumeContainerWhitespace>%s</%sConsumeContainerWhitespace>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(ConsumeContainerWhitespace_)), input_name='ConsumeContainerWhitespace'), namespace_))
        for DataTransform_ in self.DataTransform:
            showIndent(outfile, level)
            outfile.write('<%sDataTransform>%s</%sDataTransform>\n' % (namespace_, self.gds_format_string(quote_xml(DataTransform_).encode(ExternalEncoding), input_name='DataTransform'), namespace_))
        for DataSchema_ in self.DataSchema:
            showIndent(outfile, level)
            outfile.write('<%sDataSchema>%s</%sDataSchema>\n' % (namespace_, self.gds_format_string(quote_xml(DataSchema_).encode(ExternalEncoding), input_name='DataSchema'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementStyle_ in self.DataElementStyle:
            showIndent(outfile, level)
            outfile.write('<%sDataElementStyle>%s</%sDataElementStyle>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementStyle_).encode(ExternalEncoding), input_name='DataElementStyle'), namespace_))
    def hasContent_(self):
        if (
            self.Description or
            self.Author or
            self.AutoRefresh or
            self.DataSources or
            self.DataSets or
            self.Body or
            self.ReportParameters or
            self.Code or
            self.Width or
            self.Page or
            self.EmbeddedImages or
            self.Language or
            self.CodeModules or
            self.Classes or
            self.CustomProperties or
            self.Variables or
            self.DeferVariableEvaluation or
            self.ConsumeContainerWhitespace or
            self.DataTransform or
            self.DataSchema or
            self.DataElementName or
            self.DataElementStyle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Report'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Description_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Author=[\n')
        level += 1
        for Author_ in self.Author:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Author_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AutoRefresh=[\n')
        level += 1
        for AutoRefresh_ in self.AutoRefresh:
            showIndent(outfile, level)
            outfile.write('%d,\n' % AutoRefresh)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSources=[\n')
        level += 1
        for DataSources_ in self.DataSources:
            showIndent(outfile, level)
            outfile.write('model_.DataSourcesType(\n')
            DataSources_.exportLiteral(outfile, level, name_='DataSourcesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSets=[\n')
        level += 1
        for DataSets_ in self.DataSets:
            showIndent(outfile, level)
            outfile.write('model_.DataSetsType(\n')
            DataSets_.exportLiteral(outfile, level, name_='DataSetsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Body=[\n')
        level += 1
        for Body_ in self.Body:
            showIndent(outfile, level)
            outfile.write('model_.BodyType(\n')
            Body_.exportLiteral(outfile, level, name_='BodyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportParameters=[\n')
        level += 1
        for ReportParameters_ in self.ReportParameters:
            showIndent(outfile, level)
            outfile.write('model_.ReportParametersType(\n')
            ReportParameters_.exportLiteral(outfile, level, name_='ReportParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Page=[\n')
        level += 1
        for Page_ in self.Page:
            showIndent(outfile, level)
            outfile.write('model_.PageType(\n')
            Page_.exportLiteral(outfile, level, name_='PageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EmbeddedImages=[\n')
        level += 1
        for EmbeddedImages_ in self.EmbeddedImages:
            showIndent(outfile, level)
            outfile.write('model_.EmbeddedImagesType(\n')
            EmbeddedImages_.exportLiteral(outfile, level, name_='EmbeddedImagesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Language=[\n')
        level += 1
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodeModules=[\n')
        level += 1
        for CodeModules_ in self.CodeModules:
            showIndent(outfile, level)
            outfile.write('model_.CodeModulesType(\n')
            CodeModules_.exportLiteral(outfile, level, name_='CodeModulesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Classes=[\n')
        level += 1
        for Classes_ in self.Classes:
            showIndent(outfile, level)
            outfile.write('model_.ClassesType(\n')
            Classes_.exportLiteral(outfile, level, name_='ClassesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Variables=[\n')
        level += 1
        for Variables_ in self.Variables:
            showIndent(outfile, level)
            outfile.write('model_.VariablesType(\n')
            Variables_.exportLiteral(outfile, level, name_='VariablesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DeferVariableEvaluation=[\n')
        level += 1
        for DeferVariableEvaluation_ in self.DeferVariableEvaluation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % DeferVariableEvaluation)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConsumeContainerWhitespace=[\n')
        level += 1
        for ConsumeContainerWhitespace_ in self.ConsumeContainerWhitespace:
            showIndent(outfile, level)
            outfile.write('%s,\n' % ConsumeContainerWhitespace)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataTransform=[\n')
        level += 1
        for DataTransform_ in self.DataTransform:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataTransform_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSchema=[\n')
        level += 1
        for DataSchema_ in self.DataSchema:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSchema_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementStyle=[\n')
        level += 1
        for DataElementStyle_ in self.DataElementStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
        elif nodeName_ == 'Author':
            Author_ = child_.text
            Author_ = self.gds_validate_string(Author_, node, 'Author')
            self.Author.append(Author_)
        elif nodeName_ == 'AutoRefresh':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutoRefresh')
            self.AutoRefresh.append(ival_)
        elif nodeName_ == 'DataSources':
            obj_ = DataSourcesType.factory()
            obj_.build(child_)
            self.DataSources.append(obj_)
        elif nodeName_ == 'DataSets':
            obj_ = DataSetsType.factory()
            obj_.build(child_)
            self.DataSets.append(obj_)
        elif nodeName_ == 'Body':
            obj_ = BodyType.factory()
            obj_.build(child_)
            self.Body.append(obj_)
        elif nodeName_ == 'ReportParameters':
            obj_ = ReportParametersType.factory()
            obj_.build(child_)
            self.ReportParameters.append(obj_)
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code.append(Code_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'Page':
            obj_ = PageType.factory()
            obj_.build(child_)
            self.Page.append(obj_)
        elif nodeName_ == 'EmbeddedImages':
            obj_ = EmbeddedImagesType.factory()
            obj_.build(child_)
            self.EmbeddedImages.append(obj_)
        elif nodeName_ == 'Language':
            Language_ = child_.text
            Language_ = self.gds_validate_string(Language_, node, 'Language')
            self.Language.append(Language_)
        elif nodeName_ == 'CodeModules':
            obj_ = CodeModulesType.factory()
            obj_.build(child_)
            self.CodeModules.append(obj_)
        elif nodeName_ == 'Classes':
            obj_ = ClassesType.factory()
            obj_.build(child_)
            self.Classes.append(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'Variables':
            obj_ = VariablesType.factory()
            obj_.build(child_)
            self.Variables.append(obj_)
        elif nodeName_ == 'DeferVariableEvaluation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'DeferVariableEvaluation')
            self.DeferVariableEvaluation.append(ival_)
        elif nodeName_ == 'ConsumeContainerWhitespace':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ConsumeContainerWhitespace')
            self.ConsumeContainerWhitespace.append(ival_)
        elif nodeName_ == 'DataTransform':
            DataTransform_ = child_.text
            DataTransform_ = self.gds_validate_string(DataTransform_, node, 'DataTransform')
            self.DataTransform.append(DataTransform_)
        elif nodeName_ == 'DataSchema':
            DataSchema_ = child_.text
            DataSchema_ = self.gds_validate_string(DataSchema_, node, 'DataSchema')
            self.DataSchema.append(DataSchema_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementStyle':
            DataElementStyle_ = child_.text
            DataElementStyle_ = self.gds_validate_string(DataElementStyle_, node, 'DataElementStyle')
            self.DataElementStyle.append(DataElementStyle_)
# end class Report


class DataElementStyle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DataElementStyle.subclass:
            return DataElementStyle.subclass(*args_, **kwargs_)
        else:
            return DataElementStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DataElementStyle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataElementStyle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataElementStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataElementStyle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataElementStyle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataElementStyle


class ReportParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReportParameter=None):
        if ReportParameter is None:
            self.ReportParameter = []
        else:
            self.ReportParameter = ReportParameter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ReportParametersType.subclass:
            return ReportParametersType.subclass(*args_, **kwargs_)
        else:
            return ReportParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReportParameter(self): return self.ReportParameter
    def set_ReportParameter(self, ReportParameter): self.ReportParameter = ReportParameter
    def add_ReportParameter(self, value): self.ReportParameter.append(value)
    def insert_ReportParameter(self, index, value): self.ReportParameter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ReportParametersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportParametersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportParametersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReportParametersType', fromsubclass_=False):
        for ReportParameter_ in self.ReportParameter:
            ReportParameter_.export(outfile, level, namespace_, name_='ReportParameter')
    def hasContent_(self):
        if (
            self.ReportParameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReportParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ReportParameter=[\n')
        level += 1
        for ReportParameter_ in self.ReportParameter:
            showIndent(outfile, level)
            outfile.write('model_.ReportParameterType(\n')
            ReportParameter_.exportLiteral(outfile, level, name_='ReportParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReportParameter':
            obj_ = ReportParameterType.factory()
            obj_.build(child_)
            self.ReportParameter.append(obj_)
# end class ReportParametersType


class ReportParameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, DataType=None, Nullable=None, DefaultValue=None, AllowBlank=None, Prompt=None, ValidValues=None, Hidden=None, MultiValue=None, UsedInQuery=None):
        self.Name = _cast(None, Name)
        if DataType is None:
            self.DataType = []
        else:
            self.DataType = DataType
        if Nullable is None:
            self.Nullable = []
        else:
            self.Nullable = Nullable
        if DefaultValue is None:
            self.DefaultValue = []
        else:
            self.DefaultValue = DefaultValue
        if AllowBlank is None:
            self.AllowBlank = []
        else:
            self.AllowBlank = AllowBlank
        if Prompt is None:
            self.Prompt = []
        else:
            self.Prompt = Prompt
        if ValidValues is None:
            self.ValidValues = []
        else:
            self.ValidValues = ValidValues
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if MultiValue is None:
            self.MultiValue = []
        else:
            self.MultiValue = MultiValue
        if UsedInQuery is None:
            self.UsedInQuery = []
        else:
            self.UsedInQuery = UsedInQuery
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ReportParameterType.subclass:
            return ReportParameterType.subclass(*args_, **kwargs_)
        else:
            return ReportParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataType(self): return self.DataType
    def set_DataType(self, DataType): self.DataType = DataType
    def add_DataType(self, value): self.DataType.append(value)
    def insert_DataType(self, index, value): self.DataType[index] = value
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def add_Nullable(self, value): self.Nullable.append(value)
    def insert_Nullable(self, index, value): self.Nullable[index] = value
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def add_DefaultValue(self, value): self.DefaultValue.append(value)
    def insert_DefaultValue(self, index, value): self.DefaultValue[index] = value
    def get_AllowBlank(self): return self.AllowBlank
    def set_AllowBlank(self, AllowBlank): self.AllowBlank = AllowBlank
    def add_AllowBlank(self, value): self.AllowBlank.append(value)
    def insert_AllowBlank(self, index, value): self.AllowBlank[index] = value
    def get_Prompt(self): return self.Prompt
    def set_Prompt(self, Prompt): self.Prompt = Prompt
    def add_Prompt(self, value): self.Prompt.append(value)
    def insert_Prompt(self, index, value): self.Prompt[index] = value
    def get_ValidValues(self): return self.ValidValues
    def set_ValidValues(self, ValidValues): self.ValidValues = ValidValues
    def add_ValidValues(self, value): self.ValidValues.append(value)
    def insert_ValidValues(self, index, value): self.ValidValues[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_MultiValue(self): return self.MultiValue
    def set_MultiValue(self, MultiValue): self.MultiValue = MultiValue
    def add_MultiValue(self, value): self.MultiValue.append(value)
    def insert_MultiValue(self, index, value): self.MultiValue[index] = value
    def get_UsedInQuery(self): return self.UsedInQuery
    def set_UsedInQuery(self, UsedInQuery): self.UsedInQuery = UsedInQuery
    def add_UsedInQuery(self, value): self.UsedInQuery.append(value)
    def insert_UsedInQuery(self, index, value): self.UsedInQuery[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ReportParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportParameterType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportParameterType', fromsubclass_=False):
        for DataType_ in self.DataType:
            showIndent(outfile, level)
            outfile.write('<%sDataType>%s</%sDataType>\n' % (namespace_, self.gds_format_string(quote_xml(DataType_).encode(ExternalEncoding), input_name='DataType'), namespace_))
        for Nullable_ in self.Nullable:
            showIndent(outfile, level)
            outfile.write('<%sNullable>%s</%sNullable>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(Nullable_)), input_name='Nullable'), namespace_))
        for DefaultValue_ in self.DefaultValue:
            DefaultValue_.export(outfile, level, namespace_, name_='DefaultValue')
        for AllowBlank_ in self.AllowBlank:
            showIndent(outfile, level)
            outfile.write('<%sAllowBlank>%s</%sAllowBlank>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(AllowBlank_)), input_name='AllowBlank'), namespace_))
        for Prompt_ in self.Prompt:
            Prompt_.export(outfile, level, namespace_, name_='Prompt')
        for ValidValues_ in self.ValidValues:
            ValidValues_.export(outfile, level, namespace_, name_='ValidValues')
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(Hidden_)), input_name='Hidden'), namespace_))
        for MultiValue_ in self.MultiValue:
            showIndent(outfile, level)
            outfile.write('<%sMultiValue>%s</%sMultiValue>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(MultiValue_)), input_name='MultiValue'), namespace_))
        for UsedInQuery_ in self.UsedInQuery:
            showIndent(outfile, level)
            outfile.write('<%sUsedInQuery>%s</%sUsedInQuery>\n' % (namespace_, self.gds_format_string(quote_xml(UsedInQuery_).encode(ExternalEncoding), input_name='UsedInQuery'), namespace_))
    def hasContent_(self):
        if (
            self.DataType or
            self.Nullable or
            self.DefaultValue or
            self.AllowBlank or
            self.Prompt or
            self.ValidValues or
            self.Hidden or
            self.MultiValue or
            self.UsedInQuery
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReportParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataType=[\n')
        level += 1
        for DataType_ in self.DataType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Nullable=[\n')
        level += 1
        for Nullable_ in self.Nullable:
            showIndent(outfile, level)
            outfile.write('%s,\n' % Nullable)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DefaultValue=[\n')
        level += 1
        for DefaultValue_ in self.DefaultValue:
            showIndent(outfile, level)
            outfile.write('model_.DefaultValueType(\n')
            DefaultValue_.exportLiteral(outfile, level, name_='DefaultValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllowBlank=[\n')
        level += 1
        for AllowBlank_ in self.AllowBlank:
            showIndent(outfile, level)
            outfile.write('%s,\n' % AllowBlank)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Prompt=[\n')
        level += 1
        for Prompt_ in self.Prompt:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Prompt_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ValidValues=[\n')
        level += 1
        for ValidValues_ in self.ValidValues:
            showIndent(outfile, level)
            outfile.write('model_.ValidValuesType(\n')
            ValidValues_.exportLiteral(outfile, level, name_='ValidValuesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % Hidden)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MultiValue=[\n')
        level += 1
        for MultiValue_ in self.MultiValue:
            showIndent(outfile, level)
            outfile.write('%s,\n' % MultiValue)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UsedInQuery=[\n')
        level += 1
        for UsedInQuery_ in self.UsedInQuery:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UsedInQuery_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataType':
            DataType_ = child_.text
            DataType_ = self.gds_validate_string(DataType_, node, 'DataType')
            self.DataType.append(DataType_)
        elif nodeName_ == 'Nullable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Nullable')
            self.Nullable.append(ival_)
        elif nodeName_ == 'DefaultValue':
            obj_ = DefaultValueType.factory()
            obj_.build(child_)
            self.DefaultValue.append(obj_)
        elif nodeName_ == 'AllowBlank':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllowBlank')
            self.AllowBlank.append(ival_)
        elif nodeName_ == 'Prompt':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Prompt.append(obj_)
        elif nodeName_ == 'ValidValues':
            obj_ = ValidValuesType.factory()
            obj_.build(child_)
            self.ValidValues.append(obj_)
        elif nodeName_ == 'Hidden':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Hidden')
            self.Hidden.append(ival_)
        elif nodeName_ == 'MultiValue':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MultiValue')
            self.MultiValue.append(ival_)
        elif nodeName_ == 'UsedInQuery':
            UsedInQuery_ = child_.text
            UsedInQuery_ = self.gds_validate_string(UsedInQuery_, node, 'UsedInQuery')
            self.UsedInQuery.append(UsedInQuery_)
# end class ReportParameterType


class DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DataType.subclass:
            return DataType.subclass(*args_, **kwargs_)
        else:
            return DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataType


class UsedInQuery(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if UsedInQuery.subclass:
            return UsedInQuery.subclass(*args_, **kwargs_)
        else:
            return UsedInQuery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='UsedInQuery', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsedInQuery')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UsedInQuery'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UsedInQuery', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UsedInQuery'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UsedInQuery


class ValidValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSetReference=None, ParameterValues=None):
        if DataSetReference is None:
            self.DataSetReference = []
        else:
            self.DataSetReference = DataSetReference
        if ParameterValues is None:
            self.ParameterValues = []
        else:
            self.ParameterValues = ParameterValues
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ValidValuesType.subclass:
            return ValidValuesType.subclass(*args_, **kwargs_)
        else:
            return ValidValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSetReference(self): return self.DataSetReference
    def set_DataSetReference(self, DataSetReference): self.DataSetReference = DataSetReference
    def add_DataSetReference(self, value): self.DataSetReference.append(value)
    def insert_DataSetReference(self, index, value): self.DataSetReference[index] = value
    def get_ParameterValues(self): return self.ParameterValues
    def set_ParameterValues(self, ParameterValues): self.ParameterValues = ParameterValues
    def add_ParameterValues(self, value): self.ParameterValues.append(value)
    def insert_ParameterValues(self, index, value): self.ParameterValues[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ValidValuesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidValuesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValidValuesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValidValuesType', fromsubclass_=False):
        for DataSetReference_ in self.DataSetReference:
            DataSetReference_.export(outfile, level, namespace_, name_='DataSetReference')
        for ParameterValues_ in self.ParameterValues:
            ParameterValues_.export(outfile, level, namespace_, name_='ParameterValues')
    def hasContent_(self):
        if (
            self.DataSetReference or
            self.ParameterValues
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValidValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSetReference=[\n')
        level += 1
        for DataSetReference_ in self.DataSetReference:
            showIndent(outfile, level)
            outfile.write('model_.DataSetReferenceType(\n')
            DataSetReference_.exportLiteral(outfile, level, name_='DataSetReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParameterValues=[\n')
        level += 1
        for ParameterValues_ in self.ParameterValues:
            showIndent(outfile, level)
            outfile.write('model_.ParameterValuesType(\n')
            ParameterValues_.exportLiteral(outfile, level, name_='ParameterValuesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSetReference':
            obj_ = DataSetReferenceType.factory()
            obj_.build(child_)
            self.DataSetReference.append(obj_)
        elif nodeName_ == 'ParameterValues':
            obj_ = ParameterValuesType.factory()
            obj_.build(child_)
            self.ParameterValues.append(obj_)
# end class ValidValuesType


class DataSetReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSetName=None, ValueField=None, LabelField=None):
        if DataSetName is None:
            self.DataSetName = []
        else:
            self.DataSetName = DataSetName
        if ValueField is None:
            self.ValueField = []
        else:
            self.ValueField = ValueField
        if LabelField is None:
            self.LabelField = []
        else:
            self.LabelField = LabelField
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataSetReferenceType.subclass:
            return DataSetReferenceType.subclass(*args_, **kwargs_)
        else:
            return DataSetReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSetName(self): return self.DataSetName
    def set_DataSetName(self, DataSetName): self.DataSetName = DataSetName
    def add_DataSetName(self, value): self.DataSetName.append(value)
    def insert_DataSetName(self, index, value): self.DataSetName[index] = value
    def get_ValueField(self): return self.ValueField
    def set_ValueField(self, ValueField): self.ValueField = ValueField
    def add_ValueField(self, value): self.ValueField.append(value)
    def insert_ValueField(self, index, value): self.ValueField[index] = value
    def get_LabelField(self): return self.LabelField
    def set_LabelField(self, LabelField): self.LabelField = LabelField
    def add_LabelField(self, value): self.LabelField.append(value)
    def insert_LabelField(self, index, value): self.LabelField[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataSetReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSetReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSetReferenceType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataSetReferenceType', fromsubclass_=False):
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('<%sDataSetName>%s</%sDataSetName>\n' % (namespace_, self.gds_format_string(quote_xml(DataSetName_).encode(ExternalEncoding), input_name='DataSetName'), namespace_))
        for ValueField_ in self.ValueField:
            showIndent(outfile, level)
            outfile.write('<%sValueField>%s</%sValueField>\n' % (namespace_, self.gds_format_string(quote_xml(ValueField_).encode(ExternalEncoding), input_name='ValueField'), namespace_))
        for LabelField_ in self.LabelField:
            showIndent(outfile, level)
            outfile.write('<%sLabelField>%s</%sLabelField>\n' % (namespace_, self.gds_format_string(quote_xml(LabelField_).encode(ExternalEncoding), input_name='LabelField'), namespace_))
    def hasContent_(self):
        if (
            self.DataSetName or
            self.ValueField or
            self.LabelField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSetReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSetName=[\n')
        level += 1
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSetName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ValueField=[\n')
        level += 1
        for ValueField_ in self.ValueField:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ValueField_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LabelField=[\n')
        level += 1
        for LabelField_ in self.LabelField:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LabelField_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSetName':
            DataSetName_ = child_.text
            DataSetName_ = self.gds_validate_string(DataSetName_, node, 'DataSetName')
            self.DataSetName.append(DataSetName_)
        elif nodeName_ == 'ValueField':
            ValueField_ = child_.text
            ValueField_ = self.gds_validate_string(ValueField_, node, 'ValueField')
            self.ValueField.append(ValueField_)
        elif nodeName_ == 'LabelField':
            LabelField_ = child_.text
            LabelField_ = self.gds_validate_string(LabelField_, node, 'LabelField')
            self.LabelField.append(LabelField_)
# end class DataSetReferenceType


class ParameterValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ParameterValue=None):
        if ParameterValue is None:
            self.ParameterValue = []
        else:
            self.ParameterValue = ParameterValue
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ParameterValuesType.subclass:
            return ParameterValuesType.subclass(*args_, **kwargs_)
        else:
            return ParameterValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParameterValue(self): return self.ParameterValue
    def set_ParameterValue(self, ParameterValue): self.ParameterValue = ParameterValue
    def add_ParameterValue(self, value): self.ParameterValue.append(value)
    def insert_ParameterValue(self, index, value): self.ParameterValue[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ParameterValuesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValuesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterValuesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterValuesType', fromsubclass_=False):
        for ParameterValue_ in self.ParameterValue:
            ParameterValue_.export(outfile, level, namespace_, name_='ParameterValue')
    def hasContent_(self):
        if (
            self.ParameterValue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ParameterValue=[\n')
        level += 1
        for ParameterValue_ in self.ParameterValue:
            showIndent(outfile, level)
            outfile.write('model_.ParameterValueType(\n')
            ParameterValue_.exportLiteral(outfile, level, name_='ParameterValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParameterValue':
            obj_ = ParameterValueType.factory()
            obj_.build(child_)
            self.ParameterValue.append(obj_)
# end class ParameterValuesType


class ParameterValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None, Label=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Label is None:
            self.Label = []
        else:
            self.Label = Label
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ParameterValueType.subclass:
            return ParameterValueType.subclass(*args_, **kwargs_)
        else:
            return ParameterValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def add_Label(self, value): self.Label.append(value)
    def insert_Label(self, index, value): self.Label[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ParameterValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterValueType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterValueType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Label_ in self.Label:
            Label_.export(outfile, level, namespace_, name_='Label')
    def hasContent_(self):
        if (
            self.Value or
            self.Label
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Label=[\n')
        level += 1
        for Label_ in self.Label:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Label_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Label':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Label.append(obj_)
# end class ParameterValueType


class DefaultValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSetReference=None, Values=None):
        if DataSetReference is None:
            self.DataSetReference = []
        else:
            self.DataSetReference = DataSetReference
        if Values is None:
            self.Values = []
        else:
            self.Values = Values
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DefaultValueType.subclass:
            return DefaultValueType.subclass(*args_, **kwargs_)
        else:
            return DefaultValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSetReference(self): return self.DataSetReference
    def set_DataSetReference(self, DataSetReference): self.DataSetReference = DataSetReference
    def add_DataSetReference(self, value): self.DataSetReference.append(value)
    def insert_DataSetReference(self, index, value): self.DataSetReference[index] = value
    def get_Values(self): return self.Values
    def set_Values(self, Values): self.Values = Values
    def add_Values(self, value): self.Values.append(value)
    def insert_Values(self, index, value): self.Values[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DefaultValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultValueType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultValueType', fromsubclass_=False):
        for DataSetReference_ in self.DataSetReference:
            DataSetReference_.export(outfile, level, namespace_, name_='DataSetReference')
        for Values_ in self.Values:
            Values_.export(outfile, level, namespace_, name_='Values')
    def hasContent_(self):
        if (
            self.DataSetReference or
            self.Values
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefaultValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSetReference=[\n')
        level += 1
        for DataSetReference_ in self.DataSetReference:
            showIndent(outfile, level)
            outfile.write('model_.DataSetReferenceType(\n')
            DataSetReference_.exportLiteral(outfile, level, name_='DataSetReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Values=[\n')
        level += 1
        for Values_ in self.Values:
            showIndent(outfile, level)
            outfile.write('model_.ValuesType(\n')
            Values_.exportLiteral(outfile, level, name_='ValuesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSetReference':
            obj_ = DataSetReferenceType.factory()
            obj_.build(child_)
            self.DataSetReference.append(obj_)
        elif nodeName_ == 'Values':
            obj_ = ValuesType.factory()
            obj_.build(child_)
            self.Values.append(obj_)
# end class DefaultValueType


class ValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ValuesType.subclass:
            return ValuesType.subclass(*args_, **kwargs_)
        else:
            return ValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ValuesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuesType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class ValuesType


class DataSetsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSet=None):
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataSetsType.subclass:
            return DataSetsType.subclass(*args_, **kwargs_)
        else:
            return DataSetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet(self, index, value): self.DataSet[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataSetsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSetsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSetsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataSetsType', fromsubclass_=False):
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_, name_='DataSet')
    def hasContent_(self):
        if (
            self.DataSet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSetsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('model_.DataSetType(\n')
            DataSet_.exportLiteral(outfile, level, name_='DataSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
# end class DataSetsType


class DataSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Fields=None, Query=None, CaseSensitivity=None, Collation=None, AccentSensitivity=None, KanatypeSensitivity=None, WidthSensitivity=None, Filters=None, InterpretSubtotalsAsDetails=None):
        self.Name = _cast(None, Name)
        if Fields is None:
            self.Fields = []
        else:
            self.Fields = Fields
        if Query is None:
            self.Query = []
        else:
            self.Query = Query
        if CaseSensitivity is None:
            self.CaseSensitivity = []
        else:
            self.CaseSensitivity = CaseSensitivity
        if Collation is None:
            self.Collation = []
        else:
            self.Collation = Collation
        if AccentSensitivity is None:
            self.AccentSensitivity = []
        else:
            self.AccentSensitivity = AccentSensitivity
        if KanatypeSensitivity is None:
            self.KanatypeSensitivity = []
        else:
            self.KanatypeSensitivity = KanatypeSensitivity
        if WidthSensitivity is None:
            self.WidthSensitivity = []
        else:
            self.WidthSensitivity = WidthSensitivity
        if Filters is None:
            self.Filters = []
        else:
            self.Filters = Filters
        if InterpretSubtotalsAsDetails is None:
            self.InterpretSubtotalsAsDetails = []
        else:
            self.InterpretSubtotalsAsDetails = InterpretSubtotalsAsDetails
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataSetType.subclass:
            return DataSetType.subclass(*args_, **kwargs_)
        else:
            return DataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fields(self): return self.Fields
    def set_Fields(self, Fields): self.Fields = Fields
    def add_Fields(self, value): self.Fields.append(value)
    def insert_Fields(self, index, value): self.Fields[index] = value
    def get_Query(self): return self.Query
    def set_Query(self, Query): self.Query = Query
    def add_Query(self, value): self.Query.append(value)
    def insert_Query(self, index, value): self.Query[index] = value
    def get_CaseSensitivity(self): return self.CaseSensitivity
    def set_CaseSensitivity(self, CaseSensitivity): self.CaseSensitivity = CaseSensitivity
    def add_CaseSensitivity(self, value): self.CaseSensitivity.append(value)
    def insert_CaseSensitivity(self, index, value): self.CaseSensitivity[index] = value
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def add_Collation(self, value): self.Collation.append(value)
    def insert_Collation(self, index, value): self.Collation[index] = value
    def get_AccentSensitivity(self): return self.AccentSensitivity
    def set_AccentSensitivity(self, AccentSensitivity): self.AccentSensitivity = AccentSensitivity
    def add_AccentSensitivity(self, value): self.AccentSensitivity.append(value)
    def insert_AccentSensitivity(self, index, value): self.AccentSensitivity[index] = value
    def get_KanatypeSensitivity(self): return self.KanatypeSensitivity
    def set_KanatypeSensitivity(self, KanatypeSensitivity): self.KanatypeSensitivity = KanatypeSensitivity
    def add_KanatypeSensitivity(self, value): self.KanatypeSensitivity.append(value)
    def insert_KanatypeSensitivity(self, index, value): self.KanatypeSensitivity[index] = value
    def get_WidthSensitivity(self): return self.WidthSensitivity
    def set_WidthSensitivity(self, WidthSensitivity): self.WidthSensitivity = WidthSensitivity
    def add_WidthSensitivity(self, value): self.WidthSensitivity.append(value)
    def insert_WidthSensitivity(self, index, value): self.WidthSensitivity[index] = value
    def get_Filters(self): return self.Filters
    def set_Filters(self, Filters): self.Filters = Filters
    def add_Filters(self, value): self.Filters.append(value)
    def insert_Filters(self, index, value): self.Filters[index] = value
    def get_InterpretSubtotalsAsDetails(self): return self.InterpretSubtotalsAsDetails
    def set_InterpretSubtotalsAsDetails(self, InterpretSubtotalsAsDetails): self.InterpretSubtotalsAsDetails = InterpretSubtotalsAsDetails
    def add_InterpretSubtotalsAsDetails(self, value): self.InterpretSubtotalsAsDetails.append(value)
    def insert_InterpretSubtotalsAsDetails(self, index, value): self.InterpretSubtotalsAsDetails[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataSetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSetType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataSetType', fromsubclass_=False):
        for Fields_ in self.Fields:
            Fields_.export(outfile, level, namespace_, name_='Fields')
        for Query_ in self.Query:
            Query_.export(outfile, level, namespace_, name_='Query')
        for CaseSensitivity_ in self.CaseSensitivity:
            showIndent(outfile, level)
            outfile.write('<%sCaseSensitivity>%s</%sCaseSensitivity>\n' % (namespace_, self.gds_format_string(quote_xml(CaseSensitivity_).encode(ExternalEncoding), input_name='CaseSensitivity'), namespace_))
        for Collation_ in self.Collation:
            showIndent(outfile, level)
            outfile.write('<%sCollation>%s</%sCollation>\n' % (namespace_, self.gds_format_string(quote_xml(Collation_).encode(ExternalEncoding), input_name='Collation'), namespace_))
        for AccentSensitivity_ in self.AccentSensitivity:
            showIndent(outfile, level)
            outfile.write('<%sAccentSensitivity>%s</%sAccentSensitivity>\n' % (namespace_, self.gds_format_string(quote_xml(AccentSensitivity_).encode(ExternalEncoding), input_name='AccentSensitivity'), namespace_))
        for KanatypeSensitivity_ in self.KanatypeSensitivity:
            showIndent(outfile, level)
            outfile.write('<%sKanatypeSensitivity>%s</%sKanatypeSensitivity>\n' % (namespace_, self.gds_format_string(quote_xml(KanatypeSensitivity_).encode(ExternalEncoding), input_name='KanatypeSensitivity'), namespace_))
        for WidthSensitivity_ in self.WidthSensitivity:
            showIndent(outfile, level)
            outfile.write('<%sWidthSensitivity>%s</%sWidthSensitivity>\n' % (namespace_, self.gds_format_string(quote_xml(WidthSensitivity_).encode(ExternalEncoding), input_name='WidthSensitivity'), namespace_))
        for Filters_ in self.Filters:
            Filters_.export(outfile, level, namespace_, name_='Filters')
        for InterpretSubtotalsAsDetails_ in self.InterpretSubtotalsAsDetails:
            showIndent(outfile, level)
            outfile.write('<%sInterpretSubtotalsAsDetails>%s</%sInterpretSubtotalsAsDetails>\n' % (namespace_, self.gds_format_string(quote_xml(InterpretSubtotalsAsDetails_).encode(ExternalEncoding), input_name='InterpretSubtotalsAsDetails'), namespace_))
    def hasContent_(self):
        if (
            self.Fields or
            self.Query or
            self.CaseSensitivity or
            self.Collation or
            self.AccentSensitivity or
            self.KanatypeSensitivity or
            self.WidthSensitivity or
            self.Filters or
            self.InterpretSubtotalsAsDetails
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Fields=[\n')
        level += 1
        for Fields_ in self.Fields:
            showIndent(outfile, level)
            outfile.write('model_.FieldsType(\n')
            Fields_.exportLiteral(outfile, level, name_='FieldsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Query=[\n')
        level += 1
        for Query_ in self.Query:
            showIndent(outfile, level)
            outfile.write('model_.QueryType(\n')
            Query_.exportLiteral(outfile, level, name_='QueryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CaseSensitivity=[\n')
        level += 1
        for CaseSensitivity_ in self.CaseSensitivity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CaseSensitivity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Collation=[\n')
        level += 1
        for Collation_ in self.Collation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Collation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AccentSensitivity=[\n')
        level += 1
        for AccentSensitivity_ in self.AccentSensitivity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AccentSensitivity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KanatypeSensitivity=[\n')
        level += 1
        for KanatypeSensitivity_ in self.KanatypeSensitivity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KanatypeSensitivity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('WidthSensitivity=[\n')
        level += 1
        for WidthSensitivity_ in self.WidthSensitivity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(WidthSensitivity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Filters=[\n')
        level += 1
        for Filters_ in self.Filters:
            showIndent(outfile, level)
            outfile.write('model_.FiltersType(\n')
            Filters_.exportLiteral(outfile, level, name_='FiltersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InterpretSubtotalsAsDetails=[\n')
        level += 1
        for InterpretSubtotalsAsDetails_ in self.InterpretSubtotalsAsDetails:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InterpretSubtotalsAsDetails_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fields':
            obj_ = FieldsType.factory()
            obj_.build(child_)
            self.Fields.append(obj_)
        elif nodeName_ == 'Query':
            obj_ = QueryType.factory()
            obj_.build(child_)
            self.Query.append(obj_)
        elif nodeName_ == 'CaseSensitivity':
            CaseSensitivity_ = child_.text
            CaseSensitivity_ = self.gds_validate_string(CaseSensitivity_, node, 'CaseSensitivity')
            self.CaseSensitivity.append(CaseSensitivity_)
        elif nodeName_ == 'Collation':
            Collation_ = child_.text
            Collation_ = self.gds_validate_string(Collation_, node, 'Collation')
            self.Collation.append(Collation_)
        elif nodeName_ == 'AccentSensitivity':
            AccentSensitivity_ = child_.text
            AccentSensitivity_ = self.gds_validate_string(AccentSensitivity_, node, 'AccentSensitivity')
            self.AccentSensitivity.append(AccentSensitivity_)
        elif nodeName_ == 'KanatypeSensitivity':
            KanatypeSensitivity_ = child_.text
            KanatypeSensitivity_ = self.gds_validate_string(KanatypeSensitivity_, node, 'KanatypeSensitivity')
            self.KanatypeSensitivity.append(KanatypeSensitivity_)
        elif nodeName_ == 'WidthSensitivity':
            WidthSensitivity_ = child_.text
            WidthSensitivity_ = self.gds_validate_string(WidthSensitivity_, node, 'WidthSensitivity')
            self.WidthSensitivity.append(WidthSensitivity_)
        elif nodeName_ == 'Filters':
            obj_ = FiltersType.factory()
            obj_.build(child_)
            self.Filters.append(obj_)
        elif nodeName_ == 'InterpretSubtotalsAsDetails':
            InterpretSubtotalsAsDetails_ = child_.text
            InterpretSubtotalsAsDetails_ = self.gds_validate_string(InterpretSubtotalsAsDetails_, node, 'InterpretSubtotalsAsDetails')
            self.InterpretSubtotalsAsDetails.append(InterpretSubtotalsAsDetails_)
# end class DataSetType


class CaseSensitivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if CaseSensitivity.subclass:
            return CaseSensitivity.subclass(*args_, **kwargs_)
        else:
            return CaseSensitivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CaseSensitivity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CaseSensitivity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CaseSensitivity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CaseSensitivity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CaseSensitivity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CaseSensitivity


class AccentSensitivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if AccentSensitivity.subclass:
            return AccentSensitivity.subclass(*args_, **kwargs_)
        else:
            return AccentSensitivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AccentSensitivity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccentSensitivity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccentSensitivity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccentSensitivity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccentSensitivity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccentSensitivity


class KanatypeSensitivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if KanatypeSensitivity.subclass:
            return KanatypeSensitivity.subclass(*args_, **kwargs_)
        else:
            return KanatypeSensitivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='KanatypeSensitivity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KanatypeSensitivity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KanatypeSensitivity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KanatypeSensitivity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KanatypeSensitivity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KanatypeSensitivity


class WidthSensitivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if WidthSensitivity.subclass:
            return WidthSensitivity.subclass(*args_, **kwargs_)
        else:
            return WidthSensitivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='WidthSensitivity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WidthSensitivity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WidthSensitivity'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WidthSensitivity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WidthSensitivity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WidthSensitivity


class InterpretSubtotalsAsDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if InterpretSubtotalsAsDetails.subclass:
            return InterpretSubtotalsAsDetails.subclass(*args_, **kwargs_)
        else:
            return InterpretSubtotalsAsDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='InterpretSubtotalsAsDetails', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterpretSubtotalsAsDetails')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterpretSubtotalsAsDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterpretSubtotalsAsDetails', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InterpretSubtotalsAsDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InterpretSubtotalsAsDetails


class FieldsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Field=None):
        if Field is None:
            self.Field = []
        else:
            self.Field = Field
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FieldsType.subclass:
            return FieldsType.subclass(*args_, **kwargs_)
        else:
            return FieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Field(self): return self.Field
    def set_Field(self, Field): self.Field = Field
    def add_Field(self, value): self.Field.append(value)
    def insert_Field(self, index, value): self.Field[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FieldsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FieldsType', fromsubclass_=False):
        for Field_ in self.Field:
            Field_.export(outfile, level, namespace_, name_='Field')
    def hasContent_(self):
        if (
            self.Field
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FieldsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Field=[\n')
        level += 1
        for Field_ in self.Field:
            showIndent(outfile, level)
            outfile.write('model_.FieldType(\n')
            Field_.exportLiteral(outfile, level, name_='FieldType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Field':
            obj_ = FieldType.factory()
            obj_.build(child_)
            self.Field.append(obj_)
# end class FieldsType


class StringWithDataTypeAttribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataType=None, valueOf_=None, extensiontype_=None):
        self.DataType = _cast(None, DataType)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if StringWithDataTypeAttribute.subclass:
            return StringWithDataTypeAttribute.subclass(*args_, **kwargs_)
        else:
            return StringWithDataTypeAttribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataType(self): return self.DataType
    def set_DataType(self, DataType): self.DataType = DataType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='StringWithDataTypeAttribute', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringWithDataTypeAttribute')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StringWithDataTypeAttribute'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.append('DataType')
            outfile.write(' DataType=%s' % (self.gds_format_string(quote_attrib(self.DataType).encode(ExternalEncoding), input_name='DataType'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='StringWithDataTypeAttribute', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StringWithDataTypeAttribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DataType is not None and 'DataType' not in already_processed:
            already_processed.append('DataType')
            showIndent(outfile, level)
            outfile.write('DataType = "%s",\n' % (self.DataType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DataType', node)
        if value is not None and 'DataType' not in already_processed:
            already_processed.append('DataType')
            self.DataType = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringWithDataTypeAttribute


class FieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, DataField=None, Value=None):
        self.Name = _cast(None, Name)
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FieldType.subclass:
            return FieldType.subclass(*args_, **kwargs_)
        else:
            return FieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FieldType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FieldType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FieldType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FieldType', fromsubclass_=False):
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('<%sDataField>%s</%sDataField>\n' % (namespace_, self.gds_format_string(quote_xml(DataField_).encode(ExternalEncoding), input_name='DataField'), namespace_))
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value')
    def hasContent_(self):
        if (
            self.DataField or
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FieldType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataField_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.StringWithDataTypeAttribute(\n')
            Value_.exportLiteral(outfile, level, name_='StringWithDataTypeAttribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            DataField_ = child_.text
            DataField_ = self.gds_validate_string(DataField_, node, 'DataField')
            self.DataField.append(DataField_)
        elif nodeName_ == 'Value':
            class_obj_ = self.get_class_obj_(child_, StringWithDataTypeAttribute)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Value.append(obj_)
# end class FieldType


class QueryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSourceName=None, CommandType=None, CommandText=None, QueryParameters=None, Timeout=None):
        if DataSourceName is None:
            self.DataSourceName = []
        else:
            self.DataSourceName = DataSourceName
        if CommandType is None:
            self.CommandType = []
        else:
            self.CommandType = CommandType
        if CommandText is None:
            self.CommandText = []
        else:
            self.CommandText = CommandText
        if QueryParameters is None:
            self.QueryParameters = []
        else:
            self.QueryParameters = QueryParameters
        if Timeout is None:
            self.Timeout = []
        else:
            self.Timeout = Timeout
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if QueryType.subclass:
            return QueryType.subclass(*args_, **kwargs_)
        else:
            return QueryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSourceName(self): return self.DataSourceName
    def set_DataSourceName(self, DataSourceName): self.DataSourceName = DataSourceName
    def add_DataSourceName(self, value): self.DataSourceName.append(value)
    def insert_DataSourceName(self, index, value): self.DataSourceName[index] = value
    def get_CommandType(self): return self.CommandType
    def set_CommandType(self, CommandType): self.CommandType = CommandType
    def add_CommandType(self, value): self.CommandType.append(value)
    def insert_CommandType(self, index, value): self.CommandType[index] = value
    def get_CommandText(self): return self.CommandText
    def set_CommandText(self, CommandText): self.CommandText = CommandText
    def add_CommandText(self, value): self.CommandText.append(value)
    def insert_CommandText(self, index, value): self.CommandText[index] = value
    def get_QueryParameters(self): return self.QueryParameters
    def set_QueryParameters(self, QueryParameters): self.QueryParameters = QueryParameters
    def add_QueryParameters(self, value): self.QueryParameters.append(value)
    def insert_QueryParameters(self, index, value): self.QueryParameters[index] = value
    def get_Timeout(self): return self.Timeout
    def set_Timeout(self, Timeout): self.Timeout = Timeout
    def add_Timeout(self, value): self.Timeout.append(value)
    def insert_Timeout(self, index, value): self.Timeout[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='QueryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QueryType', fromsubclass_=False):
        for DataSourceName_ in self.DataSourceName:
            showIndent(outfile, level)
            outfile.write('<%sDataSourceName>%s</%sDataSourceName>\n' % (namespace_, self.gds_format_string(quote_xml(DataSourceName_).encode(ExternalEncoding), input_name='DataSourceName'), namespace_))
        for CommandType_ in self.CommandType:
            showIndent(outfile, level)
            outfile.write('<%sCommandType>%s</%sCommandType>\n' % (namespace_, self.gds_format_string(quote_xml(CommandType_).encode(ExternalEncoding), input_name='CommandType'), namespace_))
        for CommandText_ in self.CommandText:
            showIndent(outfile, level)
            outfile.write('<%sCommandText>%s</%sCommandText>\n' % (namespace_, self.gds_format_string(quote_xml(CommandText_).encode(ExternalEncoding), input_name='CommandText'), namespace_))
        for QueryParameters_ in self.QueryParameters:
            QueryParameters_.export(outfile, level, namespace_, name_='QueryParameters')
        for Timeout_ in self.Timeout:
            showIndent(outfile, level)
            outfile.write('<%sTimeout>%s</%sTimeout>\n' % (namespace_, self.gds_format_integer(Timeout_, input_name='Timeout'), namespace_))
    def hasContent_(self):
        if (
            self.DataSourceName or
            self.CommandType or
            self.CommandText or
            self.QueryParameters or
            self.Timeout
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QueryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSourceName=[\n')
        level += 1
        for DataSourceName_ in self.DataSourceName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSourceName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CommandType=[\n')
        level += 1
        for CommandType_ in self.CommandType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CommandType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CommandText=[\n')
        level += 1
        for CommandText_ in self.CommandText:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CommandText_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('QueryParameters=[\n')
        level += 1
        for QueryParameters_ in self.QueryParameters:
            showIndent(outfile, level)
            outfile.write('model_.QueryParametersType(\n')
            QueryParameters_.exportLiteral(outfile, level, name_='QueryParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Timeout=[\n')
        level += 1
        for Timeout_ in self.Timeout:
            showIndent(outfile, level)
            outfile.write('%d,\n' % Timeout)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSourceName':
            DataSourceName_ = child_.text
            DataSourceName_ = self.gds_validate_string(DataSourceName_, node, 'DataSourceName')
            self.DataSourceName.append(DataSourceName_)
        elif nodeName_ == 'CommandType':
            CommandType_ = child_.text
            CommandType_ = self.gds_validate_string(CommandType_, node, 'CommandType')
            self.CommandType.append(CommandType_)
        elif nodeName_ == 'CommandText':
            CommandText_ = child_.text
            CommandText_ = self.gds_validate_string(CommandText_, node, 'CommandText')
            self.CommandText.append(CommandText_)
        elif nodeName_ == 'QueryParameters':
            obj_ = QueryParametersType.factory()
            obj_.build(child_)
            self.QueryParameters.append(obj_)
        elif nodeName_ == 'Timeout':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Timeout')
            self.Timeout.append(ival_)
# end class QueryType


class CommandType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if CommandType.subclass:
            return CommandType.subclass(*args_, **kwargs_)
        else:
            return CommandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CommandType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommandType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommandType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommandType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CommandType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommandType


class DataSourcesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSource=None):
        if DataSource is None:
            self.DataSource = []
        else:
            self.DataSource = DataSource
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataSourcesType.subclass:
            return DataSourcesType.subclass(*args_, **kwargs_)
        else:
            return DataSourcesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSource(self): return self.DataSource
    def set_DataSource(self, DataSource): self.DataSource = DataSource
    def add_DataSource(self, value): self.DataSource.append(value)
    def insert_DataSource(self, index, value): self.DataSource[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataSourcesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSourcesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSourcesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataSourcesType', fromsubclass_=False):
        for DataSource_ in self.DataSource:
            DataSource_.export(outfile, level, namespace_, name_='DataSource')
    def hasContent_(self):
        if (
            self.DataSource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSourcesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSource=[\n')
        level += 1
        for DataSource_ in self.DataSource:
            showIndent(outfile, level)
            outfile.write('model_.DataSourceType(\n')
            DataSource_.exportLiteral(outfile, level, name_='DataSourceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSource':
            obj_ = DataSourceType.factory()
            obj_.build(child_)
            self.DataSource.append(obj_)
# end class DataSourcesType


class DataSourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Transaction=None, ConnectionProperties=None, DataSourceReference=None):
        self.Name = _cast(None, Name)
        if Transaction is None:
            self.Transaction = []
        else:
            self.Transaction = Transaction
        if ConnectionProperties is None:
            self.ConnectionProperties = []
        else:
            self.ConnectionProperties = ConnectionProperties
        if DataSourceReference is None:
            self.DataSourceReference = []
        else:
            self.DataSourceReference = DataSourceReference
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataSourceType.subclass:
            return DataSourceType.subclass(*args_, **kwargs_)
        else:
            return DataSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transaction(self): return self.Transaction
    def set_Transaction(self, Transaction): self.Transaction = Transaction
    def add_Transaction(self, value): self.Transaction.append(value)
    def insert_Transaction(self, index, value): self.Transaction[index] = value
    def get_ConnectionProperties(self): return self.ConnectionProperties
    def set_ConnectionProperties(self, ConnectionProperties): self.ConnectionProperties = ConnectionProperties
    def add_ConnectionProperties(self, value): self.ConnectionProperties.append(value)
    def insert_ConnectionProperties(self, index, value): self.ConnectionProperties[index] = value
    def get_DataSourceReference(self): return self.DataSourceReference
    def set_DataSourceReference(self, DataSourceReference): self.DataSourceReference = DataSourceReference
    def add_DataSourceReference(self, value): self.DataSourceReference.append(value)
    def insert_DataSourceReference(self, index, value): self.DataSourceReference[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataSourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataSourceType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataSourceType', fromsubclass_=False):
        for Transaction_ in self.Transaction:
            showIndent(outfile, level)
            outfile.write('<%sTransaction>%s</%sTransaction>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(Transaction_)), input_name='Transaction'), namespace_))
        for ConnectionProperties_ in self.ConnectionProperties:
            ConnectionProperties_.export(outfile, level, namespace_, name_='ConnectionProperties')
        for DataSourceReference_ in self.DataSourceReference:
            showIndent(outfile, level)
            outfile.write('<%sDataSourceReference>%s</%sDataSourceReference>\n' % (namespace_, self.gds_format_string(quote_xml(DataSourceReference_).encode(ExternalEncoding), input_name='DataSourceReference'), namespace_))
    def hasContent_(self):
        if (
            self.Transaction or
            self.ConnectionProperties or
            self.DataSourceReference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataSourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transaction=[\n')
        level += 1
        for Transaction_ in self.Transaction:
            showIndent(outfile, level)
            outfile.write('%s,\n' % Transaction)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConnectionProperties=[\n')
        level += 1
        for ConnectionProperties_ in self.ConnectionProperties:
            showIndent(outfile, level)
            outfile.write('model_.ConnectionPropertiesType(\n')
            ConnectionProperties_.exportLiteral(outfile, level, name_='ConnectionPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSourceReference=[\n')
        level += 1
        for DataSourceReference_ in self.DataSourceReference:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSourceReference_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transaction':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Transaction')
            self.Transaction.append(ival_)
        elif nodeName_ == 'ConnectionProperties':
            obj_ = ConnectionPropertiesType.factory()
            obj_.build(child_)
            self.ConnectionProperties.append(obj_)
        elif nodeName_ == 'DataSourceReference':
            DataSourceReference_ = child_.text
            DataSourceReference_ = self.gds_validate_string(DataSourceReference_, node, 'DataSourceReference')
            self.DataSourceReference.append(DataSourceReference_)
# end class DataSourceType


class ConnectionPropertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataProvider=None, ConnectString=None, IntegratedSecurity=None, Prompt=None):
        if DataProvider is None:
            self.DataProvider = []
        else:
            self.DataProvider = DataProvider
        if ConnectString is None:
            self.ConnectString = []
        else:
            self.ConnectString = ConnectString
        if IntegratedSecurity is None:
            self.IntegratedSecurity = []
        else:
            self.IntegratedSecurity = IntegratedSecurity
        if Prompt is None:
            self.Prompt = []
        else:
            self.Prompt = Prompt
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ConnectionPropertiesType.subclass:
            return ConnectionPropertiesType.subclass(*args_, **kwargs_)
        else:
            return ConnectionPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataProvider(self): return self.DataProvider
    def set_DataProvider(self, DataProvider): self.DataProvider = DataProvider
    def add_DataProvider(self, value): self.DataProvider.append(value)
    def insert_DataProvider(self, index, value): self.DataProvider[index] = value
    def get_ConnectString(self): return self.ConnectString
    def set_ConnectString(self, ConnectString): self.ConnectString = ConnectString
    def add_ConnectString(self, value): self.ConnectString.append(value)
    def insert_ConnectString(self, index, value): self.ConnectString[index] = value
    def get_IntegratedSecurity(self): return self.IntegratedSecurity
    def set_IntegratedSecurity(self, IntegratedSecurity): self.IntegratedSecurity = IntegratedSecurity
    def add_IntegratedSecurity(self, value): self.IntegratedSecurity.append(value)
    def insert_IntegratedSecurity(self, index, value): self.IntegratedSecurity[index] = value
    def get_Prompt(self): return self.Prompt
    def set_Prompt(self, Prompt): self.Prompt = Prompt
    def add_Prompt(self, value): self.Prompt.append(value)
    def insert_Prompt(self, index, value): self.Prompt[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ConnectionPropertiesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectionPropertiesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectionPropertiesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectionPropertiesType', fromsubclass_=False):
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level)
            outfile.write('<%sDataProvider>%s</%sDataProvider>\n' % (namespace_, self.gds_format_string(quote_xml(DataProvider_).encode(ExternalEncoding), input_name='DataProvider'), namespace_))
        for ConnectString_ in self.ConnectString:
            showIndent(outfile, level)
            outfile.write('<%sConnectString>%s</%sConnectString>\n' % (namespace_, self.gds_format_string(quote_xml(ConnectString_).encode(ExternalEncoding), input_name='ConnectString'), namespace_))
        for IntegratedSecurity_ in self.IntegratedSecurity:
            showIndent(outfile, level)
            outfile.write('<%sIntegratedSecurity>%s</%sIntegratedSecurity>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(IntegratedSecurity_)), input_name='IntegratedSecurity'), namespace_))
        for Prompt_ in self.Prompt:
            Prompt_.export(outfile, level, namespace_, name_='Prompt')
    def hasContent_(self):
        if (
            self.DataProvider or
            self.ConnectString or
            self.IntegratedSecurity or
            self.Prompt
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConnectionPropertiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataProvider=[\n')
        level += 1
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataProvider_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConnectString=[\n')
        level += 1
        for ConnectString_ in self.ConnectString:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ConnectString_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntegratedSecurity=[\n')
        level += 1
        for IntegratedSecurity_ in self.IntegratedSecurity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % IntegratedSecurity)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Prompt=[\n')
        level += 1
        for Prompt_ in self.Prompt:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Prompt_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataProvider':
            DataProvider_ = child_.text
            DataProvider_ = self.gds_validate_string(DataProvider_, node, 'DataProvider')
            self.DataProvider.append(DataProvider_)
        elif nodeName_ == 'ConnectString':
            ConnectString_ = child_.text
            ConnectString_ = self.gds_validate_string(ConnectString_, node, 'ConnectString')
            self.ConnectString.append(ConnectString_)
        elif nodeName_ == 'IntegratedSecurity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IntegratedSecurity')
            self.IntegratedSecurity.append(ival_)
        elif nodeName_ == 'Prompt':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Prompt.append(obj_)
# end class ConnectionPropertiesType


class QueryParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, QueryParameter=None):
        if QueryParameter is None:
            self.QueryParameter = []
        else:
            self.QueryParameter = QueryParameter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if QueryParametersType.subclass:
            return QueryParametersType.subclass(*args_, **kwargs_)
        else:
            return QueryParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QueryParameter(self): return self.QueryParameter
    def set_QueryParameter(self, QueryParameter): self.QueryParameter = QueryParameter
    def add_QueryParameter(self, value): self.QueryParameter.append(value)
    def insert_QueryParameter(self, index, value): self.QueryParameter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='QueryParametersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryParametersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryParametersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='QueryParametersType', fromsubclass_=False):
        for QueryParameter_ in self.QueryParameter:
            QueryParameter_.export(outfile, level, namespace_, name_='QueryParameter')
    def hasContent_(self):
        if (
            self.QueryParameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QueryParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('QueryParameter=[\n')
        level += 1
        for QueryParameter_ in self.QueryParameter:
            showIndent(outfile, level)
            outfile.write('model_.QueryParameterType(\n')
            QueryParameter_.exportLiteral(outfile, level, name_='QueryParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QueryParameter':
            obj_ = QueryParameterType.factory()
            obj_.build(child_)
            self.QueryParameter.append(obj_)
# end class QueryParametersType


class QueryParameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None):
        self.Name = _cast(None, Name)
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if QueryParameterType.subclass:
            return QueryParameterType.subclass(*args_, **kwargs_)
        else:
            return QueryParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='QueryParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryParameterType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryParameterType', fromsubclass_=False):
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value')
    def hasContent_(self):
        if (
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='QueryParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.StringWithDataTypeAttribute(\n')
            Value_.exportLiteral(outfile, level, name_='StringWithDataTypeAttribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            class_obj_ = self.get_class_obj_(child_, StringWithDataTypeAttribute)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Value.append(obj_)
# end class QueryParameterType


class CodeModulesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CodeModule=None):
        if CodeModule is None:
            self.CodeModule = []
        else:
            self.CodeModule = CodeModule
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CodeModulesType.subclass:
            return CodeModulesType.subclass(*args_, **kwargs_)
        else:
            return CodeModulesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CodeModule(self): return self.CodeModule
    def set_CodeModule(self, CodeModule): self.CodeModule = CodeModule
    def add_CodeModule(self, value): self.CodeModule.append(value)
    def insert_CodeModule(self, index, value): self.CodeModule[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CodeModulesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeModulesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeModulesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CodeModulesType', fromsubclass_=False):
        for CodeModule_ in self.CodeModule:
            showIndent(outfile, level)
            outfile.write('<%sCodeModule>%s</%sCodeModule>\n' % (namespace_, self.gds_format_string(quote_xml(CodeModule_).encode(ExternalEncoding), input_name='CodeModule'), namespace_))
    def hasContent_(self):
        if (
            self.CodeModule
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeModulesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CodeModule=[\n')
        level += 1
        for CodeModule_ in self.CodeModule:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CodeModule_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CodeModule':
            CodeModule_ = child_.text
            CodeModule_ = self.gds_validate_string(CodeModule_, node, 'CodeModule')
            self.CodeModule.append(CodeModule_)
# end class CodeModulesType


class ClassesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Class=None):
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ClassesType.subclass:
            return ClassesType.subclass(*args_, **kwargs_)
        else:
            return ClassesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Class(self): return self.Class
    def set_Class(self, Class): self.Class = Class
    def add_Class(self, value): self.Class.append(value)
    def insert_Class(self, index, value): self.Class[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ClassesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClassesType', fromsubclass_=False):
        for Class_ in self.Class:
            Class_.export(outfile, level, namespace_, name_='Class')
    def hasContent_(self):
        if (
            self.Class
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClassesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Class=[\n')
        level += 1
        for Class_ in self.Class:
            showIndent(outfile, level)
            outfile.write('model_.ClassType(\n')
            Class_.exportLiteral(outfile, level, name_='ClassType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Class':
            obj_ = ClassType.factory()
            obj_.build(child_)
            self.Class.append(obj_)
# end class ClassesType


class ClassType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ClassName=None, InstanceName=None):
        if ClassName is None:
            self.ClassName = []
        else:
            self.ClassName = ClassName
        if InstanceName is None:
            self.InstanceName = []
        else:
            self.InstanceName = InstanceName
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ClassType.subclass:
            return ClassType.subclass(*args_, **kwargs_)
        else:
            return ClassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClassName(self): return self.ClassName
    def set_ClassName(self, ClassName): self.ClassName = ClassName
    def add_ClassName(self, value): self.ClassName.append(value)
    def insert_ClassName(self, index, value): self.ClassName[index] = value
    def get_InstanceName(self): return self.InstanceName
    def set_InstanceName(self, InstanceName): self.InstanceName = InstanceName
    def add_InstanceName(self, value): self.InstanceName.append(value)
    def insert_InstanceName(self, index, value): self.InstanceName[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ClassType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ClassType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ClassType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ClassType', fromsubclass_=False):
        for ClassName_ in self.ClassName:
            showIndent(outfile, level)
            outfile.write('<%sClassName>%s</%sClassName>\n' % (namespace_, self.gds_format_string(quote_xml(ClassName_).encode(ExternalEncoding), input_name='ClassName'), namespace_))
        for InstanceName_ in self.InstanceName:
            showIndent(outfile, level)
            outfile.write('<%sInstanceName>%s</%sInstanceName>\n' % (namespace_, self.gds_format_string(quote_xml(InstanceName_).encode(ExternalEncoding), input_name='InstanceName'), namespace_))
    def hasContent_(self):
        if (
            self.ClassName or
            self.InstanceName
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ClassType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ClassName=[\n')
        level += 1
        for ClassName_ in self.ClassName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ClassName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InstanceName=[\n')
        level += 1
        for InstanceName_ in self.InstanceName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InstanceName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClassName':
            ClassName_ = child_.text
            ClassName_ = self.gds_validate_string(ClassName_, node, 'ClassName')
            self.ClassName.append(ClassName_)
        elif nodeName_ == 'InstanceName':
            InstanceName_ = child_.text
            InstanceName_ = self.gds_validate_string(InstanceName_, node, 'InstanceName')
            self.InstanceName.append(InstanceName_)
# end class ClassType


class BodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReportItems=None, Height=None, Style=None):
        if ReportItems is None:
            self.ReportItems = []
        else:
            self.ReportItems = ReportItems
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BodyType.subclass:
            return BodyType.subclass(*args_, **kwargs_)
        else:
            return BodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReportItems(self): return self.ReportItems
    def set_ReportItems(self, ReportItems): self.ReportItems = ReportItems
    def add_ReportItems(self, value): self.ReportItems.append(value)
    def insert_ReportItems(self, index, value): self.ReportItems[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BodyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BodyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BodyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BodyType', fromsubclass_=False):
        for ReportItems_ in self.ReportItems:
            ReportItems_.export(outfile, level, namespace_, name_='ReportItems')
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.ReportItems or
            self.Height or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BodyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ReportItems=[\n')
        level += 1
        for ReportItems_ in self.ReportItems:
            showIndent(outfile, level)
            outfile.write('model_.ReportItemsType(\n')
            ReportItems_.exportLiteral(outfile, level, name_='ReportItemsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReportItems':
            obj_ = ReportItemsType.factory()
            obj_.build(child_)
            self.ReportItems.append(obj_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class BodyType


class PageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PageHeader=None, PageFooter=None, PageHeight=None, PageWidth=None, InteractiveHeight=None, InteractiveWidth=None, LeftMargin=None, RightMargin=None, TopMargin=None, BottomMargin=None, Columns=None, ColumnSpacing=None, Style=None):
        if PageHeader is None:
            self.PageHeader = []
        else:
            self.PageHeader = PageHeader
        if PageFooter is None:
            self.PageFooter = []
        else:
            self.PageFooter = PageFooter
        if PageHeight is None:
            self.PageHeight = []
        else:
            self.PageHeight = PageHeight
        if PageWidth is None:
            self.PageWidth = []
        else:
            self.PageWidth = PageWidth
        if InteractiveHeight is None:
            self.InteractiveHeight = []
        else:
            self.InteractiveHeight = InteractiveHeight
        if InteractiveWidth is None:
            self.InteractiveWidth = []
        else:
            self.InteractiveWidth = InteractiveWidth
        if LeftMargin is None:
            self.LeftMargin = []
        else:
            self.LeftMargin = LeftMargin
        if RightMargin is None:
            self.RightMargin = []
        else:
            self.RightMargin = RightMargin
        if TopMargin is None:
            self.TopMargin = []
        else:
            self.TopMargin = TopMargin
        if BottomMargin is None:
            self.BottomMargin = []
        else:
            self.BottomMargin = BottomMargin
        if Columns is None:
            self.Columns = []
        else:
            self.Columns = Columns
        if ColumnSpacing is None:
            self.ColumnSpacing = []
        else:
            self.ColumnSpacing = ColumnSpacing
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PageType.subclass:
            return PageType.subclass(*args_, **kwargs_)
        else:
            return PageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PageHeader(self): return self.PageHeader
    def set_PageHeader(self, PageHeader): self.PageHeader = PageHeader
    def add_PageHeader(self, value): self.PageHeader.append(value)
    def insert_PageHeader(self, index, value): self.PageHeader[index] = value
    def get_PageFooter(self): return self.PageFooter
    def set_PageFooter(self, PageFooter): self.PageFooter = PageFooter
    def add_PageFooter(self, value): self.PageFooter.append(value)
    def insert_PageFooter(self, index, value): self.PageFooter[index] = value
    def get_PageHeight(self): return self.PageHeight
    def set_PageHeight(self, PageHeight): self.PageHeight = PageHeight
    def add_PageHeight(self, value): self.PageHeight.append(value)
    def insert_PageHeight(self, index, value): self.PageHeight[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_PageWidth(self): return self.PageWidth
    def set_PageWidth(self, PageWidth): self.PageWidth = PageWidth
    def add_PageWidth(self, value): self.PageWidth.append(value)
    def insert_PageWidth(self, index, value): self.PageWidth[index] = value
    def get_InteractiveHeight(self): return self.InteractiveHeight
    def set_InteractiveHeight(self, InteractiveHeight): self.InteractiveHeight = InteractiveHeight
    def add_InteractiveHeight(self, value): self.InteractiveHeight.append(value)
    def insert_InteractiveHeight(self, index, value): self.InteractiveHeight[index] = value
    def get_InteractiveWidth(self): return self.InteractiveWidth
    def set_InteractiveWidth(self, InteractiveWidth): self.InteractiveWidth = InteractiveWidth
    def add_InteractiveWidth(self, value): self.InteractiveWidth.append(value)
    def insert_InteractiveWidth(self, index, value): self.InteractiveWidth[index] = value
    def get_LeftMargin(self): return self.LeftMargin
    def set_LeftMargin(self, LeftMargin): self.LeftMargin = LeftMargin
    def add_LeftMargin(self, value): self.LeftMargin.append(value)
    def insert_LeftMargin(self, index, value): self.LeftMargin[index] = value
    def get_RightMargin(self): return self.RightMargin
    def set_RightMargin(self, RightMargin): self.RightMargin = RightMargin
    def add_RightMargin(self, value): self.RightMargin.append(value)
    def insert_RightMargin(self, index, value): self.RightMargin[index] = value
    def get_TopMargin(self): return self.TopMargin
    def set_TopMargin(self, TopMargin): self.TopMargin = TopMargin
    def add_TopMargin(self, value): self.TopMargin.append(value)
    def insert_TopMargin(self, index, value): self.TopMargin[index] = value
    def get_BottomMargin(self): return self.BottomMargin
    def set_BottomMargin(self, BottomMargin): self.BottomMargin = BottomMargin
    def add_BottomMargin(self, value): self.BottomMargin.append(value)
    def insert_BottomMargin(self, index, value): self.BottomMargin[index] = value
    def get_Columns(self): return self.Columns
    def set_Columns(self, Columns): self.Columns = Columns
    def add_Columns(self, value): self.Columns.append(value)
    def insert_Columns(self, index, value): self.Columns[index] = value
    def get_ColumnSpacing(self): return self.ColumnSpacing
    def set_ColumnSpacing(self, ColumnSpacing): self.ColumnSpacing = ColumnSpacing
    def add_ColumnSpacing(self, value): self.ColumnSpacing.append(value)
    def insert_ColumnSpacing(self, index, value): self.ColumnSpacing[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PageType', fromsubclass_=False):
        for PageHeader_ in self.PageHeader:
            PageHeader_.export(outfile, level, namespace_, name_='PageHeader')
        for PageFooter_ in self.PageFooter:
            PageFooter_.export(outfile, level, namespace_, name_='PageFooter')
        for PageHeight_ in self.PageHeight:
            showIndent(outfile, level)
            outfile.write('<%sPageHeight>%s</%sPageHeight>\n' % (namespace_, self.gds_format_string(quote_xml(PageHeight_).encode(ExternalEncoding), input_name='PageHeight'), namespace_))
        for PageWidth_ in self.PageWidth:
            showIndent(outfile, level)
            outfile.write('<%sPageWidth>%s</%sPageWidth>\n' % (namespace_, self.gds_format_string(quote_xml(PageWidth_).encode(ExternalEncoding), input_name='PageWidth'), namespace_))
        for InteractiveHeight_ in self.InteractiveHeight:
            showIndent(outfile, level)
            outfile.write('<%sInteractiveHeight>%s</%sInteractiveHeight>\n' % (namespace_, self.gds_format_string(quote_xml(InteractiveHeight_).encode(ExternalEncoding), input_name='InteractiveHeight'), namespace_))
        for InteractiveWidth_ in self.InteractiveWidth:
            showIndent(outfile, level)
            outfile.write('<%sInteractiveWidth>%s</%sInteractiveWidth>\n' % (namespace_, self.gds_format_string(quote_xml(InteractiveWidth_).encode(ExternalEncoding), input_name='InteractiveWidth'), namespace_))
        for LeftMargin_ in self.LeftMargin:
            showIndent(outfile, level)
            outfile.write('<%sLeftMargin>%s</%sLeftMargin>\n' % (namespace_, self.gds_format_string(quote_xml(LeftMargin_).encode(ExternalEncoding), input_name='LeftMargin'), namespace_))
        for RightMargin_ in self.RightMargin:
            showIndent(outfile, level)
            outfile.write('<%sRightMargin>%s</%sRightMargin>\n' % (namespace_, self.gds_format_string(quote_xml(RightMargin_).encode(ExternalEncoding), input_name='RightMargin'), namespace_))
        for TopMargin_ in self.TopMargin:
            showIndent(outfile, level)
            outfile.write('<%sTopMargin>%s</%sTopMargin>\n' % (namespace_, self.gds_format_string(quote_xml(TopMargin_).encode(ExternalEncoding), input_name='TopMargin'), namespace_))
        for BottomMargin_ in self.BottomMargin:
            showIndent(outfile, level)
            outfile.write('<%sBottomMargin>%s</%sBottomMargin>\n' % (namespace_, self.gds_format_string(quote_xml(BottomMargin_).encode(ExternalEncoding), input_name='BottomMargin'), namespace_))
        for Columns_ in self.Columns:
            showIndent(outfile, level)
            outfile.write('<%sColumns>%s</%sColumns>\n' % (namespace_, self.gds_format_integer(Columns_, input_name='Columns'), namespace_))
        for ColumnSpacing_ in self.ColumnSpacing:
            showIndent(outfile, level)
            outfile.write('<%sColumnSpacing>%s</%sColumnSpacing>\n' % (namespace_, self.gds_format_string(quote_xml(ColumnSpacing_).encode(ExternalEncoding), input_name='ColumnSpacing'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.PageHeader or
            self.PageFooter or
            self.PageHeight or
            self.PageWidth or
            self.InteractiveHeight or
            self.InteractiveWidth or
            self.LeftMargin or
            self.RightMargin or
            self.TopMargin or
            self.BottomMargin or
            self.Columns or
            self.ColumnSpacing or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PageHeader=[\n')
        level += 1
        for PageHeader_ in self.PageHeader:
            showIndent(outfile, level)
            outfile.write('model_.PageSectionType(\n')
            PageHeader_.exportLiteral(outfile, level, name_='PageSectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageFooter=[\n')
        level += 1
        for PageFooter_ in self.PageFooter:
            showIndent(outfile, level)
            outfile.write('model_.PageSectionType(\n')
            PageFooter_.exportLiteral(outfile, level, name_='PageSectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageHeight=[\n')
        level += 1
        for PageHeight_ in self.PageHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PageHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageWidth=[\n')
        level += 1
        for PageWidth_ in self.PageWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PageWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InteractiveHeight=[\n')
        level += 1
        for InteractiveHeight_ in self.InteractiveHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InteractiveHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InteractiveWidth=[\n')
        level += 1
        for InteractiveWidth_ in self.InteractiveWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InteractiveWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LeftMargin=[\n')
        level += 1
        for LeftMargin_ in self.LeftMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LeftMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RightMargin=[\n')
        level += 1
        for RightMargin_ in self.RightMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RightMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TopMargin=[\n')
        level += 1
        for TopMargin_ in self.TopMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TopMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BottomMargin=[\n')
        level += 1
        for BottomMargin_ in self.BottomMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BottomMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Columns=[\n')
        level += 1
        for Columns_ in self.Columns:
            showIndent(outfile, level)
            outfile.write('%d,\n' % Columns)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ColumnSpacing=[\n')
        level += 1
        for ColumnSpacing_ in self.ColumnSpacing:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ColumnSpacing_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PageHeader':
            obj_ = PageSectionType.factory()
            obj_.build(child_)
            self.PageHeader.append(obj_)
        elif nodeName_ == 'PageFooter':
            obj_ = PageSectionType.factory()
            obj_.build(child_)
            self.PageFooter.append(obj_)
        elif nodeName_ == 'PageHeight':
            PageHeight_ = child_.text
            PageHeight_ = self.gds_validate_string(PageHeight_, node, 'PageHeight')
            self.PageHeight.append(PageHeight_)
            self.validate_SizeType(self.PageHeight)    # validate type SizeType
        elif nodeName_ == 'PageWidth':
            PageWidth_ = child_.text
            PageWidth_ = self.gds_validate_string(PageWidth_, node, 'PageWidth')
            self.PageWidth.append(PageWidth_)
            self.validate_SizeType(self.PageWidth)    # validate type SizeType
        elif nodeName_ == 'InteractiveHeight':
            InteractiveHeight_ = child_.text
            InteractiveHeight_ = self.gds_validate_string(InteractiveHeight_, node, 'InteractiveHeight')
            self.InteractiveHeight.append(InteractiveHeight_)
            self.validate_SizeType(self.InteractiveHeight)    # validate type SizeType
        elif nodeName_ == 'InteractiveWidth':
            InteractiveWidth_ = child_.text
            InteractiveWidth_ = self.gds_validate_string(InteractiveWidth_, node, 'InteractiveWidth')
            self.InteractiveWidth.append(InteractiveWidth_)
            self.validate_SizeType(self.InteractiveWidth)    # validate type SizeType
        elif nodeName_ == 'LeftMargin':
            LeftMargin_ = child_.text
            LeftMargin_ = self.gds_validate_string(LeftMargin_, node, 'LeftMargin')
            self.LeftMargin.append(LeftMargin_)
            self.validate_SizeType(self.LeftMargin)    # validate type SizeType
        elif nodeName_ == 'RightMargin':
            RightMargin_ = child_.text
            RightMargin_ = self.gds_validate_string(RightMargin_, node, 'RightMargin')
            self.RightMargin.append(RightMargin_)
            self.validate_SizeType(self.RightMargin)    # validate type SizeType
        elif nodeName_ == 'TopMargin':
            TopMargin_ = child_.text
            TopMargin_ = self.gds_validate_string(TopMargin_, node, 'TopMargin')
            self.TopMargin.append(TopMargin_)
            self.validate_SizeType(self.TopMargin)    # validate type SizeType
        elif nodeName_ == 'BottomMargin':
            BottomMargin_ = child_.text
            BottomMargin_ = self.gds_validate_string(BottomMargin_, node, 'BottomMargin')
            self.BottomMargin.append(BottomMargin_)
            self.validate_SizeType(self.BottomMargin)    # validate type SizeType
        elif nodeName_ == 'Columns':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Columns')
            self.Columns.append(ival_)
        elif nodeName_ == 'ColumnSpacing':
            ColumnSpacing_ = child_.text
            ColumnSpacing_ = self.gds_validate_string(ColumnSpacing_, node, 'ColumnSpacing')
            self.ColumnSpacing.append(ColumnSpacing_)
            self.validate_SizeType(self.ColumnSpacing)    # validate type SizeType
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class PageType


class PageSectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Height=None, PrintOnFirstPage=None, PrintOnLastPage=None, ReportItems=None, Style=None):
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if PrintOnFirstPage is None:
            self.PrintOnFirstPage = []
        else:
            self.PrintOnFirstPage = PrintOnFirstPage
        if PrintOnLastPage is None:
            self.PrintOnLastPage = []
        else:
            self.PrintOnLastPage = PrintOnLastPage
        if ReportItems is None:
            self.ReportItems = []
        else:
            self.ReportItems = ReportItems
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PageSectionType.subclass:
            return PageSectionType.subclass(*args_, **kwargs_)
        else:
            return PageSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_PrintOnFirstPage(self): return self.PrintOnFirstPage
    def set_PrintOnFirstPage(self, PrintOnFirstPage): self.PrintOnFirstPage = PrintOnFirstPage
    def add_PrintOnFirstPage(self, value): self.PrintOnFirstPage.append(value)
    def insert_PrintOnFirstPage(self, index, value): self.PrintOnFirstPage[index] = value
    def get_PrintOnLastPage(self): return self.PrintOnLastPage
    def set_PrintOnLastPage(self, PrintOnLastPage): self.PrintOnLastPage = PrintOnLastPage
    def add_PrintOnLastPage(self, value): self.PrintOnLastPage.append(value)
    def insert_PrintOnLastPage(self, index, value): self.PrintOnLastPage[index] = value
    def get_ReportItems(self): return self.ReportItems
    def set_ReportItems(self, ReportItems): self.ReportItems = ReportItems
    def add_ReportItems(self, value): self.ReportItems.append(value)
    def insert_ReportItems(self, index, value): self.ReportItems[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PageSectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageSectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageSectionType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PageSectionType', fromsubclass_=False):
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for PrintOnFirstPage_ in self.PrintOnFirstPage:
            showIndent(outfile, level)
            outfile.write('<%sPrintOnFirstPage>%s</%sPrintOnFirstPage>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(PrintOnFirstPage_)), input_name='PrintOnFirstPage'), namespace_))
        for PrintOnLastPage_ in self.PrintOnLastPage:
            showIndent(outfile, level)
            outfile.write('<%sPrintOnLastPage>%s</%sPrintOnLastPage>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(PrintOnLastPage_)), input_name='PrintOnLastPage'), namespace_))
        for ReportItems_ in self.ReportItems:
            ReportItems_.export(outfile, level, namespace_, name_='ReportItems')
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.Height or
            self.PrintOnFirstPage or
            self.PrintOnLastPage or
            self.ReportItems or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PageSectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PrintOnFirstPage=[\n')
        level += 1
        for PrintOnFirstPage_ in self.PrintOnFirstPage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % PrintOnFirstPage)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PrintOnLastPage=[\n')
        level += 1
        for PrintOnLastPage_ in self.PrintOnLastPage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % PrintOnLastPage)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportItems=[\n')
        level += 1
        for ReportItems_ in self.ReportItems:
            showIndent(outfile, level)
            outfile.write('model_.ReportItemsType(\n')
            ReportItems_.exportLiteral(outfile, level, name_='ReportItemsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'PrintOnFirstPage':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PrintOnFirstPage')
            self.PrintOnFirstPage.append(ival_)
        elif nodeName_ == 'PrintOnLastPage':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PrintOnLastPage')
            self.PrintOnLastPage.append(ival_)
        elif nodeName_ == 'ReportItems':
            obj_ = ReportItemsType.factory()
            obj_.build(child_)
            self.ReportItems.append(obj_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class PageSectionType


class EmbeddedImagesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EmbeddedImage=None):
        if EmbeddedImage is None:
            self.EmbeddedImage = []
        else:
            self.EmbeddedImage = EmbeddedImage
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EmbeddedImagesType.subclass:
            return EmbeddedImagesType.subclass(*args_, **kwargs_)
        else:
            return EmbeddedImagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EmbeddedImage(self): return self.EmbeddedImage
    def set_EmbeddedImage(self, EmbeddedImage): self.EmbeddedImage = EmbeddedImage
    def add_EmbeddedImage(self, value): self.EmbeddedImage.append(value)
    def insert_EmbeddedImage(self, index, value): self.EmbeddedImage[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='EmbeddedImagesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmbeddedImagesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmbeddedImagesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EmbeddedImagesType', fromsubclass_=False):
        for EmbeddedImage_ in self.EmbeddedImage:
            EmbeddedImage_.export(outfile, level, namespace_, name_='EmbeddedImage')
    def hasContent_(self):
        if (
            self.EmbeddedImage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EmbeddedImagesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EmbeddedImage=[\n')
        level += 1
        for EmbeddedImage_ in self.EmbeddedImage:
            showIndent(outfile, level)
            outfile.write('model_.EmbeddedImageType(\n')
            EmbeddedImage_.exportLiteral(outfile, level, name_='EmbeddedImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EmbeddedImage':
            obj_ = EmbeddedImageType.factory()
            obj_.build(child_)
            self.EmbeddedImage.append(obj_)
# end class EmbeddedImagesType


class EmbeddedImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, MIMEType=None, ImageData=None):
        self.Name = _cast(None, Name)
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if ImageData is None:
            self.ImageData = []
        else:
            self.ImageData = ImageData
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EmbeddedImageType.subclass:
            return EmbeddedImageType.subclass(*args_, **kwargs_)
        else:
            return EmbeddedImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_ImageData(self): return self.ImageData
    def set_ImageData(self, ImageData): self.ImageData = ImageData
    def add_ImageData(self, value): self.ImageData.append(value)
    def insert_ImageData(self, index, value): self.ImageData[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='EmbeddedImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmbeddedImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EmbeddedImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EmbeddedImageType', fromsubclass_=False):
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for ImageData_ in self.ImageData:
            showIndent(outfile, level)
            outfile.write('<%sImageData>%s</%sImageData>\n' % (namespace_, self.gds_format_string(quote_xml(ImageData_).encode(ExternalEncoding), input_name='ImageData'), namespace_))
    def hasContent_(self):
        if (
            self.MIMEType or
            self.ImageData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EmbeddedImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ImageData=[\n')
        level += 1
        for ImageData_ in self.ImageData:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ImageData_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'ImageData':
            ImageData_ = child_.text
            ImageData_ = self.gds_validate_string(ImageData_, node, 'ImageData')
            self.ImageData.append(ImageData_)
# end class EmbeddedImageType


class ReportItemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Line=None, Rectangle=None, Textbox=None, Image=None, Subreport=None, Chart=None, GaugePanel=None, Tablix=None, CustomReportItem=None):
        if Line is None:
            self.Line = []
        else:
            self.Line = Line
        if Rectangle is None:
            self.Rectangle = []
        else:
            self.Rectangle = Rectangle
        if Textbox is None:
            self.Textbox = []
        else:
            self.Textbox = Textbox
        if Image is None:
            self.Image = []
        else:
            self.Image = Image
        if Subreport is None:
            self.Subreport = []
        else:
            self.Subreport = Subreport
        if Chart is None:
            self.Chart = []
        else:
            self.Chart = Chart
        if GaugePanel is None:
            self.GaugePanel = []
        else:
            self.GaugePanel = GaugePanel
        if Tablix is None:
            self.Tablix = []
        else:
            self.Tablix = Tablix
        if CustomReportItem is None:
            self.CustomReportItem = []
        else:
            self.CustomReportItem = CustomReportItem
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ReportItemsType.subclass:
            return ReportItemsType.subclass(*args_, **kwargs_)
        else:
            return ReportItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Line(self): return self.Line
    def set_Line(self, Line): self.Line = Line
    def add_Line(self, value): self.Line.append(value)
    def insert_Line(self, index, value): self.Line[index] = value
    def get_Rectangle(self): return self.Rectangle
    def set_Rectangle(self, Rectangle): self.Rectangle = Rectangle
    def add_Rectangle(self, value): self.Rectangle.append(value)
    def insert_Rectangle(self, index, value): self.Rectangle[index] = value
    def get_Textbox(self): return self.Textbox
    def set_Textbox(self, Textbox): self.Textbox = Textbox
    def add_Textbox(self, value): self.Textbox.append(value)
    def insert_Textbox(self, index, value): self.Textbox[index] = value
    def get_Image(self): return self.Image
    def set_Image(self, Image): self.Image = Image
    def add_Image(self, value): self.Image.append(value)
    def insert_Image(self, index, value): self.Image[index] = value
    def get_Subreport(self): return self.Subreport
    def set_Subreport(self, Subreport): self.Subreport = Subreport
    def add_Subreport(self, value): self.Subreport.append(value)
    def insert_Subreport(self, index, value): self.Subreport[index] = value
    def get_Chart(self): return self.Chart
    def set_Chart(self, Chart): self.Chart = Chart
    def add_Chart(self, value): self.Chart.append(value)
    def insert_Chart(self, index, value): self.Chart[index] = value
    def get_GaugePanel(self): return self.GaugePanel
    def set_GaugePanel(self, GaugePanel): self.GaugePanel = GaugePanel
    def add_GaugePanel(self, value): self.GaugePanel.append(value)
    def insert_GaugePanel(self, index, value): self.GaugePanel[index] = value
    def get_Tablix(self): return self.Tablix
    def set_Tablix(self, Tablix): self.Tablix = Tablix
    def add_Tablix(self, value): self.Tablix.append(value)
    def insert_Tablix(self, index, value): self.Tablix[index] = value
    def get_CustomReportItem(self): return self.CustomReportItem
    def set_CustomReportItem(self, CustomReportItem): self.CustomReportItem = CustomReportItem
    def add_CustomReportItem(self, value): self.CustomReportItem.append(value)
    def insert_CustomReportItem(self, index, value): self.CustomReportItem[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ReportItemsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportItemsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportItemsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReportItemsType', fromsubclass_=False):
        for Line_ in self.Line:
            Line_.export(outfile, level, namespace_, name_='Line')
        for Rectangle_ in self.Rectangle:
            Rectangle_.export(outfile, level, namespace_, name_='Rectangle')
        for Textbox_ in self.Textbox:
            Textbox_.export(outfile, level, namespace_, name_='Textbox')
        for Image_ in self.Image:
            Image_.export(outfile, level, namespace_, name_='Image')
        for Subreport_ in self.Subreport:
            Subreport_.export(outfile, level, namespace_, name_='Subreport')
        for Chart_ in self.Chart:
            Chart_.export(outfile, level, namespace_, name_='Chart')
        for GaugePanel_ in self.GaugePanel:
            GaugePanel_.export(outfile, level, namespace_, name_='GaugePanel')
        for Tablix_ in self.Tablix:
            Tablix_.export(outfile, level, namespace_, name_='Tablix')
        for CustomReportItem_ in self.CustomReportItem:
            CustomReportItem_.export(outfile, level, namespace_, name_='CustomReportItem')
    def hasContent_(self):
        if (
            self.Line or
            self.Rectangle or
            self.Textbox or
            self.Image or
            self.Subreport or
            self.Chart or
            self.GaugePanel or
            self.Tablix or
            self.CustomReportItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReportItemsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Line=[\n')
        level += 1
        for Line_ in self.Line:
            showIndent(outfile, level)
            outfile.write('model_.LineType(\n')
            Line_.exportLiteral(outfile, level, name_='LineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Rectangle=[\n')
        level += 1
        for Rectangle_ in self.Rectangle:
            showIndent(outfile, level)
            outfile.write('model_.RectangleType(\n')
            Rectangle_.exportLiteral(outfile, level, name_='RectangleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Textbox=[\n')
        level += 1
        for Textbox_ in self.Textbox:
            showIndent(outfile, level)
            outfile.write('model_.TextboxType(\n')
            Textbox_.exportLiteral(outfile, level, name_='TextboxType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Image=[\n')
        level += 1
        for Image_ in self.Image:
            showIndent(outfile, level)
            outfile.write('model_.ImageType(\n')
            Image_.exportLiteral(outfile, level, name_='ImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Subreport=[\n')
        level += 1
        for Subreport_ in self.Subreport:
            showIndent(outfile, level)
            outfile.write('model_.SubreportType(\n')
            Subreport_.exportLiteral(outfile, level, name_='SubreportType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Chart=[\n')
        level += 1
        for Chart_ in self.Chart:
            showIndent(outfile, level)
            outfile.write('model_.ChartType(\n')
            Chart_.exportLiteral(outfile, level, name_='ChartType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugePanel=[\n')
        level += 1
        for GaugePanel_ in self.GaugePanel:
            showIndent(outfile, level)
            outfile.write('model_.GaugePanelType(\n')
            GaugePanel_.exportLiteral(outfile, level, name_='GaugePanelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Tablix=[\n')
        level += 1
        for Tablix_ in self.Tablix:
            showIndent(outfile, level)
            outfile.write('model_.TablixType(\n')
            Tablix_.exportLiteral(outfile, level, name_='TablixType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomReportItem=[\n')
        level += 1
        for CustomReportItem_ in self.CustomReportItem:
            showIndent(outfile, level)
            outfile.write('model_.CustomReportItemType(\n')
            CustomReportItem_.exportLiteral(outfile, level, name_='CustomReportItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Line':
            obj_ = LineType.factory()
            obj_.build(child_)
            self.Line.append(obj_)
        elif nodeName_ == 'Rectangle':
            obj_ = RectangleType.factory()
            obj_.build(child_)
            self.Rectangle.append(obj_)
        elif nodeName_ == 'Textbox':
            obj_ = TextboxType.factory()
            obj_.build(child_)
            self.Textbox.append(obj_)
        elif nodeName_ == 'Image':
            obj_ = ImageType.factory()
            obj_.build(child_)
            self.Image.append(obj_)
        elif nodeName_ == 'Subreport':
            obj_ = SubreportType.factory()
            obj_.build(child_)
            self.Subreport.append(obj_)
        elif nodeName_ == 'Chart':
            obj_ = ChartType.factory()
            obj_.build(child_)
            self.Chart.append(obj_)
        elif nodeName_ == 'GaugePanel':
            obj_ = GaugePanelType.factory()
            obj_.build(child_)
            self.GaugePanel.append(obj_)
        elif nodeName_ == 'Tablix':
            obj_ = TablixType.factory()
            obj_.build(child_)
            self.Tablix.append(obj_)
        elif nodeName_ == 'CustomReportItem':
            obj_ = CustomReportItemType.factory()
            obj_.build(child_)
            self.CustomReportItem.append(obj_)
# end class ReportItemsType


class ActionInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Actions=None):
        if Actions is None:
            self.Actions = []
        else:
            self.Actions = Actions
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ActionInfoType.subclass:
            return ActionInfoType.subclass(*args_, **kwargs_)
        else:
            return ActionInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Actions(self): return self.Actions
    def set_Actions(self, Actions): self.Actions = Actions
    def add_Actions(self, value): self.Actions.append(value)
    def insert_Actions(self, index, value): self.Actions[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ActionInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionInfoType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionInfoType', fromsubclass_=False):
        for Actions_ in self.Actions:
            Actions_.export(outfile, level, namespace_, name_='Actions')
    def hasContent_(self):
        if (
            self.Actions
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Actions=[\n')
        level += 1
        for Actions_ in self.Actions:
            showIndent(outfile, level)
            outfile.write('model_.ActionsType(\n')
            Actions_.exportLiteral(outfile, level, name_='ActionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Actions':
            obj_ = ActionsType.factory()
            obj_.build(child_)
            self.Actions.append(obj_)
# end class ActionInfoType


class ActionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Action=None):
        if Action is None:
            self.Action = []
        else:
            self.Action = Action
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ActionsType.subclass:
            return ActionsType.subclass(*args_, **kwargs_)
        else:
            return ActionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def add_Action(self, value): self.Action.append(value)
    def insert_Action(self, index, value): self.Action[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ActionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionsType', fromsubclass_=False):
        for Action_ in self.Action:
            Action_.export(outfile, level, namespace_, name_='Action')
    def hasContent_(self):
        if (
            self.Action
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Action=[\n')
        level += 1
        for Action_ in self.Action:
            showIndent(outfile, level)
            outfile.write('model_.ActionType(\n')
            Action_.exportLiteral(outfile, level, name_='ActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            obj_ = ActionType.factory()
            obj_.build(child_)
            self.Action.append(obj_)
# end class ActionsType


class ActionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Hyperlink=None, Drillthrough=None, BookmarkLink=None):
        if Hyperlink is None:
            self.Hyperlink = []
        else:
            self.Hyperlink = Hyperlink
        if Drillthrough is None:
            self.Drillthrough = []
        else:
            self.Drillthrough = Drillthrough
        if BookmarkLink is None:
            self.BookmarkLink = []
        else:
            self.BookmarkLink = BookmarkLink
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ActionType.subclass:
            return ActionType.subclass(*args_, **kwargs_)
        else:
            return ActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hyperlink(self): return self.Hyperlink
    def set_Hyperlink(self, Hyperlink): self.Hyperlink = Hyperlink
    def add_Hyperlink(self, value): self.Hyperlink.append(value)
    def insert_Hyperlink(self, index, value): self.Hyperlink[index] = value
    def get_Drillthrough(self): return self.Drillthrough
    def set_Drillthrough(self, Drillthrough): self.Drillthrough = Drillthrough
    def add_Drillthrough(self, value): self.Drillthrough.append(value)
    def insert_Drillthrough(self, index, value): self.Drillthrough[index] = value
    def get_BookmarkLink(self): return self.BookmarkLink
    def set_BookmarkLink(self, BookmarkLink): self.BookmarkLink = BookmarkLink
    def add_BookmarkLink(self, value): self.BookmarkLink.append(value)
    def insert_BookmarkLink(self, index, value): self.BookmarkLink[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ActionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActionType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActionType', fromsubclass_=False):
        for Hyperlink_ in self.Hyperlink:
            showIndent(outfile, level)
            outfile.write('<%sHyperlink>%s</%sHyperlink>\n' % (namespace_, self.gds_format_string(quote_xml(Hyperlink_).encode(ExternalEncoding), input_name='Hyperlink'), namespace_))
        for Drillthrough_ in self.Drillthrough:
            Drillthrough_.export(outfile, level, namespace_, name_='Drillthrough')
        for BookmarkLink_ in self.BookmarkLink:
            showIndent(outfile, level)
            outfile.write('<%sBookmarkLink>%s</%sBookmarkLink>\n' % (namespace_, self.gds_format_string(quote_xml(BookmarkLink_).encode(ExternalEncoding), input_name='BookmarkLink'), namespace_))
    def hasContent_(self):
        if (
            self.Hyperlink or
            self.Drillthrough or
            self.BookmarkLink
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hyperlink=[\n')
        level += 1
        for Hyperlink_ in self.Hyperlink:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hyperlink_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Drillthrough=[\n')
        level += 1
        for Drillthrough_ in self.Drillthrough:
            showIndent(outfile, level)
            outfile.write('model_.DrillthroughType(\n')
            Drillthrough_.exportLiteral(outfile, level, name_='DrillthroughType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BookmarkLink=[\n')
        level += 1
        for BookmarkLink_ in self.BookmarkLink:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BookmarkLink_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hyperlink':
            Hyperlink_ = child_.text
            Hyperlink_ = self.gds_validate_string(Hyperlink_, node, 'Hyperlink')
            self.Hyperlink.append(Hyperlink_)
        elif nodeName_ == 'Drillthrough':
            obj_ = DrillthroughType.factory()
            obj_.build(child_)
            self.Drillthrough.append(obj_)
        elif nodeName_ == 'BookmarkLink':
            BookmarkLink_ = child_.text
            BookmarkLink_ = self.gds_validate_string(BookmarkLink_, node, 'BookmarkLink')
            self.BookmarkLink.append(BookmarkLink_)
# end class ActionType


class DrillthroughType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReportName=None, Parameters=None):
        if ReportName is None:
            self.ReportName = []
        else:
            self.ReportName = ReportName
        if Parameters is None:
            self.Parameters = []
        else:
            self.Parameters = Parameters
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DrillthroughType.subclass:
            return DrillthroughType.subclass(*args_, **kwargs_)
        else:
            return DrillthroughType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReportName(self): return self.ReportName
    def set_ReportName(self, ReportName): self.ReportName = ReportName
    def add_ReportName(self, value): self.ReportName.append(value)
    def insert_ReportName(self, index, value): self.ReportName[index] = value
    def get_Parameters(self): return self.Parameters
    def set_Parameters(self, Parameters): self.Parameters = Parameters
    def add_Parameters(self, value): self.Parameters.append(value)
    def insert_Parameters(self, index, value): self.Parameters[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DrillthroughType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DrillthroughType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DrillthroughType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DrillthroughType', fromsubclass_=False):
        for ReportName_ in self.ReportName:
            showIndent(outfile, level)
            outfile.write('<%sReportName>%s</%sReportName>\n' % (namespace_, self.gds_format_string(quote_xml(ReportName_).encode(ExternalEncoding), input_name='ReportName'), namespace_))
        for Parameters_ in self.Parameters:
            Parameters_.export(outfile, level, namespace_, name_='Parameters')
    def hasContent_(self):
        if (
            self.ReportName or
            self.Parameters
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DrillthroughType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ReportName=[\n')
        level += 1
        for ReportName_ in self.ReportName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ReportName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Parameters=[\n')
        level += 1
        for Parameters_ in self.Parameters:
            showIndent(outfile, level)
            outfile.write('model_.ParametersType(\n')
            Parameters_.exportLiteral(outfile, level, name_='ParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReportName':
            ReportName_ = child_.text
            ReportName_ = self.gds_validate_string(ReportName_, node, 'ReportName')
            self.ReportName.append(ReportName_)
        elif nodeName_ == 'Parameters':
            obj_ = ParametersType.factory()
            obj_.build(child_)
            self.Parameters.append(obj_)
# end class DrillthroughType


class VisibilityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Hidden=None, ToggleItem=None):
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ToggleItem is None:
            self.ToggleItem = []
        else:
            self.ToggleItem = ToggleItem
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VisibilityType.subclass:
            return VisibilityType.subclass(*args_, **kwargs_)
        else:
            return VisibilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ToggleItem(self): return self.ToggleItem
    def set_ToggleItem(self, ToggleItem): self.ToggleItem = ToggleItem
    def add_ToggleItem(self, value): self.ToggleItem.append(value)
    def insert_ToggleItem(self, index, value): self.ToggleItem[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VisibilityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VisibilityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VisibilityType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VisibilityType', fromsubclass_=False):
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ToggleItem_ in self.ToggleItem:
            showIndent(outfile, level)
            outfile.write('<%sToggleItem>%s</%sToggleItem>\n' % (namespace_, self.gds_format_string(quote_xml(ToggleItem_).encode(ExternalEncoding), input_name='ToggleItem'), namespace_))
    def hasContent_(self):
        if (
            self.Hidden or
            self.ToggleItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VisibilityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToggleItem=[\n')
        level += 1
        for ToggleItem_ in self.ToggleItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToggleItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ToggleItem':
            ToggleItem_ = child_.text
            ToggleItem_ = self.gds_validate_string(ToggleItem_, node, 'ToggleItem')
            self.ToggleItem.append(ToggleItem_)
# end class VisibilityType


class LineType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, DataElementName=None, DataElementOutput=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LineType.subclass:
            return LineType.subclass(*args_, **kwargs_)
        else:
            return LineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LineType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LineType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class LineType


class DataElementOutput(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DataElementOutput.subclass:
            return DataElementOutput.subclass(*args_, **kwargs_)
        else:
            return DataElementOutput(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DataElementOutput', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataElementOutput')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataElementOutput'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataElementOutput', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataElementOutput'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataElementOutput


class RectangleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, LinkToChild=None, Bookmark=None, RepeatWith=None, CustomProperties=None, ReportItems=None, PageBreak=None, KeepTogether=None, OmitBorderOnPageBreak=None, DataElementName=None, DataElementOutput=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if LinkToChild is None:
            self.LinkToChild = []
        else:
            self.LinkToChild = LinkToChild
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if ReportItems is None:
            self.ReportItems = []
        else:
            self.ReportItems = ReportItems
        if PageBreak is None:
            self.PageBreak = []
        else:
            self.PageBreak = PageBreak
        if KeepTogether is None:
            self.KeepTogether = []
        else:
            self.KeepTogether = KeepTogether
        if OmitBorderOnPageBreak is None:
            self.OmitBorderOnPageBreak = []
        else:
            self.OmitBorderOnPageBreak = OmitBorderOnPageBreak
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RectangleType.subclass:
            return RectangleType.subclass(*args_, **kwargs_)
        else:
            return RectangleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_LinkToChild(self): return self.LinkToChild
    def set_LinkToChild(self, LinkToChild): self.LinkToChild = LinkToChild
    def add_LinkToChild(self, value): self.LinkToChild.append(value)
    def insert_LinkToChild(self, index, value): self.LinkToChild[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_ReportItems(self): return self.ReportItems
    def set_ReportItems(self, ReportItems): self.ReportItems = ReportItems
    def add_ReportItems(self, value): self.ReportItems.append(value)
    def insert_ReportItems(self, index, value): self.ReportItems[index] = value
    def get_PageBreak(self): return self.PageBreak
    def set_PageBreak(self, PageBreak): self.PageBreak = PageBreak
    def add_PageBreak(self, value): self.PageBreak.append(value)
    def insert_PageBreak(self, index, value): self.PageBreak[index] = value
    def get_KeepTogether(self): return self.KeepTogether
    def set_KeepTogether(self, KeepTogether): self.KeepTogether = KeepTogether
    def add_KeepTogether(self, value): self.KeepTogether.append(value)
    def insert_KeepTogether(self, index, value): self.KeepTogether[index] = value
    def get_OmitBorderOnPageBreak(self): return self.OmitBorderOnPageBreak
    def set_OmitBorderOnPageBreak(self, OmitBorderOnPageBreak): self.OmitBorderOnPageBreak = OmitBorderOnPageBreak
    def add_OmitBorderOnPageBreak(self, value): self.OmitBorderOnPageBreak.append(value)
    def insert_OmitBorderOnPageBreak(self, index, value): self.OmitBorderOnPageBreak[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RectangleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RectangleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RectangleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RectangleType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for LinkToChild_ in self.LinkToChild:
            showIndent(outfile, level)
            outfile.write('<%sLinkToChild>%s</%sLinkToChild>\n' % (namespace_, self.gds_format_string(quote_xml(LinkToChild_).encode(ExternalEncoding), input_name='LinkToChild'), namespace_))
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for ReportItems_ in self.ReportItems:
            ReportItems_.export(outfile, level, namespace_, name_='ReportItems')
        for PageBreak_ in self.PageBreak:
            PageBreak_.export(outfile, level, namespace_, name_='PageBreak')
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('<%sKeepTogether>%s</%sKeepTogether>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(KeepTogether_)), input_name='KeepTogether'), namespace_))
        for OmitBorderOnPageBreak_ in self.OmitBorderOnPageBreak:
            showIndent(outfile, level)
            outfile.write('<%sOmitBorderOnPageBreak>%s</%sOmitBorderOnPageBreak>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(OmitBorderOnPageBreak_)), input_name='OmitBorderOnPageBreak'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.LinkToChild or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.ReportItems or
            self.PageBreak or
            self.KeepTogether or
            self.OmitBorderOnPageBreak or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RectangleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LinkToChild=[\n')
        level += 1
        for LinkToChild_ in self.LinkToChild:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LinkToChild_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportItems=[\n')
        level += 1
        for ReportItems_ in self.ReportItems:
            showIndent(outfile, level)
            outfile.write('model_.ReportItemsType(\n')
            ReportItems_.exportLiteral(outfile, level, name_='ReportItemsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageBreak=[\n')
        level += 1
        for PageBreak_ in self.PageBreak:
            showIndent(outfile, level)
            outfile.write('model_.PageBreakType(\n')
            PageBreak_.exportLiteral(outfile, level, name_='PageBreakType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeepTogether=[\n')
        level += 1
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('%s,\n' % KeepTogether)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OmitBorderOnPageBreak=[\n')
        level += 1
        for OmitBorderOnPageBreak_ in self.OmitBorderOnPageBreak:
            showIndent(outfile, level)
            outfile.write('%s,\n' % OmitBorderOnPageBreak)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'LinkToChild':
            LinkToChild_ = child_.text
            LinkToChild_ = self.gds_validate_string(LinkToChild_, node, 'LinkToChild')
            self.LinkToChild.append(LinkToChild_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'ReportItems':
            obj_ = ReportItemsType.factory()
            obj_.build(child_)
            self.ReportItems.append(obj_)
        elif nodeName_ == 'PageBreak':
            obj_ = PageBreakType.factory()
            obj_.build(child_)
            self.PageBreak.append(obj_)
        elif nodeName_ == 'KeepTogether':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KeepTogether')
            self.KeepTogether.append(ival_)
        elif nodeName_ == 'OmitBorderOnPageBreak':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'OmitBorderOnPageBreak')
            self.OmitBorderOnPageBreak.append(ival_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class RectangleType


class TextboxType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, Paragraphs=None, CanGrow=None, CanShrink=None, HideDuplicates=None, ToggleImage=None, UserSort=None, KeepTogether=None, DataElementName=None, DataElementOutput=None, DataElementStyle=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if Paragraphs is None:
            self.Paragraphs = []
        else:
            self.Paragraphs = Paragraphs
        if CanGrow is None:
            self.CanGrow = []
        else:
            self.CanGrow = CanGrow
        if CanShrink is None:
            self.CanShrink = []
        else:
            self.CanShrink = CanShrink
        if HideDuplicates is None:
            self.HideDuplicates = []
        else:
            self.HideDuplicates = HideDuplicates
        if ToggleImage is None:
            self.ToggleImage = []
        else:
            self.ToggleImage = ToggleImage
        if UserSort is None:
            self.UserSort = []
        else:
            self.UserSort = UserSort
        if KeepTogether is None:
            self.KeepTogether = []
        else:
            self.KeepTogether = KeepTogether
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        if DataElementStyle is None:
            self.DataElementStyle = []
        else:
            self.DataElementStyle = DataElementStyle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TextboxType.subclass:
            return TextboxType.subclass(*args_, **kwargs_)
        else:
            return TextboxType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_Paragraphs(self): return self.Paragraphs
    def set_Paragraphs(self, Paragraphs): self.Paragraphs = Paragraphs
    def add_Paragraphs(self, value): self.Paragraphs.append(value)
    def insert_Paragraphs(self, index, value): self.Paragraphs[index] = value
    def get_CanGrow(self): return self.CanGrow
    def set_CanGrow(self, CanGrow): self.CanGrow = CanGrow
    def add_CanGrow(self, value): self.CanGrow.append(value)
    def insert_CanGrow(self, index, value): self.CanGrow[index] = value
    def get_CanShrink(self): return self.CanShrink
    def set_CanShrink(self, CanShrink): self.CanShrink = CanShrink
    def add_CanShrink(self, value): self.CanShrink.append(value)
    def insert_CanShrink(self, index, value): self.CanShrink[index] = value
    def get_HideDuplicates(self): return self.HideDuplicates
    def set_HideDuplicates(self, HideDuplicates): self.HideDuplicates = HideDuplicates
    def add_HideDuplicates(self, value): self.HideDuplicates.append(value)
    def insert_HideDuplicates(self, index, value): self.HideDuplicates[index] = value
    def get_ToggleImage(self): return self.ToggleImage
    def set_ToggleImage(self, ToggleImage): self.ToggleImage = ToggleImage
    def add_ToggleImage(self, value): self.ToggleImage.append(value)
    def insert_ToggleImage(self, index, value): self.ToggleImage[index] = value
    def get_UserSort(self): return self.UserSort
    def set_UserSort(self, UserSort): self.UserSort = UserSort
    def add_UserSort(self, value): self.UserSort.append(value)
    def insert_UserSort(self, index, value): self.UserSort[index] = value
    def get_KeepTogether(self): return self.KeepTogether
    def set_KeepTogether(self, KeepTogether): self.KeepTogether = KeepTogether
    def add_KeepTogether(self, value): self.KeepTogether.append(value)
    def insert_KeepTogether(self, index, value): self.KeepTogether[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_DataElementStyle(self): return self.DataElementStyle
    def set_DataElementStyle(self, DataElementStyle): self.DataElementStyle = DataElementStyle
    def add_DataElementStyle(self, value): self.DataElementStyle.append(value)
    def insert_DataElementStyle(self, index, value): self.DataElementStyle[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TextboxType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextboxType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextboxType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TextboxType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for Paragraphs_ in self.Paragraphs:
            Paragraphs_.export(outfile, level, namespace_, name_='Paragraphs')
        for CanGrow_ in self.CanGrow:
            showIndent(outfile, level)
            outfile.write('<%sCanGrow>%s</%sCanGrow>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(CanGrow_)), input_name='CanGrow'), namespace_))
        for CanShrink_ in self.CanShrink:
            showIndent(outfile, level)
            outfile.write('<%sCanShrink>%s</%sCanShrink>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(CanShrink_)), input_name='CanShrink'), namespace_))
        for HideDuplicates_ in self.HideDuplicates:
            showIndent(outfile, level)
            outfile.write('<%sHideDuplicates>%s</%sHideDuplicates>\n' % (namespace_, self.gds_format_string(quote_xml(HideDuplicates_).encode(ExternalEncoding), input_name='HideDuplicates'), namespace_))
        for ToggleImage_ in self.ToggleImage:
            ToggleImage_.export(outfile, level, namespace_, name_='ToggleImage')
        for UserSort_ in self.UserSort:
            UserSort_.export(outfile, level, namespace_, name_='UserSort')
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('<%sKeepTogether>%s</%sKeepTogether>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(KeepTogether_)), input_name='KeepTogether'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
        for DataElementStyle_ in self.DataElementStyle:
            showIndent(outfile, level)
            outfile.write('<%sDataElementStyle>%s</%sDataElementStyle>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementStyle_).encode(ExternalEncoding), input_name='DataElementStyle'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.Paragraphs or
            self.CanGrow or
            self.CanShrink or
            self.HideDuplicates or
            self.ToggleImage or
            self.UserSort or
            self.KeepTogether or
            self.DataElementName or
            self.DataElementOutput or
            self.DataElementStyle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextboxType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Paragraphs=[\n')
        level += 1
        for Paragraphs_ in self.Paragraphs:
            showIndent(outfile, level)
            outfile.write('model_.ParagraphsType(\n')
            Paragraphs_.exportLiteral(outfile, level, name_='ParagraphsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CanGrow=[\n')
        level += 1
        for CanGrow_ in self.CanGrow:
            showIndent(outfile, level)
            outfile.write('%s,\n' % CanGrow)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CanShrink=[\n')
        level += 1
        for CanShrink_ in self.CanShrink:
            showIndent(outfile, level)
            outfile.write('%s,\n' % CanShrink)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HideDuplicates=[\n')
        level += 1
        for HideDuplicates_ in self.HideDuplicates:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HideDuplicates_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToggleImage=[\n')
        level += 1
        for ToggleImage_ in self.ToggleImage:
            showIndent(outfile, level)
            outfile.write('model_.ToggleImageType(\n')
            ToggleImage_.exportLiteral(outfile, level, name_='ToggleImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UserSort=[\n')
        level += 1
        for UserSort_ in self.UserSort:
            showIndent(outfile, level)
            outfile.write('model_.UserSortType(\n')
            UserSort_.exportLiteral(outfile, level, name_='UserSortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeepTogether=[\n')
        level += 1
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('%s,\n' % KeepTogether)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementStyle=[\n')
        level += 1
        for DataElementStyle_ in self.DataElementStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'Paragraphs':
            obj_ = ParagraphsType.factory()
            obj_.build(child_)
            self.Paragraphs.append(obj_)
        elif nodeName_ == 'CanGrow':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CanGrow')
            self.CanGrow.append(ival_)
        elif nodeName_ == 'CanShrink':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CanShrink')
            self.CanShrink.append(ival_)
        elif nodeName_ == 'HideDuplicates':
            HideDuplicates_ = child_.text
            HideDuplicates_ = self.gds_validate_string(HideDuplicates_, node, 'HideDuplicates')
            self.HideDuplicates.append(HideDuplicates_)
        elif nodeName_ == 'ToggleImage':
            obj_ = ToggleImageType.factory()
            obj_.build(child_)
            self.ToggleImage.append(obj_)
        elif nodeName_ == 'UserSort':
            obj_ = UserSortType.factory()
            obj_.build(child_)
            self.UserSort.append(obj_)
        elif nodeName_ == 'KeepTogether':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KeepTogether')
            self.KeepTogether.append(ival_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
        elif nodeName_ == 'DataElementStyle':
            DataElementStyle_ = child_.text
            DataElementStyle_ = self.gds_validate_string(DataElementStyle_, node, 'DataElementStyle')
            self.DataElementStyle.append(DataElementStyle_)
# end class TextboxType


class ParagraphsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Paragraph=None):
        if Paragraph is None:
            self.Paragraph = []
        else:
            self.Paragraph = Paragraph
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ParagraphsType.subclass:
            return ParagraphsType.subclass(*args_, **kwargs_)
        else:
            return ParagraphsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Paragraph(self): return self.Paragraph
    def set_Paragraph(self, Paragraph): self.Paragraph = Paragraph
    def add_Paragraph(self, value): self.Paragraph.append(value)
    def insert_Paragraph(self, index, value): self.Paragraph[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ParagraphsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParagraphsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParagraphsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParagraphsType', fromsubclass_=False):
        for Paragraph_ in self.Paragraph:
            Paragraph_.export(outfile, level, namespace_, name_='Paragraph')
    def hasContent_(self):
        if (
            self.Paragraph
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParagraphsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Paragraph=[\n')
        level += 1
        for Paragraph_ in self.Paragraph:
            showIndent(outfile, level)
            outfile.write('model_.ParagraphType(\n')
            Paragraph_.exportLiteral(outfile, level, name_='ParagraphType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Paragraph':
            obj_ = ParagraphType.factory()
            obj_.build(child_)
            self.Paragraph.append(obj_)
# end class ParagraphsType


class ParagraphType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, TextRuns=None, LeftIndent=None, RightIndent=None, HangingIndent=None, ListStyle=None, ListLevel=None, SpaceBefore=None, SpaceAfter=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if TextRuns is None:
            self.TextRuns = []
        else:
            self.TextRuns = TextRuns
        if LeftIndent is None:
            self.LeftIndent = []
        else:
            self.LeftIndent = LeftIndent
        if RightIndent is None:
            self.RightIndent = []
        else:
            self.RightIndent = RightIndent
        if HangingIndent is None:
            self.HangingIndent = []
        else:
            self.HangingIndent = HangingIndent
        if ListStyle is None:
            self.ListStyle = []
        else:
            self.ListStyle = ListStyle
        if ListLevel is None:
            self.ListLevel = []
        else:
            self.ListLevel = ListLevel
        if SpaceBefore is None:
            self.SpaceBefore = []
        else:
            self.SpaceBefore = SpaceBefore
        if SpaceAfter is None:
            self.SpaceAfter = []
        else:
            self.SpaceAfter = SpaceAfter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ParagraphType.subclass:
            return ParagraphType.subclass(*args_, **kwargs_)
        else:
            return ParagraphType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_TextRuns(self): return self.TextRuns
    def set_TextRuns(self, TextRuns): self.TextRuns = TextRuns
    def add_TextRuns(self, value): self.TextRuns.append(value)
    def insert_TextRuns(self, index, value): self.TextRuns[index] = value
    def get_LeftIndent(self): return self.LeftIndent
    def set_LeftIndent(self, LeftIndent): self.LeftIndent = LeftIndent
    def add_LeftIndent(self, value): self.LeftIndent.append(value)
    def insert_LeftIndent(self, index, value): self.LeftIndent[index] = value
    def get_RightIndent(self): return self.RightIndent
    def set_RightIndent(self, RightIndent): self.RightIndent = RightIndent
    def add_RightIndent(self, value): self.RightIndent.append(value)
    def insert_RightIndent(self, index, value): self.RightIndent[index] = value
    def get_HangingIndent(self): return self.HangingIndent
    def set_HangingIndent(self, HangingIndent): self.HangingIndent = HangingIndent
    def add_HangingIndent(self, value): self.HangingIndent.append(value)
    def insert_HangingIndent(self, index, value): self.HangingIndent[index] = value
    def get_ListStyle(self): return self.ListStyle
    def set_ListStyle(self, ListStyle): self.ListStyle = ListStyle
    def add_ListStyle(self, value): self.ListStyle.append(value)
    def insert_ListStyle(self, index, value): self.ListStyle[index] = value
    def get_ListLevel(self): return self.ListLevel
    def set_ListLevel(self, ListLevel): self.ListLevel = ListLevel
    def add_ListLevel(self, value): self.ListLevel.append(value)
    def insert_ListLevel(self, index, value): self.ListLevel[index] = value
    def get_SpaceBefore(self): return self.SpaceBefore
    def set_SpaceBefore(self, SpaceBefore): self.SpaceBefore = SpaceBefore
    def add_SpaceBefore(self, value): self.SpaceBefore.append(value)
    def insert_SpaceBefore(self, index, value): self.SpaceBefore[index] = value
    def get_SpaceAfter(self): return self.SpaceAfter
    def set_SpaceAfter(self, SpaceAfter): self.SpaceAfter = SpaceAfter
    def add_SpaceAfter(self, value): self.SpaceAfter.append(value)
    def insert_SpaceAfter(self, index, value): self.SpaceAfter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ParagraphType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParagraphType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParagraphType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParagraphType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for TextRuns_ in self.TextRuns:
            TextRuns_.export(outfile, level, namespace_, name_='TextRuns')
        for LeftIndent_ in self.LeftIndent:
            showIndent(outfile, level)
            outfile.write('<%sLeftIndent>%s</%sLeftIndent>\n' % (namespace_, self.gds_format_string(quote_xml(LeftIndent_).encode(ExternalEncoding), input_name='LeftIndent'), namespace_))
        for RightIndent_ in self.RightIndent:
            showIndent(outfile, level)
            outfile.write('<%sRightIndent>%s</%sRightIndent>\n' % (namespace_, self.gds_format_string(quote_xml(RightIndent_).encode(ExternalEncoding), input_name='RightIndent'), namespace_))
        for HangingIndent_ in self.HangingIndent:
            showIndent(outfile, level)
            outfile.write('<%sHangingIndent>%s</%sHangingIndent>\n' % (namespace_, self.gds_format_string(quote_xml(HangingIndent_).encode(ExternalEncoding), input_name='HangingIndent'), namespace_))
        for ListStyle_ in self.ListStyle:
            showIndent(outfile, level)
            outfile.write('<%sListStyle>%s</%sListStyle>\n' % (namespace_, self.gds_format_string(quote_xml(ListStyle_).encode(ExternalEncoding), input_name='ListStyle'), namespace_))
        for ListLevel_ in self.ListLevel:
            showIndent(outfile, level)
            outfile.write('<%sListLevel>%s</%sListLevel>\n' % (namespace_, self.gds_format_integer(ListLevel_, input_name='ListLevel'), namespace_))
        for SpaceBefore_ in self.SpaceBefore:
            showIndent(outfile, level)
            outfile.write('<%sSpaceBefore>%s</%sSpaceBefore>\n' % (namespace_, self.gds_format_string(quote_xml(SpaceBefore_).encode(ExternalEncoding), input_name='SpaceBefore'), namespace_))
        for SpaceAfter_ in self.SpaceAfter:
            showIndent(outfile, level)
            outfile.write('<%sSpaceAfter>%s</%sSpaceAfter>\n' % (namespace_, self.gds_format_string(quote_xml(SpaceAfter_).encode(ExternalEncoding), input_name='SpaceAfter'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.TextRuns or
            self.LeftIndent or
            self.RightIndent or
            self.HangingIndent or
            self.ListStyle or
            self.ListLevel or
            self.SpaceBefore or
            self.SpaceAfter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParagraphType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextRuns=[\n')
        level += 1
        for TextRuns_ in self.TextRuns:
            showIndent(outfile, level)
            outfile.write('model_.TextRunsType(\n')
            TextRuns_.exportLiteral(outfile, level, name_='TextRunsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LeftIndent=[\n')
        level += 1
        for LeftIndent_ in self.LeftIndent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LeftIndent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RightIndent=[\n')
        level += 1
        for RightIndent_ in self.RightIndent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RightIndent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HangingIndent=[\n')
        level += 1
        for HangingIndent_ in self.HangingIndent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HangingIndent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ListStyle=[\n')
        level += 1
        for ListStyle_ in self.ListStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ListStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ListLevel=[\n')
        level += 1
        for ListLevel_ in self.ListLevel:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ListLevel)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SpaceBefore=[\n')
        level += 1
        for SpaceBefore_ in self.SpaceBefore:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SpaceBefore_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SpaceAfter=[\n')
        level += 1
        for SpaceAfter_ in self.SpaceAfter:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SpaceAfter_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'TextRuns':
            obj_ = TextRunsType.factory()
            obj_.build(child_)
            self.TextRuns.append(obj_)
        elif nodeName_ == 'LeftIndent':
            LeftIndent_ = child_.text
            LeftIndent_ = self.gds_validate_string(LeftIndent_, node, 'LeftIndent')
            self.LeftIndent.append(LeftIndent_)
        elif nodeName_ == 'RightIndent':
            RightIndent_ = child_.text
            RightIndent_ = self.gds_validate_string(RightIndent_, node, 'RightIndent')
            self.RightIndent.append(RightIndent_)
        elif nodeName_ == 'HangingIndent':
            HangingIndent_ = child_.text
            HangingIndent_ = self.gds_validate_string(HangingIndent_, node, 'HangingIndent')
            self.HangingIndent.append(HangingIndent_)
        elif nodeName_ == 'ListStyle':
            ListStyle_ = child_.text
            ListStyle_ = self.gds_validate_string(ListStyle_, node, 'ListStyle')
            self.ListStyle.append(ListStyle_)
        elif nodeName_ == 'ListLevel':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ListLevel')
            self.ListLevel.append(ival_)
        elif nodeName_ == 'SpaceBefore':
            SpaceBefore_ = child_.text
            SpaceBefore_ = self.gds_validate_string(SpaceBefore_, node, 'SpaceBefore')
            self.SpaceBefore.append(SpaceBefore_)
        elif nodeName_ == 'SpaceAfter':
            SpaceAfter_ = child_.text
            SpaceAfter_ = self.gds_validate_string(SpaceAfter_, node, 'SpaceAfter')
            self.SpaceAfter.append(SpaceAfter_)
# end class ParagraphType


class ListStyle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ListStyle.subclass:
            return ListStyle.subclass(*args_, **kwargs_)
        else:
            return ListStyle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ListStyle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ListStyle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ListStyle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ListStyle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ListStyle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ListStyle


class TextRunsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TextRun=None):
        if TextRun is None:
            self.TextRun = []
        else:
            self.TextRun = TextRun
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TextRunsType.subclass:
            return TextRunsType.subclass(*args_, **kwargs_)
        else:
            return TextRunsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextRun(self): return self.TextRun
    def set_TextRun(self, TextRun): self.TextRun = TextRun
    def add_TextRun(self, value): self.TextRun.append(value)
    def insert_TextRun(self, index, value): self.TextRun[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TextRunsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextRunsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextRunsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TextRunsType', fromsubclass_=False):
        for TextRun_ in self.TextRun:
            TextRun_.export(outfile, level, namespace_, name_='TextRun')
    def hasContent_(self):
        if (
            self.TextRun
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextRunsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TextRun=[\n')
        level += 1
        for TextRun_ in self.TextRun:
            showIndent(outfile, level)
            outfile.write('model_.TextRunType(\n')
            TextRun_.exportLiteral(outfile, level, name_='TextRunType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextRun':
            obj_ = TextRunType.factory()
            obj_.build(child_)
            self.TextRun.append(obj_)
# end class TextRunsType


class TextRunType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, Value=None, Label=None, ActionInfo=None, ToolTip=None, MarkupType=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Label is None:
            self.Label = []
        else:
            self.Label = Label
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if MarkupType is None:
            self.MarkupType = []
        else:
            self.MarkupType = MarkupType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TextRunType.subclass:
            return TextRunType.subclass(*args_, **kwargs_)
        else:
            return TextRunType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def add_Label(self, value): self.Label.append(value)
    def insert_Label(self, index, value): self.Label[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_MarkupType(self): return self.MarkupType
    def set_MarkupType(self, MarkupType): self.MarkupType = MarkupType
    def add_MarkupType(self, value): self.MarkupType.append(value)
    def insert_MarkupType(self, index, value): self.MarkupType[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TextRunType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextRunType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextRunType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TextRunType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value')
        for Label_ in self.Label:
            showIndent(outfile, level)
            outfile.write('<%sLabel>%s</%sLabel>\n' % (namespace_, self.gds_format_string(quote_xml(Label_).encode(ExternalEncoding), input_name='Label'), namespace_))
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for MarkupType_ in self.MarkupType:
            showIndent(outfile, level)
            outfile.write('<%sMarkupType>%s</%sMarkupType>\n' % (namespace_, self.gds_format_string(quote_xml(MarkupType_).encode(ExternalEncoding), input_name='MarkupType'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.Value or
            self.Label or
            self.ActionInfo or
            self.ToolTip or
            self.MarkupType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TextRunType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.LocIDStringWithDataTypeAttribute(\n')
            Value_.exportLiteral(outfile, level, name_='LocIDStringWithDataTypeAttribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Label=[\n')
        level += 1
        for Label_ in self.Label:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Label_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarkupType=[\n')
        level += 1
        for MarkupType_ in self.MarkupType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarkupType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Value':
            obj_ = LocIDStringWithDataTypeAttribute.factory()
            obj_.build(child_)
            self.Value.append(obj_)
        elif nodeName_ == 'Label':
            Label_ = child_.text
            Label_ = self.gds_validate_string(Label_, node, 'Label')
            self.Label.append(Label_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'MarkupType':
            MarkupType_ = child_.text
            MarkupType_ = self.gds_validate_string(MarkupType_, node, 'MarkupType')
            self.MarkupType.append(MarkupType_)
# end class TextRunType


class ToggleImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InitialState=None):
        if InitialState is None:
            self.InitialState = []
        else:
            self.InitialState = InitialState
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ToggleImageType.subclass:
            return ToggleImageType.subclass(*args_, **kwargs_)
        else:
            return ToggleImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InitialState(self): return self.InitialState
    def set_InitialState(self, InitialState): self.InitialState = InitialState
    def add_InitialState(self, value): self.InitialState.append(value)
    def insert_InitialState(self, index, value): self.InitialState[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ToggleImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToggleImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ToggleImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ToggleImageType', fromsubclass_=False):
        for InitialState_ in self.InitialState:
            showIndent(outfile, level)
            outfile.write('<%sInitialState>%s</%sInitialState>\n' % (namespace_, self.gds_format_string(quote_xml(InitialState_).encode(ExternalEncoding), input_name='InitialState'), namespace_))
    def hasContent_(self):
        if (
            self.InitialState
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ToggleImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InitialState=[\n')
        level += 1
        for InitialState_ in self.InitialState:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InitialState_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InitialState':
            InitialState_ = child_.text
            InitialState_ = self.gds_validate_string(InitialState_, node, 'InitialState')
            self.InitialState.append(InitialState_)
# end class ToggleImageType


class ImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, Source=None, Value=None, MIMEType=None, Sizing=None, DataElementName=None, DataElementOutput=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if Sizing is None:
            self.Sizing = []
        else:
            self.Sizing = Sizing
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ImageType.subclass:
            return ImageType.subclass(*args_, **kwargs_)
        else:
            return ImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_Sizing(self): return self.Sizing
    def set_Sizing(self, Sizing): self.Sizing = Sizing
    def add_Sizing(self, value): self.Sizing.append(value)
    def insert_Sizing(self, index, value): self.Sizing[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ImageType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for Sizing_ in self.Sizing:
            showIndent(outfile, level)
            outfile.write('<%sSizing>%s</%sSizing>\n' % (namespace_, self.gds_format_string(quote_xml(Sizing_).encode(ExternalEncoding), input_name='Sizing'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.Source or
            self.Value or
            self.MIMEType or
            self.Sizing or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Sizing=[\n')
        level += 1
        for Sizing_ in self.Sizing:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Sizing_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'Sizing':
            Sizing_ = child_.text
            Sizing_ = self.gds_validate_string(Sizing_, node, 'Sizing')
            self.Sizing.append(Sizing_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class ImageType


class Source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Source.subclass:
            return Source.subclass(*args_, **kwargs_)
        else:
            return Source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Source', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Source')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Source'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Source', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Source'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Source


class Sizing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Sizing.subclass:
            return Sizing.subclass(*args_, **kwargs_)
        else:
            return Sizing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Sizing', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sizing')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sizing'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Sizing', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Sizing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Sizing


class SubreportType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, ReportName=None, Parameters=None, NoRowsMessage=None, MergeTransactions=None, KeepTogether=None, OmitBorderOnPageBreak=None, DataElementName=None, DataElementOutput=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if ReportName is None:
            self.ReportName = []
        else:
            self.ReportName = ReportName
        if Parameters is None:
            self.Parameters = []
        else:
            self.Parameters = Parameters
        if NoRowsMessage is None:
            self.NoRowsMessage = []
        else:
            self.NoRowsMessage = NoRowsMessage
        if MergeTransactions is None:
            self.MergeTransactions = []
        else:
            self.MergeTransactions = MergeTransactions
        if KeepTogether is None:
            self.KeepTogether = []
        else:
            self.KeepTogether = KeepTogether
        if OmitBorderOnPageBreak is None:
            self.OmitBorderOnPageBreak = []
        else:
            self.OmitBorderOnPageBreak = OmitBorderOnPageBreak
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if SubreportType.subclass:
            return SubreportType.subclass(*args_, **kwargs_)
        else:
            return SubreportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_ReportName(self): return self.ReportName
    def set_ReportName(self, ReportName): self.ReportName = ReportName
    def add_ReportName(self, value): self.ReportName.append(value)
    def insert_ReportName(self, index, value): self.ReportName[index] = value
    def get_Parameters(self): return self.Parameters
    def set_Parameters(self, Parameters): self.Parameters = Parameters
    def add_Parameters(self, value): self.Parameters.append(value)
    def insert_Parameters(self, index, value): self.Parameters[index] = value
    def get_NoRowsMessage(self): return self.NoRowsMessage
    def set_NoRowsMessage(self, NoRowsMessage): self.NoRowsMessage = NoRowsMessage
    def add_NoRowsMessage(self, value): self.NoRowsMessage.append(value)
    def insert_NoRowsMessage(self, index, value): self.NoRowsMessage[index] = value
    def get_MergeTransactions(self): return self.MergeTransactions
    def set_MergeTransactions(self, MergeTransactions): self.MergeTransactions = MergeTransactions
    def add_MergeTransactions(self, value): self.MergeTransactions.append(value)
    def insert_MergeTransactions(self, index, value): self.MergeTransactions[index] = value
    def get_KeepTogether(self): return self.KeepTogether
    def set_KeepTogether(self, KeepTogether): self.KeepTogether = KeepTogether
    def add_KeepTogether(self, value): self.KeepTogether.append(value)
    def insert_KeepTogether(self, index, value): self.KeepTogether[index] = value
    def get_OmitBorderOnPageBreak(self): return self.OmitBorderOnPageBreak
    def set_OmitBorderOnPageBreak(self, OmitBorderOnPageBreak): self.OmitBorderOnPageBreak = OmitBorderOnPageBreak
    def add_OmitBorderOnPageBreak(self, value): self.OmitBorderOnPageBreak.append(value)
    def insert_OmitBorderOnPageBreak(self, index, value): self.OmitBorderOnPageBreak[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='SubreportType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubreportType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubreportType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubreportType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for ReportName_ in self.ReportName:
            showIndent(outfile, level)
            outfile.write('<%sReportName>%s</%sReportName>\n' % (namespace_, self.gds_format_string(quote_xml(ReportName_).encode(ExternalEncoding), input_name='ReportName'), namespace_))
        for Parameters_ in self.Parameters:
            Parameters_.export(outfile, level, namespace_, name_='Parameters')
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('<%sNoRowsMessage>%s</%sNoRowsMessage>\n' % (namespace_, self.gds_format_string(quote_xml(NoRowsMessage_).encode(ExternalEncoding), input_name='NoRowsMessage'), namespace_))
        for MergeTransactions_ in self.MergeTransactions:
            showIndent(outfile, level)
            outfile.write('<%sMergeTransactions>%s</%sMergeTransactions>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(MergeTransactions_)), input_name='MergeTransactions'), namespace_))
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('<%sKeepTogether>%s</%sKeepTogether>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(KeepTogether_)), input_name='KeepTogether'), namespace_))
        for OmitBorderOnPageBreak_ in self.OmitBorderOnPageBreak:
            showIndent(outfile, level)
            outfile.write('<%sOmitBorderOnPageBreak>%s</%sOmitBorderOnPageBreak>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(OmitBorderOnPageBreak_)), input_name='OmitBorderOnPageBreak'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.ReportName or
            self.Parameters or
            self.NoRowsMessage or
            self.MergeTransactions or
            self.KeepTogether or
            self.OmitBorderOnPageBreak or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubreportType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportName=[\n')
        level += 1
        for ReportName_ in self.ReportName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ReportName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Parameters=[\n')
        level += 1
        for Parameters_ in self.Parameters:
            showIndent(outfile, level)
            outfile.write('model_.ParametersType(\n')
            Parameters_.exportLiteral(outfile, level, name_='ParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NoRowsMessage=[\n')
        level += 1
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NoRowsMessage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MergeTransactions=[\n')
        level += 1
        for MergeTransactions_ in self.MergeTransactions:
            showIndent(outfile, level)
            outfile.write('%s,\n' % MergeTransactions)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeepTogether=[\n')
        level += 1
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('%s,\n' % KeepTogether)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OmitBorderOnPageBreak=[\n')
        level += 1
        for OmitBorderOnPageBreak_ in self.OmitBorderOnPageBreak:
            showIndent(outfile, level)
            outfile.write('%s,\n' % OmitBorderOnPageBreak)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'ReportName':
            ReportName_ = child_.text
            ReportName_ = self.gds_validate_string(ReportName_, node, 'ReportName')
            self.ReportName.append(ReportName_)
        elif nodeName_ == 'Parameters':
            obj_ = ParametersType.factory()
            obj_.build(child_)
            self.Parameters.append(obj_)
        elif nodeName_ == 'NoRowsMessage':
            NoRowsMessage_ = child_.text
            NoRowsMessage_ = self.gds_validate_string(NoRowsMessage_, node, 'NoRowsMessage')
            self.NoRowsMessage.append(NoRowsMessage_)
        elif nodeName_ == 'MergeTransactions':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MergeTransactions')
            self.MergeTransactions.append(ival_)
        elif nodeName_ == 'KeepTogether':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KeepTogether')
            self.KeepTogether.append(ival_)
        elif nodeName_ == 'OmitBorderOnPageBreak':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'OmitBorderOnPageBreak')
            self.OmitBorderOnPageBreak.append(ival_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class SubreportType


class CustomReportItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Type=None, Style=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, AltReportItem=None, CustomData=None, DataElementName=None, DataElementOutput=None):
        self.Name = _cast(None, Name)
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if AltReportItem is None:
            self.AltReportItem = []
        else:
            self.AltReportItem = AltReportItem
        if CustomData is None:
            self.CustomData = []
        else:
            self.CustomData = CustomData
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CustomReportItemType.subclass:
            return CustomReportItemType.subclass(*args_, **kwargs_)
        else:
            return CustomReportItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_AltReportItem(self): return self.AltReportItem
    def set_AltReportItem(self, AltReportItem): self.AltReportItem = AltReportItem
    def add_AltReportItem(self, value): self.AltReportItem.append(value)
    def insert_AltReportItem(self, index, value): self.AltReportItem[index] = value
    def get_CustomData(self): return self.CustomData
    def set_CustomData(self, CustomData): self.CustomData = CustomData
    def add_CustomData(self, value): self.CustomData.append(value)
    def insert_CustomData(self, index, value): self.CustomData[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CustomReportItemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomReportItemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomReportItemType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CustomReportItemType', fromsubclass_=False):
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(Type_).encode(ExternalEncoding), input_name='Type'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for AltReportItem_ in self.AltReportItem:
            AltReportItem_.export(outfile, level, namespace_, name_='AltReportItem')
        for CustomData_ in self.CustomData:
            CustomData_.export(outfile, level, namespace_, name_='CustomData')
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Type or
            self.Style or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.AltReportItem or
            self.CustomData or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomReportItemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AltReportItem=[\n')
        level += 1
        for AltReportItem_ in self.AltReportItem:
            showIndent(outfile, level)
            outfile.write('model_.ReportItemsType(\n')
            AltReportItem_.exportLiteral(outfile, level, name_='ReportItemsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomData=[\n')
        level += 1
        for CustomData_ in self.CustomData:
            showIndent(outfile, level)
            outfile.write('model_.CustomDataType(\n')
            CustomData_.exportLiteral(outfile, level, name_='CustomDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'AltReportItem':
            obj_ = ReportItemsType.factory()
            obj_.build(child_)
            self.AltReportItem.append(obj_)
        elif nodeName_ == 'CustomData':
            obj_ = CustomDataType.factory()
            obj_.build(child_)
            self.CustomData.append(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class CustomReportItemType


class CustomDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataSetName=None, Filters=None, SortExpressions=None, DataColumnHierarchy=None, DataRowHierarchy=None, DataRows=None):
        if DataSetName is None:
            self.DataSetName = []
        else:
            self.DataSetName = DataSetName
        if Filters is None:
            self.Filters = []
        else:
            self.Filters = Filters
        if SortExpressions is None:
            self.SortExpressions = []
        else:
            self.SortExpressions = SortExpressions
        if DataColumnHierarchy is None:
            self.DataColumnHierarchy = []
        else:
            self.DataColumnHierarchy = DataColumnHierarchy
        if DataRowHierarchy is None:
            self.DataRowHierarchy = []
        else:
            self.DataRowHierarchy = DataRowHierarchy
        if DataRows is None:
            self.DataRows = []
        else:
            self.DataRows = DataRows
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CustomDataType.subclass:
            return CustomDataType.subclass(*args_, **kwargs_)
        else:
            return CustomDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSetName(self): return self.DataSetName
    def set_DataSetName(self, DataSetName): self.DataSetName = DataSetName
    def add_DataSetName(self, value): self.DataSetName.append(value)
    def insert_DataSetName(self, index, value): self.DataSetName[index] = value
    def get_Filters(self): return self.Filters
    def set_Filters(self, Filters): self.Filters = Filters
    def add_Filters(self, value): self.Filters.append(value)
    def insert_Filters(self, index, value): self.Filters[index] = value
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def add_SortExpressions(self, value): self.SortExpressions.append(value)
    def insert_SortExpressions(self, index, value): self.SortExpressions[index] = value
    def get_DataColumnHierarchy(self): return self.DataColumnHierarchy
    def set_DataColumnHierarchy(self, DataColumnHierarchy): self.DataColumnHierarchy = DataColumnHierarchy
    def add_DataColumnHierarchy(self, value): self.DataColumnHierarchy.append(value)
    def insert_DataColumnHierarchy(self, index, value): self.DataColumnHierarchy[index] = value
    def get_DataRowHierarchy(self): return self.DataRowHierarchy
    def set_DataRowHierarchy(self, DataRowHierarchy): self.DataRowHierarchy = DataRowHierarchy
    def add_DataRowHierarchy(self, value): self.DataRowHierarchy.append(value)
    def insert_DataRowHierarchy(self, index, value): self.DataRowHierarchy[index] = value
    def get_DataRows(self): return self.DataRows
    def set_DataRows(self, DataRows): self.DataRows = DataRows
    def add_DataRows(self, value): self.DataRows.append(value)
    def insert_DataRows(self, index, value): self.DataRows[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CustomDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomDataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomDataType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomDataType', fromsubclass_=False):
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('<%sDataSetName>%s</%sDataSetName>\n' % (namespace_, self.gds_format_string(quote_xml(DataSetName_).encode(ExternalEncoding), input_name='DataSetName'), namespace_))
        for Filters_ in self.Filters:
            Filters_.export(outfile, level, namespace_, name_='Filters')
        for SortExpressions_ in self.SortExpressions:
            SortExpressions_.export(outfile, level, namespace_, name_='SortExpressions')
        for DataColumnHierarchy_ in self.DataColumnHierarchy:
            DataColumnHierarchy_.export(outfile, level, namespace_, name_='DataColumnHierarchy')
        for DataRowHierarchy_ in self.DataRowHierarchy:
            DataRowHierarchy_.export(outfile, level, namespace_, name_='DataRowHierarchy')
        for DataRows_ in self.DataRows:
            DataRows_.export(outfile, level, namespace_, name_='DataRows')
    def hasContent_(self):
        if (
            self.DataSetName or
            self.Filters or
            self.SortExpressions or
            self.DataColumnHierarchy or
            self.DataRowHierarchy or
            self.DataRows
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSetName=[\n')
        level += 1
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSetName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Filters=[\n')
        level += 1
        for Filters_ in self.Filters:
            showIndent(outfile, level)
            outfile.write('model_.FiltersType(\n')
            Filters_.exportLiteral(outfile, level, name_='FiltersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressions=[\n')
        level += 1
        for SortExpressions_ in self.SortExpressions:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionsType(\n')
            SortExpressions_.exportLiteral(outfile, level, name_='SortExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataColumnHierarchy=[\n')
        level += 1
        for DataColumnHierarchy_ in self.DataColumnHierarchy:
            showIndent(outfile, level)
            outfile.write('model_.DataColumnHierarchyType(\n')
            DataColumnHierarchy_.exportLiteral(outfile, level, name_='DataColumnHierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataRowHierarchy=[\n')
        level += 1
        for DataRowHierarchy_ in self.DataRowHierarchy:
            showIndent(outfile, level)
            outfile.write('model_.DataRowHierarchyType(\n')
            DataRowHierarchy_.exportLiteral(outfile, level, name_='DataRowHierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataRows=[\n')
        level += 1
        for DataRows_ in self.DataRows:
            showIndent(outfile, level)
            outfile.write('model_.DataRowsType(\n')
            DataRows_.exportLiteral(outfile, level, name_='DataRowsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSetName':
            DataSetName_ = child_.text
            DataSetName_ = self.gds_validate_string(DataSetName_, node, 'DataSetName')
            self.DataSetName.append(DataSetName_)
        elif nodeName_ == 'Filters':
            obj_ = FiltersType.factory()
            obj_.build(child_)
            self.Filters.append(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.SortExpressions.append(obj_)
        elif nodeName_ == 'DataColumnHierarchy':
            obj_ = DataColumnHierarchyType.factory()
            obj_.build(child_)
            self.DataColumnHierarchy.append(obj_)
        elif nodeName_ == 'DataRowHierarchy':
            obj_ = DataRowHierarchyType.factory()
            obj_.build(child_)
            self.DataRowHierarchy.append(obj_)
        elif nodeName_ == 'DataRows':
            obj_ = DataRowsType.factory()
            obj_.build(child_)
            self.DataRows.append(obj_)
# end class CustomDataType


class DataColumnHierarchyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataMembers=None):
        if DataMembers is None:
            self.DataMembers = []
        else:
            self.DataMembers = DataMembers
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataColumnHierarchyType.subclass:
            return DataColumnHierarchyType.subclass(*args_, **kwargs_)
        else:
            return DataColumnHierarchyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataMembers(self): return self.DataMembers
    def set_DataMembers(self, DataMembers): self.DataMembers = DataMembers
    def add_DataMembers(self, value): self.DataMembers.append(value)
    def insert_DataMembers(self, index, value): self.DataMembers[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataColumnHierarchyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataColumnHierarchyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataColumnHierarchyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataColumnHierarchyType', fromsubclass_=False):
        for DataMembers_ in self.DataMembers:
            DataMembers_.export(outfile, level, namespace_, name_='DataMembers')
    def hasContent_(self):
        if (
            self.DataMembers
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataColumnHierarchyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataMembers=[\n')
        level += 1
        for DataMembers_ in self.DataMembers:
            showIndent(outfile, level)
            outfile.write('model_.DataMembersType(\n')
            DataMembers_.exportLiteral(outfile, level, name_='DataMembersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataMembers':
            obj_ = DataMembersType.factory()
            obj_.build(child_)
            self.DataMembers.append(obj_)
# end class DataColumnHierarchyType


class DataRowHierarchyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataMembers=None):
        if DataMembers is None:
            self.DataMembers = []
        else:
            self.DataMembers = DataMembers
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataRowHierarchyType.subclass:
            return DataRowHierarchyType.subclass(*args_, **kwargs_)
        else:
            return DataRowHierarchyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataMembers(self): return self.DataMembers
    def set_DataMembers(self, DataMembers): self.DataMembers = DataMembers
    def add_DataMembers(self, value): self.DataMembers.append(value)
    def insert_DataMembers(self, index, value): self.DataMembers[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataRowHierarchyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataRowHierarchyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataRowHierarchyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataRowHierarchyType', fromsubclass_=False):
        for DataMembers_ in self.DataMembers:
            DataMembers_.export(outfile, level, namespace_, name_='DataMembers')
    def hasContent_(self):
        if (
            self.DataMembers
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataRowHierarchyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataMembers=[\n')
        level += 1
        for DataMembers_ in self.DataMembers:
            showIndent(outfile, level)
            outfile.write('model_.DataMembersType(\n')
            DataMembers_.exportLiteral(outfile, level, name_='DataMembersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataMembers':
            obj_ = DataMembersType.factory()
            obj_.build(child_)
            self.DataMembers.append(obj_)
# end class DataRowHierarchyType


class DataMembersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataMember=None):
        if DataMember is None:
            self.DataMember = []
        else:
            self.DataMember = DataMember
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataMembersType.subclass:
            return DataMembersType.subclass(*args_, **kwargs_)
        else:
            return DataMembersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataMember(self): return self.DataMember
    def set_DataMember(self, DataMember): self.DataMember = DataMember
    def add_DataMember(self, value): self.DataMember.append(value)
    def insert_DataMember(self, index, value): self.DataMember[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataMembersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataMembersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataMembersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataMembersType', fromsubclass_=False):
        for DataMember_ in self.DataMember:
            DataMember_.export(outfile, level, namespace_, name_='DataMember')
    def hasContent_(self):
        if (
            self.DataMember
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataMembersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataMember=[\n')
        level += 1
        for DataMember_ in self.DataMember:
            showIndent(outfile, level)
            outfile.write('model_.DataMemberType(\n')
            DataMember_.exportLiteral(outfile, level, name_='DataMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataMember':
            obj_ = DataMemberType.factory()
            obj_.build(child_)
            self.DataMember.append(obj_)
# end class DataMembersType


class DataMemberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None, SortExpressions=None, Subtotal=None, CustomProperties=None, DataMembers=None):
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        if SortExpressions is None:
            self.SortExpressions = []
        else:
            self.SortExpressions = SortExpressions
        if Subtotal is None:
            self.Subtotal = []
        else:
            self.Subtotal = Subtotal
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if DataMembers is None:
            self.DataMembers = []
        else:
            self.DataMembers = DataMembers
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataMemberType.subclass:
            return DataMemberType.subclass(*args_, **kwargs_)
        else:
            return DataMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group(self, index, value): self.Group[index] = value
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def add_SortExpressions(self, value): self.SortExpressions.append(value)
    def insert_SortExpressions(self, index, value): self.SortExpressions[index] = value
    def get_Subtotal(self): return self.Subtotal
    def set_Subtotal(self, Subtotal): self.Subtotal = Subtotal
    def add_Subtotal(self, value): self.Subtotal.append(value)
    def insert_Subtotal(self, index, value): self.Subtotal[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_DataMembers(self): return self.DataMembers
    def set_DataMembers(self, DataMembers): self.DataMembers = DataMembers
    def add_DataMembers(self, value): self.DataMembers.append(value)
    def insert_DataMembers(self, index, value): self.DataMembers[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataMemberType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataMemberType', fromsubclass_=False):
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group')
        for SortExpressions_ in self.SortExpressions:
            SortExpressions_.export(outfile, level, namespace_, name_='SortExpressions')
        for Subtotal_ in self.Subtotal:
            showIndent(outfile, level)
            outfile.write('<%sSubtotal>%s</%sSubtotal>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(Subtotal_)), input_name='Subtotal'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for DataMembers_ in self.DataMembers:
            DataMembers_.export(outfile, level, namespace_, name_='DataMembers')
    def hasContent_(self):
        if (
            self.Group or
            self.SortExpressions or
            self.Subtotal or
            self.CustomProperties or
            self.DataMembers
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.GroupType(\n')
            Group_.exportLiteral(outfile, level, name_='GroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressions=[\n')
        level += 1
        for SortExpressions_ in self.SortExpressions:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionsType(\n')
            SortExpressions_.exportLiteral(outfile, level, name_='SortExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Subtotal=[\n')
        level += 1
        for Subtotal_ in self.Subtotal:
            showIndent(outfile, level)
            outfile.write('%s,\n' % Subtotal)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataMembers=[\n')
        level += 1
        for DataMembers_ in self.DataMembers:
            showIndent(outfile, level)
            outfile.write('model_.DataMembersType(\n')
            DataMembers_.exportLiteral(outfile, level, name_='DataMembersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = GroupType.factory()
            obj_.build(child_)
            self.Group.append(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.SortExpressions.append(obj_)
        elif nodeName_ == 'Subtotal':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Subtotal')
            self.Subtotal.append(ival_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'DataMembers':
            obj_ = DataMembersType.factory()
            obj_.build(child_)
            self.DataMembers.append(obj_)
# end class DataMemberType


class DataRowsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataRow=None):
        if DataRow is None:
            self.DataRow = []
        else:
            self.DataRow = DataRow
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataRowsType.subclass:
            return DataRowsType.subclass(*args_, **kwargs_)
        else:
            return DataRowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataRow(self): return self.DataRow
    def set_DataRow(self, DataRow): self.DataRow = DataRow
    def add_DataRow(self, value): self.DataRow.append(value)
    def insert_DataRow(self, index, value): self.DataRow[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataRowsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataRowsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataRowsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataRowsType', fromsubclass_=False):
        for DataRow_ in self.DataRow:
            DataRow_.export(outfile, level, namespace_, name_='DataRow')
    def hasContent_(self):
        if (
            self.DataRow
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataRowsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataRow=[\n')
        level += 1
        for DataRow_ in self.DataRow:
            showIndent(outfile, level)
            outfile.write('model_.DataRowType(\n')
            DataRow_.exportLiteral(outfile, level, name_='DataRowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataRow':
            obj_ = DataRowType.factory()
            obj_.build(child_)
            self.DataRow.append(obj_)
# end class DataRowsType


class DataRowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataCell=None):
        if DataCell is None:
            self.DataCell = []
        else:
            self.DataCell = DataCell
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataRowType.subclass:
            return DataRowType.subclass(*args_, **kwargs_)
        else:
            return DataRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataCell(self): return self.DataCell
    def set_DataCell(self, DataCell): self.DataCell = DataCell
    def add_DataCell(self, value): self.DataCell.append(value)
    def insert_DataCell(self, index, value): self.DataCell[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataRowType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataRowType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataRowType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataRowType', fromsubclass_=False):
        for DataCell_ in self.DataCell:
            DataCell_.export(outfile, level, namespace_, name_='DataCell')
    def hasContent_(self):
        if (
            self.DataCell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataRowType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataCell=[\n')
        level += 1
        for DataCell_ in self.DataCell:
            showIndent(outfile, level)
            outfile.write('model_.DataCellType(\n')
            DataCell_.exportLiteral(outfile, level, name_='DataCellType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataCell':
            obj_ = DataCellType.factory()
            obj_.build(child_)
            self.DataCell.append(obj_)
# end class DataRowType


class DataCellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataValue=None):
        if DataValue is None:
            self.DataValue = []
        else:
            self.DataValue = DataValue
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataCellType.subclass:
            return DataCellType.subclass(*args_, **kwargs_)
        else:
            return DataCellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataValue(self): return self.DataValue
    def set_DataValue(self, DataValue): self.DataValue = DataValue
    def add_DataValue(self, value): self.DataValue.append(value)
    def insert_DataValue(self, index, value): self.DataValue[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataCellType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataCellType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataCellType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataCellType', fromsubclass_=False):
        for DataValue_ in self.DataValue:
            DataValue_.export(outfile, level, namespace_, name_='DataValue')
    def hasContent_(self):
        if (
            self.DataValue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataCellType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataValue=[\n')
        level += 1
        for DataValue_ in self.DataValue:
            showIndent(outfile, level)
            outfile.write('model_.DataValueType(\n')
            DataValue_.exportLiteral(outfile, level, name_='DataValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataValue':
            obj_ = DataValueType.factory()
            obj_.build(child_)
            self.DataValue.append(obj_)
# end class DataCellType


class ParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Parameter=None):
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ParametersType.subclass:
            return ParametersType.subclass(*args_, **kwargs_)
        else:
            return ParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ParametersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParametersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParametersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParametersType', fromsubclass_=False):
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter')
    def hasContent_(self):
        if (
            self.Parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.ParameterType(\n')
            Parameter_.exportLiteral(outfile, level, name_='ParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Parameter':
            obj_ = ParameterType.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
# end class ParametersType


class ParameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None, Omit=None):
        self.Name = _cast(None, Name)
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Omit is None:
            self.Omit = []
        else:
            self.Omit = Omit
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ParameterType.subclass:
            return ParameterType.subclass(*args_, **kwargs_)
        else:
            return ParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Omit(self): return self.Omit
    def set_Omit(self, Omit): self.Omit = Omit
    def add_Omit(self, value): self.Omit.append(value)
    def insert_Omit(self, index, value): self.Omit[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Omit_ in self.Omit:
            showIndent(outfile, level)
            outfile.write('<%sOmit>%s</%sOmit>\n' % (namespace_, self.gds_format_string(quote_xml(Omit_).encode(ExternalEncoding), input_name='Omit'), namespace_))
    def hasContent_(self):
        if (
            self.Value or
            self.Omit
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Omit=[\n')
        level += 1
        for Omit_ in self.Omit:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Omit_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Omit':
            Omit_ = child_.text
            Omit_ = self.gds_validate_string(Omit_, node, 'Omit')
            self.Omit.append(Omit_)
# end class ParameterType


class GroupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, DocumentMapLabel=None, GroupExpressions=None, ReGroupExpressions=None, PageBreak=None, Filters=None, Parent=None, DataElementName=None, DataElementOutput=None, Variables=None):
        self.Name = _cast(None, Name)
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if GroupExpressions is None:
            self.GroupExpressions = []
        else:
            self.GroupExpressions = GroupExpressions
        if ReGroupExpressions is None:
            self.ReGroupExpressions = []
        else:
            self.ReGroupExpressions = ReGroupExpressions
        if PageBreak is None:
            self.PageBreak = []
        else:
            self.PageBreak = PageBreak
        if Filters is None:
            self.Filters = []
        else:
            self.Filters = Filters
        if Parent is None:
            self.Parent = []
        else:
            self.Parent = Parent
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        if Variables is None:
            self.Variables = []
        else:
            self.Variables = Variables
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GroupType.subclass:
            return GroupType.subclass(*args_, **kwargs_)
        else:
            return GroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_GroupExpressions(self): return self.GroupExpressions
    def set_GroupExpressions(self, GroupExpressions): self.GroupExpressions = GroupExpressions
    def add_GroupExpressions(self, value): self.GroupExpressions.append(value)
    def insert_GroupExpressions(self, index, value): self.GroupExpressions[index] = value
    def get_ReGroupExpressions(self): return self.ReGroupExpressions
    def set_ReGroupExpressions(self, ReGroupExpressions): self.ReGroupExpressions = ReGroupExpressions
    def add_ReGroupExpressions(self, value): self.ReGroupExpressions.append(value)
    def insert_ReGroupExpressions(self, index, value): self.ReGroupExpressions[index] = value
    def get_PageBreak(self): return self.PageBreak
    def set_PageBreak(self, PageBreak): self.PageBreak = PageBreak
    def add_PageBreak(self, value): self.PageBreak.append(value)
    def insert_PageBreak(self, index, value): self.PageBreak[index] = value
    def get_Filters(self): return self.Filters
    def set_Filters(self, Filters): self.Filters = Filters
    def add_Filters(self, value): self.Filters.append(value)
    def insert_Filters(self, index, value): self.Filters[index] = value
    def get_Parent(self): return self.Parent
    def set_Parent(self, Parent): self.Parent = Parent
    def add_Parent(self, value): self.Parent.append(value)
    def insert_Parent(self, index, value): self.Parent[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Variables(self): return self.Variables
    def set_Variables(self, Variables): self.Variables = Variables
    def add_Variables(self, value): self.Variables.append(value)
    def insert_Variables(self, index, value): self.Variables[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GroupType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GroupType', fromsubclass_=False):
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for GroupExpressions_ in self.GroupExpressions:
            GroupExpressions_.export(outfile, level, namespace_, name_='GroupExpressions')
        for ReGroupExpressions_ in self.ReGroupExpressions:
            ReGroupExpressions_.export(outfile, level, namespace_, name_='ReGroupExpressions')
        for PageBreak_ in self.PageBreak:
            PageBreak_.export(outfile, level, namespace_, name_='PageBreak')
        for Filters_ in self.Filters:
            Filters_.export(outfile, level, namespace_, name_='Filters')
        for Parent_ in self.Parent:
            showIndent(outfile, level)
            outfile.write('<%sParent>%s</%sParent>\n' % (namespace_, self.gds_format_string(quote_xml(Parent_).encode(ExternalEncoding), input_name='Parent'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
        for Variables_ in self.Variables:
            Variables_.export(outfile, level, namespace_, name_='Variables')
    def hasContent_(self):
        if (
            self.DocumentMapLabel or
            self.GroupExpressions or
            self.ReGroupExpressions or
            self.PageBreak or
            self.Filters or
            self.Parent or
            self.DataElementName or
            self.DataElementOutput or
            self.Variables
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GroupExpressions=[\n')
        level += 1
        for GroupExpressions_ in self.GroupExpressions:
            showIndent(outfile, level)
            outfile.write('model_.GroupExpressionsType(\n')
            GroupExpressions_.exportLiteral(outfile, level, name_='GroupExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReGroupExpressions=[\n')
        level += 1
        for ReGroupExpressions_ in self.ReGroupExpressions:
            showIndent(outfile, level)
            outfile.write('model_.GroupExpressionsType(\n')
            ReGroupExpressions_.exportLiteral(outfile, level, name_='GroupExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageBreak=[\n')
        level += 1
        for PageBreak_ in self.PageBreak:
            showIndent(outfile, level)
            outfile.write('model_.PageBreakType(\n')
            PageBreak_.exportLiteral(outfile, level, name_='PageBreakType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Filters=[\n')
        level += 1
        for Filters_ in self.Filters:
            showIndent(outfile, level)
            outfile.write('model_.FiltersType(\n')
            Filters_.exportLiteral(outfile, level, name_='FiltersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Parent=[\n')
        level += 1
        for Parent_ in self.Parent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Parent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Variables=[\n')
        level += 1
        for Variables_ in self.Variables:
            showIndent(outfile, level)
            outfile.write('model_.VariablesType(\n')
            Variables_.exportLiteral(outfile, level, name_='VariablesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'GroupExpressions':
            obj_ = GroupExpressionsType.factory()
            obj_.build(child_)
            self.GroupExpressions.append(obj_)
        elif nodeName_ == 'ReGroupExpressions':
            obj_ = GroupExpressionsType.factory()
            obj_.build(child_)
            self.ReGroupExpressions.append(obj_)
        elif nodeName_ == 'PageBreak':
            obj_ = PageBreakType.factory()
            obj_.build(child_)
            self.PageBreak.append(obj_)
        elif nodeName_ == 'Filters':
            obj_ = FiltersType.factory()
            obj_.build(child_)
            self.Filters.append(obj_)
        elif nodeName_ == 'Parent':
            Parent_ = child_.text
            Parent_ = self.gds_validate_string(Parent_, node, 'Parent')
            self.Parent.append(Parent_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
        elif nodeName_ == 'Variables':
            obj_ = VariablesType.factory()
            obj_.build(child_)
            self.Variables.append(obj_)
# end class GroupType


class VariablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Variable=None):
        if Variable is None:
            self.Variable = []
        else:
            self.Variable = Variable
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VariablesType.subclass:
            return VariablesType.subclass(*args_, **kwargs_)
        else:
            return VariablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Variable(self): return self.Variable
    def set_Variable(self, Variable): self.Variable = Variable
    def add_Variable(self, value): self.Variable.append(value)
    def insert_Variable(self, index, value): self.Variable[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VariablesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariablesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VariablesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VariablesType', fromsubclass_=False):
        for Variable_ in self.Variable:
            Variable_.export(outfile, level, namespace_, name_='Variable')
    def hasContent_(self):
        if (
            self.Variable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariablesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Variable=[\n')
        level += 1
        for Variable_ in self.Variable:
            showIndent(outfile, level)
            outfile.write('model_.VariableType(\n')
            Variable_.exportLiteral(outfile, level, name_='VariableType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Variable':
            obj_ = VariableType.factory()
            obj_.build(child_)
            self.Variable.append(obj_)
# end class VariablesType


class VariableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None):
        self.Name = _cast(None, Name)
        self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VariableType.subclass:
            return VariableType.subclass(*args_, **kwargs_)
        else:
            return VariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='VariableType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VariableType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VariableType', fromsubclass_=False):
        if self.Value:
            self.Value.export(outfile, level, namespace_, name_='Value', )
    def hasContent_(self):
        if (
            self.Value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.StringWithDataTypeAttribute(\n')
            self.Value.exportLiteral(outfile, level, name_='Value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            class_obj_ = self.get_class_obj_(child_, StringWithDataTypeAttribute)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Value(obj_)
# end class VariableType


class GroupExpressionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GroupExpression=None):
        if GroupExpression is None:
            self.GroupExpression = []
        else:
            self.GroupExpression = GroupExpression
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GroupExpressionsType.subclass:
            return GroupExpressionsType.subclass(*args_, **kwargs_)
        else:
            return GroupExpressionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GroupExpression(self): return self.GroupExpression
    def set_GroupExpression(self, GroupExpression): self.GroupExpression = GroupExpression
    def add_GroupExpression(self, value): self.GroupExpression.append(value)
    def insert_GroupExpression(self, index, value): self.GroupExpression[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GroupExpressionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupExpressionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupExpressionsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupExpressionsType', fromsubclass_=False):
        for GroupExpression_ in self.GroupExpression:
            showIndent(outfile, level)
            outfile.write('<%sGroupExpression>%s</%sGroupExpression>\n' % (namespace_, self.gds_format_string(quote_xml(GroupExpression_).encode(ExternalEncoding), input_name='GroupExpression'), namespace_))
    def hasContent_(self):
        if (
            self.GroupExpression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupExpressionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('GroupExpression=[\n')
        level += 1
        for GroupExpression_ in self.GroupExpression:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GroupExpression_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GroupExpression':
            GroupExpression_ = child_.text
            GroupExpression_ = self.gds_validate_string(GroupExpression_, node, 'GroupExpression')
            self.GroupExpression.append(GroupExpression_)
# end class GroupExpressionsType


class SortExpressionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SortExpression=None):
        if SortExpression is None:
            self.SortExpression = []
        else:
            self.SortExpression = SortExpression
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if SortExpressionsType.subclass:
            return SortExpressionsType.subclass(*args_, **kwargs_)
        else:
            return SortExpressionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SortExpression(self): return self.SortExpression
    def set_SortExpression(self, SortExpression): self.SortExpression = SortExpression
    def add_SortExpression(self, value): self.SortExpression.append(value)
    def insert_SortExpression(self, index, value): self.SortExpression[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='SortExpressionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SortExpressionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SortExpressionsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SortExpressionsType', fromsubclass_=False):
        for SortExpression_ in self.SortExpression:
            SortExpression_.export(outfile, level, namespace_, name_='SortExpression')
    def hasContent_(self):
        if (
            self.SortExpression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SortExpressionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SortExpression=[\n')
        level += 1
        for SortExpression_ in self.SortExpression:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionType(\n')
            SortExpression_.exportLiteral(outfile, level, name_='SortExpressionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SortExpression':
            obj_ = SortExpressionType.factory()
            obj_.build(child_)
            self.SortExpression.append(obj_)
# end class SortExpressionsType


class SortExpressionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None, Direction=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Direction is None:
            self.Direction = []
        else:
            self.Direction = Direction
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if SortExpressionType.subclass:
            return SortExpressionType.subclass(*args_, **kwargs_)
        else:
            return SortExpressionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    def add_Direction(self, value): self.Direction.append(value)
    def insert_Direction(self, index, value): self.Direction[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='SortExpressionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SortExpressionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SortExpressionType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SortExpressionType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Direction_ in self.Direction:
            showIndent(outfile, level)
            outfile.write('<%sDirection>%s</%sDirection>\n' % (namespace_, self.gds_format_string(quote_xml(Direction_).encode(ExternalEncoding), input_name='Direction'), namespace_))
    def hasContent_(self):
        if (
            self.Value or
            self.Direction
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SortExpressionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Direction=[\n')
        level += 1
        for Direction_ in self.Direction:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Direction_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction.append(Direction_)
# end class SortExpressionType


class Direction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Direction.subclass:
            return Direction.subclass(*args_, **kwargs_)
        else:
            return Direction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Direction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Direction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Direction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Direction', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Direction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Direction


class ChartType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, SortExpressions=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, NoRowsMessage=None, DataSetName=None, PageBreak=None, Filters=None, ChartSeriesHierarchy=None, ChartCategoryHierarchy=None, ChartData=None, ChartAreas=None, ChartLegends=None, ChartTitles=None, DynamicHeight=None, DynamicWidth=None, Palette=None, ChartCustomPaletteColors=None, PaletteHatchBehavior=None, DataElementName=None, DataElementOutput=None, ChartBorderSkin=None, Code=None, CodeLanguage=None, ChartCodeParameters=None, ChartAnnotations=None, ChartNoDataMessage=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if SortExpressions is None:
            self.SortExpressions = []
        else:
            self.SortExpressions = SortExpressions
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if NoRowsMessage is None:
            self.NoRowsMessage = []
        else:
            self.NoRowsMessage = NoRowsMessage
        if DataSetName is None:
            self.DataSetName = []
        else:
            self.DataSetName = DataSetName
        if PageBreak is None:
            self.PageBreak = []
        else:
            self.PageBreak = PageBreak
        if Filters is None:
            self.Filters = []
        else:
            self.Filters = Filters
        if ChartSeriesHierarchy is None:
            self.ChartSeriesHierarchy = []
        else:
            self.ChartSeriesHierarchy = ChartSeriesHierarchy
        if ChartCategoryHierarchy is None:
            self.ChartCategoryHierarchy = []
        else:
            self.ChartCategoryHierarchy = ChartCategoryHierarchy
        if ChartData is None:
            self.ChartData = []
        else:
            self.ChartData = ChartData
        if ChartAreas is None:
            self.ChartAreas = []
        else:
            self.ChartAreas = ChartAreas
        if ChartLegends is None:
            self.ChartLegends = []
        else:
            self.ChartLegends = ChartLegends
        if ChartTitles is None:
            self.ChartTitles = []
        else:
            self.ChartTitles = ChartTitles
        if DynamicHeight is None:
            self.DynamicHeight = []
        else:
            self.DynamicHeight = DynamicHeight
        if DynamicWidth is None:
            self.DynamicWidth = []
        else:
            self.DynamicWidth = DynamicWidth
        if Palette is None:
            self.Palette = []
        else:
            self.Palette = Palette
        if ChartCustomPaletteColors is None:
            self.ChartCustomPaletteColors = []
        else:
            self.ChartCustomPaletteColors = ChartCustomPaletteColors
        if PaletteHatchBehavior is None:
            self.PaletteHatchBehavior = []
        else:
            self.PaletteHatchBehavior = PaletteHatchBehavior
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        if ChartBorderSkin is None:
            self.ChartBorderSkin = []
        else:
            self.ChartBorderSkin = ChartBorderSkin
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        if CodeLanguage is None:
            self.CodeLanguage = []
        else:
            self.CodeLanguage = CodeLanguage
        if ChartCodeParameters is None:
            self.ChartCodeParameters = []
        else:
            self.ChartCodeParameters = ChartCodeParameters
        if ChartAnnotations is None:
            self.ChartAnnotations = []
        else:
            self.ChartAnnotations = ChartAnnotations
        if ChartNoDataMessage is None:
            self.ChartNoDataMessage = []
        else:
            self.ChartNoDataMessage = ChartNoDataMessage
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartType.subclass:
            return ChartType.subclass(*args_, **kwargs_)
        else:
            return ChartType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def add_SortExpressions(self, value): self.SortExpressions.append(value)
    def insert_SortExpressions(self, index, value): self.SortExpressions[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_NoRowsMessage(self): return self.NoRowsMessage
    def set_NoRowsMessage(self, NoRowsMessage): self.NoRowsMessage = NoRowsMessage
    def add_NoRowsMessage(self, value): self.NoRowsMessage.append(value)
    def insert_NoRowsMessage(self, index, value): self.NoRowsMessage[index] = value
    def get_DataSetName(self): return self.DataSetName
    def set_DataSetName(self, DataSetName): self.DataSetName = DataSetName
    def add_DataSetName(self, value): self.DataSetName.append(value)
    def insert_DataSetName(self, index, value): self.DataSetName[index] = value
    def get_PageBreak(self): return self.PageBreak
    def set_PageBreak(self, PageBreak): self.PageBreak = PageBreak
    def add_PageBreak(self, value): self.PageBreak.append(value)
    def insert_PageBreak(self, index, value): self.PageBreak[index] = value
    def get_Filters(self): return self.Filters
    def set_Filters(self, Filters): self.Filters = Filters
    def add_Filters(self, value): self.Filters.append(value)
    def insert_Filters(self, index, value): self.Filters[index] = value
    def get_ChartSeriesHierarchy(self): return self.ChartSeriesHierarchy
    def set_ChartSeriesHierarchy(self, ChartSeriesHierarchy): self.ChartSeriesHierarchy = ChartSeriesHierarchy
    def add_ChartSeriesHierarchy(self, value): self.ChartSeriesHierarchy.append(value)
    def insert_ChartSeriesHierarchy(self, index, value): self.ChartSeriesHierarchy[index] = value
    def get_ChartCategoryHierarchy(self): return self.ChartCategoryHierarchy
    def set_ChartCategoryHierarchy(self, ChartCategoryHierarchy): self.ChartCategoryHierarchy = ChartCategoryHierarchy
    def add_ChartCategoryHierarchy(self, value): self.ChartCategoryHierarchy.append(value)
    def insert_ChartCategoryHierarchy(self, index, value): self.ChartCategoryHierarchy[index] = value
    def get_ChartData(self): return self.ChartData
    def set_ChartData(self, ChartData): self.ChartData = ChartData
    def add_ChartData(self, value): self.ChartData.append(value)
    def insert_ChartData(self, index, value): self.ChartData[index] = value
    def get_ChartAreas(self): return self.ChartAreas
    def set_ChartAreas(self, ChartAreas): self.ChartAreas = ChartAreas
    def add_ChartAreas(self, value): self.ChartAreas.append(value)
    def insert_ChartAreas(self, index, value): self.ChartAreas[index] = value
    def get_ChartLegends(self): return self.ChartLegends
    def set_ChartLegends(self, ChartLegends): self.ChartLegends = ChartLegends
    def add_ChartLegends(self, value): self.ChartLegends.append(value)
    def insert_ChartLegends(self, index, value): self.ChartLegends[index] = value
    def get_ChartTitles(self): return self.ChartTitles
    def set_ChartTitles(self, ChartTitles): self.ChartTitles = ChartTitles
    def add_ChartTitles(self, value): self.ChartTitles.append(value)
    def insert_ChartTitles(self, index, value): self.ChartTitles[index] = value
    def get_DynamicHeight(self): return self.DynamicHeight
    def set_DynamicHeight(self, DynamicHeight): self.DynamicHeight = DynamicHeight
    def add_DynamicHeight(self, value): self.DynamicHeight.append(value)
    def insert_DynamicHeight(self, index, value): self.DynamicHeight[index] = value
    def get_DynamicWidth(self): return self.DynamicWidth
    def set_DynamicWidth(self, DynamicWidth): self.DynamicWidth = DynamicWidth
    def add_DynamicWidth(self, value): self.DynamicWidth.append(value)
    def insert_DynamicWidth(self, index, value): self.DynamicWidth[index] = value
    def get_Palette(self): return self.Palette
    def set_Palette(self, Palette): self.Palette = Palette
    def add_Palette(self, value): self.Palette.append(value)
    def insert_Palette(self, index, value): self.Palette[index] = value
    def get_ChartCustomPaletteColors(self): return self.ChartCustomPaletteColors
    def set_ChartCustomPaletteColors(self, ChartCustomPaletteColors): self.ChartCustomPaletteColors = ChartCustomPaletteColors
    def add_ChartCustomPaletteColors(self, value): self.ChartCustomPaletteColors.append(value)
    def insert_ChartCustomPaletteColors(self, index, value): self.ChartCustomPaletteColors[index] = value
    def get_PaletteHatchBehavior(self): return self.PaletteHatchBehavior
    def set_PaletteHatchBehavior(self, PaletteHatchBehavior): self.PaletteHatchBehavior = PaletteHatchBehavior
    def add_PaletteHatchBehavior(self, value): self.PaletteHatchBehavior.append(value)
    def insert_PaletteHatchBehavior(self, index, value): self.PaletteHatchBehavior[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_ChartBorderSkin(self): return self.ChartBorderSkin
    def set_ChartBorderSkin(self, ChartBorderSkin): self.ChartBorderSkin = ChartBorderSkin
    def add_ChartBorderSkin(self, value): self.ChartBorderSkin.append(value)
    def insert_ChartBorderSkin(self, index, value): self.ChartBorderSkin[index] = value
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code(self, index, value): self.Code[index] = value
    def get_CodeLanguage(self): return self.CodeLanguage
    def set_CodeLanguage(self, CodeLanguage): self.CodeLanguage = CodeLanguage
    def add_CodeLanguage(self, value): self.CodeLanguage.append(value)
    def insert_CodeLanguage(self, index, value): self.CodeLanguage[index] = value
    def get_ChartCodeParameters(self): return self.ChartCodeParameters
    def set_ChartCodeParameters(self, ChartCodeParameters): self.ChartCodeParameters = ChartCodeParameters
    def add_ChartCodeParameters(self, value): self.ChartCodeParameters.append(value)
    def insert_ChartCodeParameters(self, index, value): self.ChartCodeParameters[index] = value
    def get_ChartAnnotations(self): return self.ChartAnnotations
    def set_ChartAnnotations(self, ChartAnnotations): self.ChartAnnotations = ChartAnnotations
    def add_ChartAnnotations(self, value): self.ChartAnnotations.append(value)
    def insert_ChartAnnotations(self, index, value): self.ChartAnnotations[index] = value
    def get_ChartNoDataMessage(self): return self.ChartNoDataMessage
    def set_ChartNoDataMessage(self, ChartNoDataMessage): self.ChartNoDataMessage = ChartNoDataMessage
    def add_ChartNoDataMessage(self, value): self.ChartNoDataMessage.append(value)
    def insert_ChartNoDataMessage(self, index, value): self.ChartNoDataMessage[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for SortExpressions_ in self.SortExpressions:
            SortExpressions_.export(outfile, level, namespace_, name_='SortExpressions')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('<%sNoRowsMessage>%s</%sNoRowsMessage>\n' % (namespace_, self.gds_format_string(quote_xml(NoRowsMessage_).encode(ExternalEncoding), input_name='NoRowsMessage'), namespace_))
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('<%sDataSetName>%s</%sDataSetName>\n' % (namespace_, self.gds_format_string(quote_xml(DataSetName_).encode(ExternalEncoding), input_name='DataSetName'), namespace_))
        for PageBreak_ in self.PageBreak:
            PageBreak_.export(outfile, level, namespace_, name_='PageBreak')
        for Filters_ in self.Filters:
            Filters_.export(outfile, level, namespace_, name_='Filters')
        for ChartSeriesHierarchy_ in self.ChartSeriesHierarchy:
            ChartSeriesHierarchy_.export(outfile, level, namespace_, name_='ChartSeriesHierarchy')
        for ChartCategoryHierarchy_ in self.ChartCategoryHierarchy:
            ChartCategoryHierarchy_.export(outfile, level, namespace_, name_='ChartCategoryHierarchy')
        for ChartData_ in self.ChartData:
            ChartData_.export(outfile, level, namespace_, name_='ChartData')
        for ChartAreas_ in self.ChartAreas:
            ChartAreas_.export(outfile, level, namespace_, name_='ChartAreas')
        for ChartLegends_ in self.ChartLegends:
            ChartLegends_.export(outfile, level, namespace_, name_='ChartLegends')
        for ChartTitles_ in self.ChartTitles:
            ChartTitles_.export(outfile, level, namespace_, name_='ChartTitles')
        for DynamicHeight_ in self.DynamicHeight:
            showIndent(outfile, level)
            outfile.write('<%sDynamicHeight>%s</%sDynamicHeight>\n' % (namespace_, self.gds_format_string(quote_xml(DynamicHeight_).encode(ExternalEncoding), input_name='DynamicHeight'), namespace_))
        for DynamicWidth_ in self.DynamicWidth:
            showIndent(outfile, level)
            outfile.write('<%sDynamicWidth>%s</%sDynamicWidth>\n' % (namespace_, self.gds_format_string(quote_xml(DynamicWidth_).encode(ExternalEncoding), input_name='DynamicWidth'), namespace_))
        for Palette_ in self.Palette:
            showIndent(outfile, level)
            outfile.write('<%sPalette>%s</%sPalette>\n' % (namespace_, self.gds_format_string(quote_xml(Palette_).encode(ExternalEncoding), input_name='Palette'), namespace_))
        for ChartCustomPaletteColors_ in self.ChartCustomPaletteColors:
            ChartCustomPaletteColors_.export(outfile, level, namespace_, name_='ChartCustomPaletteColors')
        for PaletteHatchBehavior_ in self.PaletteHatchBehavior:
            showIndent(outfile, level)
            outfile.write('<%sPaletteHatchBehavior>%s</%sPaletteHatchBehavior>\n' % (namespace_, self.gds_format_string(quote_xml(PaletteHatchBehavior_).encode(ExternalEncoding), input_name='PaletteHatchBehavior'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
        for ChartBorderSkin_ in self.ChartBorderSkin:
            ChartBorderSkin_.export(outfile, level, namespace_, name_='ChartBorderSkin')
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('<%sCode>%s</%sCode>\n' % (namespace_, self.gds_format_string(quote_xml(Code_).encode(ExternalEncoding), input_name='Code'), namespace_))
        for CodeLanguage_ in self.CodeLanguage:
            showIndent(outfile, level)
            outfile.write('<%sCodeLanguage>%s</%sCodeLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(CodeLanguage_).encode(ExternalEncoding), input_name='CodeLanguage'), namespace_))
        for ChartCodeParameters_ in self.ChartCodeParameters:
            ChartCodeParameters_.export(outfile, level, namespace_, name_='ChartCodeParameters')
        for ChartAnnotations_ in self.ChartAnnotations:
            ChartAnnotations_.export(outfile, level, namespace_, name_='ChartAnnotations')
        for ChartNoDataMessage_ in self.ChartNoDataMessage:
            ChartNoDataMessage_.export(outfile, level, namespace_, name_='ChartNoDataMessage')
    def hasContent_(self):
        if (
            self.Style or
            self.SortExpressions or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.NoRowsMessage or
            self.DataSetName or
            self.PageBreak or
            self.Filters or
            self.ChartSeriesHierarchy or
            self.ChartCategoryHierarchy or
            self.ChartData or
            self.ChartAreas or
            self.ChartLegends or
            self.ChartTitles or
            self.DynamicHeight or
            self.DynamicWidth or
            self.Palette or
            self.ChartCustomPaletteColors or
            self.PaletteHatchBehavior or
            self.DataElementName or
            self.DataElementOutput or
            self.ChartBorderSkin or
            self.Code or
            self.CodeLanguage or
            self.ChartCodeParameters or
            self.ChartAnnotations or
            self.ChartNoDataMessage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressions=[\n')
        level += 1
        for SortExpressions_ in self.SortExpressions:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionsType(\n')
            SortExpressions_.exportLiteral(outfile, level, name_='SortExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NoRowsMessage=[\n')
        level += 1
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NoRowsMessage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSetName=[\n')
        level += 1
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSetName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageBreak=[\n')
        level += 1
        for PageBreak_ in self.PageBreak:
            showIndent(outfile, level)
            outfile.write('model_.PageBreakType(\n')
            PageBreak_.exportLiteral(outfile, level, name_='PageBreakType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Filters=[\n')
        level += 1
        for Filters_ in self.Filters:
            showIndent(outfile, level)
            outfile.write('model_.FiltersType(\n')
            Filters_.exportLiteral(outfile, level, name_='FiltersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartSeriesHierarchy=[\n')
        level += 1
        for ChartSeriesHierarchy_ in self.ChartSeriesHierarchy:
            showIndent(outfile, level)
            outfile.write('model_.ChartHierarchyType(\n')
            ChartSeriesHierarchy_.exportLiteral(outfile, level, name_='ChartHierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartCategoryHierarchy=[\n')
        level += 1
        for ChartCategoryHierarchy_ in self.ChartCategoryHierarchy:
            showIndent(outfile, level)
            outfile.write('model_.ChartHierarchyType(\n')
            ChartCategoryHierarchy_.exportLiteral(outfile, level, name_='ChartHierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartData=[\n')
        level += 1
        for ChartData_ in self.ChartData:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataType(\n')
            ChartData_.exportLiteral(outfile, level, name_='ChartDataType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartAreas=[\n')
        level += 1
        for ChartAreas_ in self.ChartAreas:
            showIndent(outfile, level)
            outfile.write('model_.ChartAreasType(\n')
            ChartAreas_.exportLiteral(outfile, level, name_='ChartAreasType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartLegends=[\n')
        level += 1
        for ChartLegends_ in self.ChartLegends:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendsType(\n')
            ChartLegends_.exportLiteral(outfile, level, name_='ChartLegendsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartTitles=[\n')
        level += 1
        for ChartTitles_ in self.ChartTitles:
            showIndent(outfile, level)
            outfile.write('model_.ChartTitlesType(\n')
            ChartTitles_.exportLiteral(outfile, level, name_='ChartTitlesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DynamicHeight=[\n')
        level += 1
        for DynamicHeight_ in self.DynamicHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DynamicHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DynamicWidth=[\n')
        level += 1
        for DynamicWidth_ in self.DynamicWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DynamicWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Palette=[\n')
        level += 1
        for Palette_ in self.Palette:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Palette_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartCustomPaletteColors=[\n')
        level += 1
        for ChartCustomPaletteColors_ in self.ChartCustomPaletteColors:
            showIndent(outfile, level)
            outfile.write('model_.ChartCustomPaletteColorsType(\n')
            ChartCustomPaletteColors_.exportLiteral(outfile, level, name_='ChartCustomPaletteColorsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaletteHatchBehavior=[\n')
        level += 1
        for PaletteHatchBehavior_ in self.PaletteHatchBehavior:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PaletteHatchBehavior_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartBorderSkin=[\n')
        level += 1
        for ChartBorderSkin_ in self.ChartBorderSkin:
            showIndent(outfile, level)
            outfile.write('model_.ChartBorderSkinType(\n')
            ChartBorderSkin_.exportLiteral(outfile, level, name_='ChartBorderSkinType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodeLanguage=[\n')
        level += 1
        for CodeLanguage_ in self.CodeLanguage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CodeLanguage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartCodeParameters=[\n')
        level += 1
        for ChartCodeParameters_ in self.ChartCodeParameters:
            showIndent(outfile, level)
            outfile.write('model_.ChartCodeParametersType(\n')
            ChartCodeParameters_.exportLiteral(outfile, level, name_='ChartCodeParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartAnnotations=[\n')
        level += 1
        for ChartAnnotations_ in self.ChartAnnotations:
            showIndent(outfile, level)
            outfile.write('model_.ChartAnnotationsType(\n')
            ChartAnnotations_.exportLiteral(outfile, level, name_='ChartAnnotationsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartNoDataMessage=[\n')
        level += 1
        for ChartNoDataMessage_ in self.ChartNoDataMessage:
            showIndent(outfile, level)
            outfile.write('model_.ChartTitleType(\n')
            ChartNoDataMessage_.exportLiteral(outfile, level, name_='ChartTitleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.SortExpressions.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'NoRowsMessage':
            NoRowsMessage_ = child_.text
            NoRowsMessage_ = self.gds_validate_string(NoRowsMessage_, node, 'NoRowsMessage')
            self.NoRowsMessage.append(NoRowsMessage_)
        elif nodeName_ == 'DataSetName':
            DataSetName_ = child_.text
            DataSetName_ = self.gds_validate_string(DataSetName_, node, 'DataSetName')
            self.DataSetName.append(DataSetName_)
        elif nodeName_ == 'PageBreak':
            obj_ = PageBreakType.factory()
            obj_.build(child_)
            self.PageBreak.append(obj_)
        elif nodeName_ == 'Filters':
            obj_ = FiltersType.factory()
            obj_.build(child_)
            self.Filters.append(obj_)
        elif nodeName_ == 'ChartSeriesHierarchy':
            obj_ = ChartHierarchyType.factory()
            obj_.build(child_)
            self.ChartSeriesHierarchy.append(obj_)
        elif nodeName_ == 'ChartCategoryHierarchy':
            obj_ = ChartHierarchyType.factory()
            obj_.build(child_)
            self.ChartCategoryHierarchy.append(obj_)
        elif nodeName_ == 'ChartData':
            obj_ = ChartDataType.factory()
            obj_.build(child_)
            self.ChartData.append(obj_)
        elif nodeName_ == 'ChartAreas':
            obj_ = ChartAreasType.factory()
            obj_.build(child_)
            self.ChartAreas.append(obj_)
        elif nodeName_ == 'ChartLegends':
            obj_ = ChartLegendsType.factory()
            obj_.build(child_)
            self.ChartLegends.append(obj_)
        elif nodeName_ == 'ChartTitles':
            obj_ = ChartTitlesType.factory()
            obj_.build(child_)
            self.ChartTitles.append(obj_)
        elif nodeName_ == 'DynamicHeight':
            DynamicHeight_ = child_.text
            DynamicHeight_ = self.gds_validate_string(DynamicHeight_, node, 'DynamicHeight')
            self.DynamicHeight.append(DynamicHeight_)
        elif nodeName_ == 'DynamicWidth':
            DynamicWidth_ = child_.text
            DynamicWidth_ = self.gds_validate_string(DynamicWidth_, node, 'DynamicWidth')
            self.DynamicWidth.append(DynamicWidth_)
        elif nodeName_ == 'Palette':
            Palette_ = child_.text
            Palette_ = self.gds_validate_string(Palette_, node, 'Palette')
            self.Palette.append(Palette_)
        elif nodeName_ == 'ChartCustomPaletteColors':
            obj_ = ChartCustomPaletteColorsType.factory()
            obj_.build(child_)
            self.ChartCustomPaletteColors.append(obj_)
        elif nodeName_ == 'PaletteHatchBehavior':
            PaletteHatchBehavior_ = child_.text
            PaletteHatchBehavior_ = self.gds_validate_string(PaletteHatchBehavior_, node, 'PaletteHatchBehavior')
            self.PaletteHatchBehavior.append(PaletteHatchBehavior_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
        elif nodeName_ == 'ChartBorderSkin':
            obj_ = ChartBorderSkinType.factory()
            obj_.build(child_)
            self.ChartBorderSkin.append(obj_)
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code.append(Code_)
        elif nodeName_ == 'CodeLanguage':
            CodeLanguage_ = child_.text
            CodeLanguage_ = self.gds_validate_string(CodeLanguage_, node, 'CodeLanguage')
            self.CodeLanguage.append(CodeLanguage_)
        elif nodeName_ == 'ChartCodeParameters':
            obj_ = ChartCodeParametersType.factory()
            obj_.build(child_)
            self.ChartCodeParameters.append(obj_)
        elif nodeName_ == 'ChartAnnotations':
            obj_ = ChartAnnotationsType.factory()
            obj_.build(child_)
            self.ChartAnnotations.append(obj_)
        elif nodeName_ == 'ChartNoDataMessage':
            obj_ = ChartTitleType.factory()
            obj_.build(child_)
            self.ChartNoDataMessage.append(obj_)
# end class ChartType


class CodeLanguage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if CodeLanguage.subclass:
            return CodeLanguage.subclass(*args_, **kwargs_)
        else:
            return CodeLanguage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CodeLanguage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeLanguage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CodeLanguage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CodeLanguage', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CodeLanguage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodeLanguage


class ChartHierarchyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartMembers=None):
        self.ChartMembers = ChartMembers
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartHierarchyType.subclass:
            return ChartHierarchyType.subclass(*args_, **kwargs_)
        else:
            return ChartHierarchyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartMembers(self): return self.ChartMembers
    def set_ChartMembers(self, ChartMembers): self.ChartMembers = ChartMembers
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartHierarchyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartHierarchyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartHierarchyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartHierarchyType', fromsubclass_=False):
        if self.ChartMembers:
            self.ChartMembers.export(outfile, level, namespace_, name_='ChartMembers', )
    def hasContent_(self):
        if (
            self.ChartMembers is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartHierarchyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ChartMembers is not None:
            showIndent(outfile, level)
            outfile.write('ChartMembers=model_.ChartMembersType(\n')
            self.ChartMembers.exportLiteral(outfile, level, name_='ChartMembers')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartMembers':
            obj_ = ChartMembersType.factory()
            obj_.build(child_)
            self.set_ChartMembers(obj_)
# end class ChartHierarchyType


class ChartMembersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartMember=None):
        if ChartMember is None:
            self.ChartMember = []
        else:
            self.ChartMember = ChartMember
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartMembersType.subclass:
            return ChartMembersType.subclass(*args_, **kwargs_)
        else:
            return ChartMembersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartMember(self): return self.ChartMember
    def set_ChartMember(self, ChartMember): self.ChartMember = ChartMember
    def add_ChartMember(self, value): self.ChartMember.append(value)
    def insert_ChartMember(self, index, value): self.ChartMember[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartMembersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartMembersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartMembersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartMembersType', fromsubclass_=False):
        for ChartMember_ in self.ChartMember:
            ChartMember_.export(outfile, level, namespace_, name_='ChartMember')
    def hasContent_(self):
        if (
            self.ChartMember
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartMembersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartMember=[\n')
        level += 1
        for ChartMember_ in self.ChartMember:
            showIndent(outfile, level)
            outfile.write('model_.ChartMemberType(\n')
            ChartMember_.exportLiteral(outfile, level, name_='ChartMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartMember':
            obj_ = ChartMemberType.factory()
            obj_.build(child_)
            self.ChartMember.append(obj_)
# end class ChartMembersType


class ChartMemberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None, SortExpressions=None, ChartMembers=None, Label=None, CustomProperties=None, DataElementName=None, DataElementOutput=None):
        self.Group = Group
        self.SortExpressions = SortExpressions
        self.ChartMembers = ChartMembers
        self.Label = Label
        self.CustomProperties = CustomProperties
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartMemberType.subclass:
            return ChartMemberType.subclass(*args_, **kwargs_)
        else:
            return ChartMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def get_ChartMembers(self): return self.ChartMembers
    def set_ChartMembers(self, ChartMembers): self.ChartMembers = ChartMembers
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartMemberType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartMemberType', fromsubclass_=False):
        if self.Group:
            self.Group.export(outfile, level, namespace_, name_='Group')
        if self.SortExpressions:
            self.SortExpressions.export(outfile, level, namespace_, name_='SortExpressions')
        if self.ChartMembers:
            self.ChartMembers.export(outfile, level, namespace_, name_='ChartMembers')
        if self.Label:
            self.Label.export(outfile, level, namespace_, name_='Label', )
        if self.CustomProperties:
            self.CustomProperties.export(outfile, level, namespace_, name_='CustomProperties')
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        if self.DataElementOutput is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataElementOutput).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Group is not None or
            self.SortExpressions is not None or
            self.ChartMembers is not None or
            self.Label is not None or
            self.CustomProperties is not None or
            self.DataElementName or
            self.DataElementOutput is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Group is not None:
            showIndent(outfile, level)
            outfile.write('Group=model_.GroupType(\n')
            self.Group.exportLiteral(outfile, level, name_='Group')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SortExpressions is not None:
            showIndent(outfile, level)
            outfile.write('SortExpressions=model_.SortExpressionsType(\n')
            self.SortExpressions.exportLiteral(outfile, level, name_='SortExpressions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ChartMembers is not None:
            showIndent(outfile, level)
            outfile.write('ChartMembers=model_.ChartMembersType(\n')
            self.ChartMembers.exportLiteral(outfile, level, name_='ChartMembers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=model_.StringLocIDType(\n')
            self.Label.exportLiteral(outfile, level, name_='Label')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CustomProperties is not None:
            showIndent(outfile, level)
            outfile.write('CustomProperties=model_.CustomPropertiesType(\n')
            self.CustomProperties.exportLiteral(outfile, level, name_='CustomProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DataElementOutput is not None:
            showIndent(outfile, level)
            outfile.write('DataElementOutput=%s,\n' % quote_python(self.DataElementOutput).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = GroupType.factory()
            obj_.build(child_)
            self.set_Group(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.set_SortExpressions(obj_)
        elif nodeName_ == 'ChartMembers':
            obj_ = ChartMembersType.factory()
            obj_.build(child_)
            self.set_ChartMembers(obj_)
        elif nodeName_ == 'Label':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.set_Label(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.set_CustomProperties(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput = DataElementOutput_
# end class ChartMemberType


class ChartAreasType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartArea=None):
        if ChartArea is None:
            self.ChartArea = []
        else:
            self.ChartArea = ChartArea
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAreasType.subclass:
            return ChartAreasType.subclass(*args_, **kwargs_)
        else:
            return ChartAreasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartArea(self): return self.ChartArea
    def set_ChartArea(self, ChartArea): self.ChartArea = ChartArea
    def add_ChartArea(self, value): self.ChartArea.append(value)
    def insert_ChartArea(self, index, value): self.ChartArea[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAreasType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAreasType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAreasType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAreasType', fromsubclass_=False):
        for ChartArea_ in self.ChartArea:
            ChartArea_.export(outfile, level, namespace_, name_='ChartArea')
    def hasContent_(self):
        if (
            self.ChartArea
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAreasType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartArea=[\n')
        level += 1
        for ChartArea_ in self.ChartArea:
            showIndent(outfile, level)
            outfile.write('model_.ChartAreaType(\n')
            ChartArea_.exportLiteral(outfile, level, name_='ChartAreaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartArea':
            obj_ = ChartAreaType.factory()
            obj_.build(child_)
            self.ChartArea.append(obj_)
# end class ChartAreasType


class ChartAreaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Hidden=None, ChartCategoryAxes=None, ChartValueAxes=None, ChartThreeDProperties=None, Style=None, AlignOrientation=None, ChartAlignType=None, ChartElementPosition=None, ChartInnerPlotPosition=None, AlignWithChartArea=None, EquallySizedAxesFont=None):
        self.Name = _cast(None, Name)
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ChartCategoryAxes is None:
            self.ChartCategoryAxes = []
        else:
            self.ChartCategoryAxes = ChartCategoryAxes
        if ChartValueAxes is None:
            self.ChartValueAxes = []
        else:
            self.ChartValueAxes = ChartValueAxes
        if ChartThreeDProperties is None:
            self.ChartThreeDProperties = []
        else:
            self.ChartThreeDProperties = ChartThreeDProperties
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if AlignOrientation is None:
            self.AlignOrientation = []
        else:
            self.AlignOrientation = AlignOrientation
        if ChartAlignType is None:
            self.ChartAlignType = []
        else:
            self.ChartAlignType = ChartAlignType
        if ChartElementPosition is None:
            self.ChartElementPosition = []
        else:
            self.ChartElementPosition = ChartElementPosition
        if ChartInnerPlotPosition is None:
            self.ChartInnerPlotPosition = []
        else:
            self.ChartInnerPlotPosition = ChartInnerPlotPosition
        if AlignWithChartArea is None:
            self.AlignWithChartArea = []
        else:
            self.AlignWithChartArea = AlignWithChartArea
        if EquallySizedAxesFont is None:
            self.EquallySizedAxesFont = []
        else:
            self.EquallySizedAxesFont = EquallySizedAxesFont
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAreaType.subclass:
            return ChartAreaType.subclass(*args_, **kwargs_)
        else:
            return ChartAreaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ChartCategoryAxes(self): return self.ChartCategoryAxes
    def set_ChartCategoryAxes(self, ChartCategoryAxes): self.ChartCategoryAxes = ChartCategoryAxes
    def add_ChartCategoryAxes(self, value): self.ChartCategoryAxes.append(value)
    def insert_ChartCategoryAxes(self, index, value): self.ChartCategoryAxes[index] = value
    def get_ChartValueAxes(self): return self.ChartValueAxes
    def set_ChartValueAxes(self, ChartValueAxes): self.ChartValueAxes = ChartValueAxes
    def add_ChartValueAxes(self, value): self.ChartValueAxes.append(value)
    def insert_ChartValueAxes(self, index, value): self.ChartValueAxes[index] = value
    def get_ChartThreeDProperties(self): return self.ChartThreeDProperties
    def set_ChartThreeDProperties(self, ChartThreeDProperties): self.ChartThreeDProperties = ChartThreeDProperties
    def add_ChartThreeDProperties(self, value): self.ChartThreeDProperties.append(value)
    def insert_ChartThreeDProperties(self, index, value): self.ChartThreeDProperties[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_AlignOrientation(self): return self.AlignOrientation
    def set_AlignOrientation(self, AlignOrientation): self.AlignOrientation = AlignOrientation
    def add_AlignOrientation(self, value): self.AlignOrientation.append(value)
    def insert_AlignOrientation(self, index, value): self.AlignOrientation[index] = value
    def get_ChartAlignType(self): return self.ChartAlignType
    def set_ChartAlignType(self, ChartAlignType): self.ChartAlignType = ChartAlignType
    def add_ChartAlignType(self, value): self.ChartAlignType.append(value)
    def insert_ChartAlignType(self, index, value): self.ChartAlignType[index] = value
    def get_ChartElementPosition(self): return self.ChartElementPosition
    def set_ChartElementPosition(self, ChartElementPosition): self.ChartElementPosition = ChartElementPosition
    def add_ChartElementPosition(self, value): self.ChartElementPosition.append(value)
    def insert_ChartElementPosition(self, index, value): self.ChartElementPosition[index] = value
    def get_ChartInnerPlotPosition(self): return self.ChartInnerPlotPosition
    def set_ChartInnerPlotPosition(self, ChartInnerPlotPosition): self.ChartInnerPlotPosition = ChartInnerPlotPosition
    def add_ChartInnerPlotPosition(self, value): self.ChartInnerPlotPosition.append(value)
    def insert_ChartInnerPlotPosition(self, index, value): self.ChartInnerPlotPosition[index] = value
    def get_AlignWithChartArea(self): return self.AlignWithChartArea
    def set_AlignWithChartArea(self, AlignWithChartArea): self.AlignWithChartArea = AlignWithChartArea
    def add_AlignWithChartArea(self, value): self.AlignWithChartArea.append(value)
    def insert_AlignWithChartArea(self, index, value): self.AlignWithChartArea[index] = value
    def get_EquallySizedAxesFont(self): return self.EquallySizedAxesFont
    def set_EquallySizedAxesFont(self, EquallySizedAxesFont): self.EquallySizedAxesFont = EquallySizedAxesFont
    def add_EquallySizedAxesFont(self, value): self.EquallySizedAxesFont.append(value)
    def insert_EquallySizedAxesFont(self, index, value): self.EquallySizedAxesFont[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAreaType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAreaType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAreaType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAreaType', fromsubclass_=False):
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ChartCategoryAxes_ in self.ChartCategoryAxes:
            ChartCategoryAxes_.export(outfile, level, namespace_, name_='ChartCategoryAxes')
        for ChartValueAxes_ in self.ChartValueAxes:
            ChartValueAxes_.export(outfile, level, namespace_, name_='ChartValueAxes')
        for ChartThreeDProperties_ in self.ChartThreeDProperties:
            ChartThreeDProperties_.export(outfile, level, namespace_, name_='ChartThreeDProperties')
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for AlignOrientation_ in self.AlignOrientation:
            showIndent(outfile, level)
            outfile.write('<%sAlignOrientation>%s</%sAlignOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(AlignOrientation_).encode(ExternalEncoding), input_name='AlignOrientation'), namespace_))
        for ChartAlignType_ in self.ChartAlignType:
            ChartAlignType_.export(outfile, level, namespace_, name_='ChartAlignType')
        for ChartElementPosition_ in self.ChartElementPosition:
            ChartElementPosition_.export(outfile, level, namespace_, name_='ChartElementPosition')
        for ChartInnerPlotPosition_ in self.ChartInnerPlotPosition:
            ChartInnerPlotPosition_.export(outfile, level, namespace_, name_='ChartInnerPlotPosition')
        for AlignWithChartArea_ in self.AlignWithChartArea:
            showIndent(outfile, level)
            outfile.write('<%sAlignWithChartArea>%s</%sAlignWithChartArea>\n' % (namespace_, self.gds_format_string(quote_xml(AlignWithChartArea_).encode(ExternalEncoding), input_name='AlignWithChartArea'), namespace_))
        for EquallySizedAxesFont_ in self.EquallySizedAxesFont:
            showIndent(outfile, level)
            outfile.write('<%sEquallySizedAxesFont>%s</%sEquallySizedAxesFont>\n' % (namespace_, self.gds_format_string(quote_xml(EquallySizedAxesFont_).encode(ExternalEncoding), input_name='EquallySizedAxesFont'), namespace_))
    def hasContent_(self):
        if (
            self.Hidden or
            self.ChartCategoryAxes or
            self.ChartValueAxes or
            self.ChartThreeDProperties or
            self.Style or
            self.AlignOrientation or
            self.ChartAlignType or
            self.ChartElementPosition or
            self.ChartInnerPlotPosition or
            self.AlignWithChartArea or
            self.EquallySizedAxesFont
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAreaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartCategoryAxes=[\n')
        level += 1
        for ChartCategoryAxes_ in self.ChartCategoryAxes:
            showIndent(outfile, level)
            outfile.write('model_.ChartCategoryAxesType(\n')
            ChartCategoryAxes_.exportLiteral(outfile, level, name_='ChartCategoryAxesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartValueAxes=[\n')
        level += 1
        for ChartValueAxes_ in self.ChartValueAxes:
            showIndent(outfile, level)
            outfile.write('model_.ChartValueAxesType(\n')
            ChartValueAxes_.exportLiteral(outfile, level, name_='ChartValueAxesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartThreeDProperties=[\n')
        level += 1
        for ChartThreeDProperties_ in self.ChartThreeDProperties:
            showIndent(outfile, level)
            outfile.write('model_.ChartThreeDPropertiesType(\n')
            ChartThreeDProperties_.exportLiteral(outfile, level, name_='ChartThreeDPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AlignOrientation=[\n')
        level += 1
        for AlignOrientation_ in self.AlignOrientation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AlignOrientation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartAlignType=[\n')
        level += 1
        for ChartAlignType_ in self.ChartAlignType:
            showIndent(outfile, level)
            outfile.write('model_.ChartAlignTypeType(\n')
            ChartAlignType_.exportLiteral(outfile, level, name_='ChartAlignTypeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartElementPosition=[\n')
        level += 1
        for ChartElementPosition_ in self.ChartElementPosition:
            showIndent(outfile, level)
            outfile.write('model_.ChartElementPositionType(\n')
            ChartElementPosition_.exportLiteral(outfile, level, name_='ChartElementPositionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartInnerPlotPosition=[\n')
        level += 1
        for ChartInnerPlotPosition_ in self.ChartInnerPlotPosition:
            showIndent(outfile, level)
            outfile.write('model_.ChartElementPositionType(\n')
            ChartInnerPlotPosition_.exportLiteral(outfile, level, name_='ChartElementPositionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AlignWithChartArea=[\n')
        level += 1
        for AlignWithChartArea_ in self.AlignWithChartArea:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AlignWithChartArea_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EquallySizedAxesFont=[\n')
        level += 1
        for EquallySizedAxesFont_ in self.EquallySizedAxesFont:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EquallySizedAxesFont_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ChartCategoryAxes':
            obj_ = ChartCategoryAxesType.factory()
            obj_.build(child_)
            self.ChartCategoryAxes.append(obj_)
        elif nodeName_ == 'ChartValueAxes':
            obj_ = ChartValueAxesType.factory()
            obj_.build(child_)
            self.ChartValueAxes.append(obj_)
        elif nodeName_ == 'ChartThreeDProperties':
            obj_ = ChartThreeDPropertiesType.factory()
            obj_.build(child_)
            self.ChartThreeDProperties.append(obj_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'AlignOrientation':
            AlignOrientation_ = child_.text
            AlignOrientation_ = self.gds_validate_string(AlignOrientation_, node, 'AlignOrientation')
            self.AlignOrientation.append(AlignOrientation_)
        elif nodeName_ == 'ChartAlignType':
            obj_ = ChartAlignTypeType.factory()
            obj_.build(child_)
            self.ChartAlignType.append(obj_)
        elif nodeName_ == 'ChartElementPosition':
            obj_ = ChartElementPositionType.factory()
            obj_.build(child_)
            self.ChartElementPosition.append(obj_)
        elif nodeName_ == 'ChartInnerPlotPosition':
            obj_ = ChartElementPositionType.factory()
            obj_.build(child_)
            self.ChartInnerPlotPosition.append(obj_)
        elif nodeName_ == 'AlignWithChartArea':
            AlignWithChartArea_ = child_.text
            AlignWithChartArea_ = self.gds_validate_string(AlignWithChartArea_, node, 'AlignWithChartArea')
            self.AlignWithChartArea.append(AlignWithChartArea_)
        elif nodeName_ == 'EquallySizedAxesFont':
            EquallySizedAxesFont_ = child_.text
            EquallySizedAxesFont_ = self.gds_validate_string(EquallySizedAxesFont_, node, 'EquallySizedAxesFont')
            self.EquallySizedAxesFont.append(EquallySizedAxesFont_)
# end class ChartAreaType


class ChartAlignTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AxesView=None, Cursor=None, Position=None, InnerPlotPosition=None):
        if AxesView is None:
            self.AxesView = []
        else:
            self.AxesView = AxesView
        if Cursor is None:
            self.Cursor = []
        else:
            self.Cursor = Cursor
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        if InnerPlotPosition is None:
            self.InnerPlotPosition = []
        else:
            self.InnerPlotPosition = InnerPlotPosition
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAlignTypeType.subclass:
            return ChartAlignTypeType.subclass(*args_, **kwargs_)
        else:
            return ChartAlignTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AxesView(self): return self.AxesView
    def set_AxesView(self, AxesView): self.AxesView = AxesView
    def add_AxesView(self, value): self.AxesView.append(value)
    def insert_AxesView(self, index, value): self.AxesView[index] = value
    def get_Cursor(self): return self.Cursor
    def set_Cursor(self, Cursor): self.Cursor = Cursor
    def add_Cursor(self, value): self.Cursor.append(value)
    def insert_Cursor(self, index, value): self.Cursor[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_InnerPlotPosition(self): return self.InnerPlotPosition
    def set_InnerPlotPosition(self, InnerPlotPosition): self.InnerPlotPosition = InnerPlotPosition
    def add_InnerPlotPosition(self, value): self.InnerPlotPosition.append(value)
    def insert_InnerPlotPosition(self, index, value): self.InnerPlotPosition[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAlignTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAlignTypeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAlignTypeType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAlignTypeType', fromsubclass_=False):
        for AxesView_ in self.AxesView:
            showIndent(outfile, level)
            outfile.write('<%sAxesView>%s</%sAxesView>\n' % (namespace_, self.gds_format_string(quote_xml(AxesView_).encode(ExternalEncoding), input_name='AxesView'), namespace_))
        for Cursor_ in self.Cursor:
            showIndent(outfile, level)
            outfile.write('<%sCursor>%s</%sCursor>\n' % (namespace_, self.gds_format_string(quote_xml(Cursor_).encode(ExternalEncoding), input_name='Cursor'), namespace_))
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
        for InnerPlotPosition_ in self.InnerPlotPosition:
            showIndent(outfile, level)
            outfile.write('<%sInnerPlotPosition>%s</%sInnerPlotPosition>\n' % (namespace_, self.gds_format_string(quote_xml(InnerPlotPosition_).encode(ExternalEncoding), input_name='InnerPlotPosition'), namespace_))
    def hasContent_(self):
        if (
            self.AxesView or
            self.Cursor or
            self.Position or
            self.InnerPlotPosition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAlignTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AxesView=[\n')
        level += 1
        for AxesView_ in self.AxesView:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AxesView_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Cursor=[\n')
        level += 1
        for Cursor_ in self.Cursor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Cursor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InnerPlotPosition=[\n')
        level += 1
        for InnerPlotPosition_ in self.InnerPlotPosition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InnerPlotPosition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AxesView':
            AxesView_ = child_.text
            AxesView_ = self.gds_validate_string(AxesView_, node, 'AxesView')
            self.AxesView.append(AxesView_)
        elif nodeName_ == 'Cursor':
            Cursor_ = child_.text
            Cursor_ = self.gds_validate_string(Cursor_, node, 'Cursor')
            self.Cursor.append(Cursor_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
        elif nodeName_ == 'InnerPlotPosition':
            InnerPlotPosition_ = child_.text
            InnerPlotPosition_ = self.gds_validate_string(InnerPlotPosition_, node, 'InnerPlotPosition')
            self.InnerPlotPosition.append(InnerPlotPosition_)
# end class ChartAlignTypeType


class ChartElementPositionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Top=None, Left=None, Height=None, Width=None):
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartElementPositionType.subclass:
            return ChartElementPositionType.subclass(*args_, **kwargs_)
        else:
            return ChartElementPositionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartElementPositionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartElementPositionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartElementPositionType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartElementPositionType', fromsubclass_=False):
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
    def hasContent_(self):
        if (
            self.Top or
            self.Left or
            self.Height or
            self.Width
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartElementPositionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
# end class ChartElementPositionType


class ChartTitlesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartTitle=None):
        if ChartTitle is None:
            self.ChartTitle = []
        else:
            self.ChartTitle = ChartTitle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartTitlesType.subclass:
            return ChartTitlesType.subclass(*args_, **kwargs_)
        else:
            return ChartTitlesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartTitle(self): return self.ChartTitle
    def set_ChartTitle(self, ChartTitle): self.ChartTitle = ChartTitle
    def add_ChartTitle(self, value): self.ChartTitle.append(value)
    def insert_ChartTitle(self, index, value): self.ChartTitle[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartTitlesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartTitlesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartTitlesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartTitlesType', fromsubclass_=False):
        for ChartTitle_ in self.ChartTitle:
            ChartTitle_.export(outfile, level, namespace_, name_='ChartTitle')
    def hasContent_(self):
        if (
            self.ChartTitle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartTitlesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartTitle=[\n')
        level += 1
        for ChartTitle_ in self.ChartTitle:
            showIndent(outfile, level)
            outfile.write('model_.ChartTitleType(\n')
            ChartTitle_.exportLiteral(outfile, level, name_='ChartTitleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartTitle':
            obj_ = ChartTitleType.factory()
            obj_.build(child_)
            self.ChartTitle.append(obj_)
# end class ChartTitlesType


class ChartTitleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Caption=None, Hidden=None, Style=None, Position=None, DockToChartArea=None, DockOutsideChartArea=None, DockOffset=None, ChartElementPosition=None, ToolTip=None, ActionInfo=None, TextOrientation=None):
        self.Name = _cast(None, Name)
        if Caption is None:
            self.Caption = []
        else:
            self.Caption = Caption
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        if DockToChartArea is None:
            self.DockToChartArea = []
        else:
            self.DockToChartArea = DockToChartArea
        if DockOutsideChartArea is None:
            self.DockOutsideChartArea = []
        else:
            self.DockOutsideChartArea = DockOutsideChartArea
        if DockOffset is None:
            self.DockOffset = []
        else:
            self.DockOffset = DockOffset
        if ChartElementPosition is None:
            self.ChartElementPosition = []
        else:
            self.ChartElementPosition = ChartElementPosition
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if TextOrientation is None:
            self.TextOrientation = []
        else:
            self.TextOrientation = TextOrientation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartTitleType.subclass:
            return ChartTitleType.subclass(*args_, **kwargs_)
        else:
            return ChartTitleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def add_Caption(self, value): self.Caption.append(value)
    def insert_Caption(self, index, value): self.Caption[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_DockToChartArea(self): return self.DockToChartArea
    def set_DockToChartArea(self, DockToChartArea): self.DockToChartArea = DockToChartArea
    def add_DockToChartArea(self, value): self.DockToChartArea.append(value)
    def insert_DockToChartArea(self, index, value): self.DockToChartArea[index] = value
    def get_DockOutsideChartArea(self): return self.DockOutsideChartArea
    def set_DockOutsideChartArea(self, DockOutsideChartArea): self.DockOutsideChartArea = DockOutsideChartArea
    def add_DockOutsideChartArea(self, value): self.DockOutsideChartArea.append(value)
    def insert_DockOutsideChartArea(self, index, value): self.DockOutsideChartArea[index] = value
    def get_DockOffset(self): return self.DockOffset
    def set_DockOffset(self, DockOffset): self.DockOffset = DockOffset
    def add_DockOffset(self, value): self.DockOffset.append(value)
    def insert_DockOffset(self, index, value): self.DockOffset[index] = value
    def get_ChartElementPosition(self): return self.ChartElementPosition
    def set_ChartElementPosition(self, ChartElementPosition): self.ChartElementPosition = ChartElementPosition
    def add_ChartElementPosition(self, value): self.ChartElementPosition.append(value)
    def insert_ChartElementPosition(self, index, value): self.ChartElementPosition[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_TextOrientation(self): return self.TextOrientation
    def set_TextOrientation(self, TextOrientation): self.TextOrientation = TextOrientation
    def add_TextOrientation(self, value): self.TextOrientation.append(value)
    def insert_TextOrientation(self, index, value): self.TextOrientation[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartTitleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartTitleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartTitleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartTitleType', fromsubclass_=False):
        for Caption_ in self.Caption:
            Caption_.export(outfile, level, namespace_, name_='Caption')
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
        for DockToChartArea_ in self.DockToChartArea:
            showIndent(outfile, level)
            outfile.write('<%sDockToChartArea>%s</%sDockToChartArea>\n' % (namespace_, self.gds_format_string(quote_xml(DockToChartArea_).encode(ExternalEncoding), input_name='DockToChartArea'), namespace_))
        for DockOutsideChartArea_ in self.DockOutsideChartArea:
            showIndent(outfile, level)
            outfile.write('<%sDockOutsideChartArea>%s</%sDockOutsideChartArea>\n' % (namespace_, self.gds_format_string(quote_xml(DockOutsideChartArea_).encode(ExternalEncoding), input_name='DockOutsideChartArea'), namespace_))
        for DockOffset_ in self.DockOffset:
            showIndent(outfile, level)
            outfile.write('<%sDockOffset>%s</%sDockOffset>\n' % (namespace_, self.gds_format_string(quote_xml(DockOffset_).encode(ExternalEncoding), input_name='DockOffset'), namespace_))
        for ChartElementPosition_ in self.ChartElementPosition:
            ChartElementPosition_.export(outfile, level, namespace_, name_='ChartElementPosition')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for TextOrientation_ in self.TextOrientation:
            showIndent(outfile, level)
            outfile.write('<%sTextOrientation>%s</%sTextOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(TextOrientation_).encode(ExternalEncoding), input_name='TextOrientation'), namespace_))
    def hasContent_(self):
        if (
            self.Caption or
            self.Hidden or
            self.Style or
            self.Position or
            self.DockToChartArea or
            self.DockOutsideChartArea or
            self.DockOffset or
            self.ChartElementPosition or
            self.ToolTip or
            self.ActionInfo or
            self.TextOrientation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartTitleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Caption=[\n')
        level += 1
        for Caption_ in self.Caption:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Caption_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DockToChartArea=[\n')
        level += 1
        for DockToChartArea_ in self.DockToChartArea:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DockToChartArea_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DockOutsideChartArea=[\n')
        level += 1
        for DockOutsideChartArea_ in self.DockOutsideChartArea:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DockOutsideChartArea_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DockOffset=[\n')
        level += 1
        for DockOffset_ in self.DockOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DockOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartElementPosition=[\n')
        level += 1
        for ChartElementPosition_ in self.ChartElementPosition:
            showIndent(outfile, level)
            outfile.write('model_.ChartElementPositionType(\n')
            ChartElementPosition_.exportLiteral(outfile, level, name_='ChartElementPositionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextOrientation=[\n')
        level += 1
        for TextOrientation_ in self.TextOrientation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextOrientation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Caption':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Caption.append(obj_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
        elif nodeName_ == 'DockToChartArea':
            DockToChartArea_ = child_.text
            DockToChartArea_ = self.gds_validate_string(DockToChartArea_, node, 'DockToChartArea')
            self.DockToChartArea.append(DockToChartArea_)
        elif nodeName_ == 'DockOutsideChartArea':
            DockOutsideChartArea_ = child_.text
            DockOutsideChartArea_ = self.gds_validate_string(DockOutsideChartArea_, node, 'DockOutsideChartArea')
            self.DockOutsideChartArea.append(DockOutsideChartArea_)
        elif nodeName_ == 'DockOffset':
            DockOffset_ = child_.text
            DockOffset_ = self.gds_validate_string(DockOffset_, node, 'DockOffset')
            self.DockOffset.append(DockOffset_)
        elif nodeName_ == 'ChartElementPosition':
            obj_ = ChartElementPositionType.factory()
            obj_.build(child_)
            self.ChartElementPosition.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'TextOrientation':
            TextOrientation_ = child_.text
            TextOrientation_ = self.gds_validate_string(TextOrientation_, node, 'TextOrientation')
            self.TextOrientation.append(TextOrientation_)
# end class ChartTitleType


class ChartLegendsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartLegend=None):
        if ChartLegend is None:
            self.ChartLegend = []
        else:
            self.ChartLegend = ChartLegend
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendsType.subclass:
            return ChartLegendsType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartLegend(self): return self.ChartLegend
    def set_ChartLegend(self, ChartLegend): self.ChartLegend = ChartLegend
    def add_ChartLegend(self, value): self.ChartLegend.append(value)
    def insert_ChartLegend(self, index, value): self.ChartLegend[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendsType', fromsubclass_=False):
        for ChartLegend_ in self.ChartLegend:
            ChartLegend_.export(outfile, level, namespace_, name_='ChartLegend')
    def hasContent_(self):
        if (
            self.ChartLegend
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartLegend=[\n')
        level += 1
        for ChartLegend_ in self.ChartLegend:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendType(\n')
            ChartLegend_.exportLiteral(outfile, level, name_='ChartLegendType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartLegend':
            obj_ = ChartLegendType.factory()
            obj_.build(child_)
            self.ChartLegend.append(obj_)
# end class ChartLegendsType


class ChartLegendType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Hidden=None, Style=None, Position=None, Layout=None, DockToChartArea=None, DockOutsideChartArea=None, ChartElementPosition=None, ChartLegendTitle=None, AutoFitTextDisabled=None, MinFontSize=None, ChartLegendColumns=None, HeaderSeparator=None, HeaderSeparatorColor=None, ColumnSeparator=None, ColumnSeparatorColor=None, ColumnSpacing=None, InterlacedRows=None, InterlacedRowsColor=None, EquallySpacedItems=None, Reversed=None, MaxAutoSize=None, TextWrapThreshold=None):
        self.Name = _cast(None, Name)
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        if Layout is None:
            self.Layout = []
        else:
            self.Layout = Layout
        if DockToChartArea is None:
            self.DockToChartArea = []
        else:
            self.DockToChartArea = DockToChartArea
        if DockOutsideChartArea is None:
            self.DockOutsideChartArea = []
        else:
            self.DockOutsideChartArea = DockOutsideChartArea
        if ChartElementPosition is None:
            self.ChartElementPosition = []
        else:
            self.ChartElementPosition = ChartElementPosition
        if ChartLegendTitle is None:
            self.ChartLegendTitle = []
        else:
            self.ChartLegendTitle = ChartLegendTitle
        if AutoFitTextDisabled is None:
            self.AutoFitTextDisabled = []
        else:
            self.AutoFitTextDisabled = AutoFitTextDisabled
        if MinFontSize is None:
            self.MinFontSize = []
        else:
            self.MinFontSize = MinFontSize
        if ChartLegendColumns is None:
            self.ChartLegendColumns = []
        else:
            self.ChartLegendColumns = ChartLegendColumns
        if HeaderSeparator is None:
            self.HeaderSeparator = []
        else:
            self.HeaderSeparator = HeaderSeparator
        if HeaderSeparatorColor is None:
            self.HeaderSeparatorColor = []
        else:
            self.HeaderSeparatorColor = HeaderSeparatorColor
        if ColumnSeparator is None:
            self.ColumnSeparator = []
        else:
            self.ColumnSeparator = ColumnSeparator
        if ColumnSeparatorColor is None:
            self.ColumnSeparatorColor = []
        else:
            self.ColumnSeparatorColor = ColumnSeparatorColor
        if ColumnSpacing is None:
            self.ColumnSpacing = []
        else:
            self.ColumnSpacing = ColumnSpacing
        if InterlacedRows is None:
            self.InterlacedRows = []
        else:
            self.InterlacedRows = InterlacedRows
        if InterlacedRowsColor is None:
            self.InterlacedRowsColor = []
        else:
            self.InterlacedRowsColor = InterlacedRowsColor
        if EquallySpacedItems is None:
            self.EquallySpacedItems = []
        else:
            self.EquallySpacedItems = EquallySpacedItems
        if Reversed is None:
            self.Reversed = []
        else:
            self.Reversed = Reversed
        if MaxAutoSize is None:
            self.MaxAutoSize = []
        else:
            self.MaxAutoSize = MaxAutoSize
        if TextWrapThreshold is None:
            self.TextWrapThreshold = []
        else:
            self.TextWrapThreshold = TextWrapThreshold
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendType.subclass:
            return ChartLegendType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_Layout(self): return self.Layout
    def set_Layout(self, Layout): self.Layout = Layout
    def add_Layout(self, value): self.Layout.append(value)
    def insert_Layout(self, index, value): self.Layout[index] = value
    def get_DockToChartArea(self): return self.DockToChartArea
    def set_DockToChartArea(self, DockToChartArea): self.DockToChartArea = DockToChartArea
    def add_DockToChartArea(self, value): self.DockToChartArea.append(value)
    def insert_DockToChartArea(self, index, value): self.DockToChartArea[index] = value
    def get_DockOutsideChartArea(self): return self.DockOutsideChartArea
    def set_DockOutsideChartArea(self, DockOutsideChartArea): self.DockOutsideChartArea = DockOutsideChartArea
    def add_DockOutsideChartArea(self, value): self.DockOutsideChartArea.append(value)
    def insert_DockOutsideChartArea(self, index, value): self.DockOutsideChartArea[index] = value
    def get_ChartElementPosition(self): return self.ChartElementPosition
    def set_ChartElementPosition(self, ChartElementPosition): self.ChartElementPosition = ChartElementPosition
    def add_ChartElementPosition(self, value): self.ChartElementPosition.append(value)
    def insert_ChartElementPosition(self, index, value): self.ChartElementPosition[index] = value
    def get_ChartLegendTitle(self): return self.ChartLegendTitle
    def set_ChartLegendTitle(self, ChartLegendTitle): self.ChartLegendTitle = ChartLegendTitle
    def add_ChartLegendTitle(self, value): self.ChartLegendTitle.append(value)
    def insert_ChartLegendTitle(self, index, value): self.ChartLegendTitle[index] = value
    def get_AutoFitTextDisabled(self): return self.AutoFitTextDisabled
    def set_AutoFitTextDisabled(self, AutoFitTextDisabled): self.AutoFitTextDisabled = AutoFitTextDisabled
    def add_AutoFitTextDisabled(self, value): self.AutoFitTextDisabled.append(value)
    def insert_AutoFitTextDisabled(self, index, value): self.AutoFitTextDisabled[index] = value
    def get_MinFontSize(self): return self.MinFontSize
    def set_MinFontSize(self, MinFontSize): self.MinFontSize = MinFontSize
    def add_MinFontSize(self, value): self.MinFontSize.append(value)
    def insert_MinFontSize(self, index, value): self.MinFontSize[index] = value
    def get_ChartLegendColumns(self): return self.ChartLegendColumns
    def set_ChartLegendColumns(self, ChartLegendColumns): self.ChartLegendColumns = ChartLegendColumns
    def add_ChartLegendColumns(self, value): self.ChartLegendColumns.append(value)
    def insert_ChartLegendColumns(self, index, value): self.ChartLegendColumns[index] = value
    def get_HeaderSeparator(self): return self.HeaderSeparator
    def set_HeaderSeparator(self, HeaderSeparator): self.HeaderSeparator = HeaderSeparator
    def add_HeaderSeparator(self, value): self.HeaderSeparator.append(value)
    def insert_HeaderSeparator(self, index, value): self.HeaderSeparator[index] = value
    def get_HeaderSeparatorColor(self): return self.HeaderSeparatorColor
    def set_HeaderSeparatorColor(self, HeaderSeparatorColor): self.HeaderSeparatorColor = HeaderSeparatorColor
    def add_HeaderSeparatorColor(self, value): self.HeaderSeparatorColor.append(value)
    def insert_HeaderSeparatorColor(self, index, value): self.HeaderSeparatorColor[index] = value
    def get_ColumnSeparator(self): return self.ColumnSeparator
    def set_ColumnSeparator(self, ColumnSeparator): self.ColumnSeparator = ColumnSeparator
    def add_ColumnSeparator(self, value): self.ColumnSeparator.append(value)
    def insert_ColumnSeparator(self, index, value): self.ColumnSeparator[index] = value
    def get_ColumnSeparatorColor(self): return self.ColumnSeparatorColor
    def set_ColumnSeparatorColor(self, ColumnSeparatorColor): self.ColumnSeparatorColor = ColumnSeparatorColor
    def add_ColumnSeparatorColor(self, value): self.ColumnSeparatorColor.append(value)
    def insert_ColumnSeparatorColor(self, index, value): self.ColumnSeparatorColor[index] = value
    def get_ColumnSpacing(self): return self.ColumnSpacing
    def set_ColumnSpacing(self, ColumnSpacing): self.ColumnSpacing = ColumnSpacing
    def add_ColumnSpacing(self, value): self.ColumnSpacing.append(value)
    def insert_ColumnSpacing(self, index, value): self.ColumnSpacing[index] = value
    def get_InterlacedRows(self): return self.InterlacedRows
    def set_InterlacedRows(self, InterlacedRows): self.InterlacedRows = InterlacedRows
    def add_InterlacedRows(self, value): self.InterlacedRows.append(value)
    def insert_InterlacedRows(self, index, value): self.InterlacedRows[index] = value
    def get_InterlacedRowsColor(self): return self.InterlacedRowsColor
    def set_InterlacedRowsColor(self, InterlacedRowsColor): self.InterlacedRowsColor = InterlacedRowsColor
    def add_InterlacedRowsColor(self, value): self.InterlacedRowsColor.append(value)
    def insert_InterlacedRowsColor(self, index, value): self.InterlacedRowsColor[index] = value
    def get_EquallySpacedItems(self): return self.EquallySpacedItems
    def set_EquallySpacedItems(self, EquallySpacedItems): self.EquallySpacedItems = EquallySpacedItems
    def add_EquallySpacedItems(self, value): self.EquallySpacedItems.append(value)
    def insert_EquallySpacedItems(self, index, value): self.EquallySpacedItems[index] = value
    def get_Reversed(self): return self.Reversed
    def set_Reversed(self, Reversed): self.Reversed = Reversed
    def add_Reversed(self, value): self.Reversed.append(value)
    def insert_Reversed(self, index, value): self.Reversed[index] = value
    def get_MaxAutoSize(self): return self.MaxAutoSize
    def set_MaxAutoSize(self, MaxAutoSize): self.MaxAutoSize = MaxAutoSize
    def add_MaxAutoSize(self, value): self.MaxAutoSize.append(value)
    def insert_MaxAutoSize(self, index, value): self.MaxAutoSize[index] = value
    def get_TextWrapThreshold(self): return self.TextWrapThreshold
    def set_TextWrapThreshold(self, TextWrapThreshold): self.TextWrapThreshold = TextWrapThreshold
    def add_TextWrapThreshold(self, value): self.TextWrapThreshold.append(value)
    def insert_TextWrapThreshold(self, index, value): self.TextWrapThreshold[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendType', fromsubclass_=False):
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
        for Layout_ in self.Layout:
            showIndent(outfile, level)
            outfile.write('<%sLayout>%s</%sLayout>\n' % (namespace_, self.gds_format_string(quote_xml(Layout_).encode(ExternalEncoding), input_name='Layout'), namespace_))
        for DockToChartArea_ in self.DockToChartArea:
            showIndent(outfile, level)
            outfile.write('<%sDockToChartArea>%s</%sDockToChartArea>\n' % (namespace_, self.gds_format_string(quote_xml(DockToChartArea_).encode(ExternalEncoding), input_name='DockToChartArea'), namespace_))
        for DockOutsideChartArea_ in self.DockOutsideChartArea:
            showIndent(outfile, level)
            outfile.write('<%sDockOutsideChartArea>%s</%sDockOutsideChartArea>\n' % (namespace_, self.gds_format_string(quote_xml(DockOutsideChartArea_).encode(ExternalEncoding), input_name='DockOutsideChartArea'), namespace_))
        for ChartElementPosition_ in self.ChartElementPosition:
            ChartElementPosition_.export(outfile, level, namespace_, name_='ChartElementPosition')
        for ChartLegendTitle_ in self.ChartLegendTitle:
            ChartLegendTitle_.export(outfile, level, namespace_, name_='ChartLegendTitle')
        for AutoFitTextDisabled_ in self.AutoFitTextDisabled:
            showIndent(outfile, level)
            outfile.write('<%sAutoFitTextDisabled>%s</%sAutoFitTextDisabled>\n' % (namespace_, self.gds_format_string(quote_xml(AutoFitTextDisabled_).encode(ExternalEncoding), input_name='AutoFitTextDisabled'), namespace_))
        for MinFontSize_ in self.MinFontSize:
            showIndent(outfile, level)
            outfile.write('<%sMinFontSize>%s</%sMinFontSize>\n' % (namespace_, self.gds_format_string(quote_xml(MinFontSize_).encode(ExternalEncoding), input_name='MinFontSize'), namespace_))
        for ChartLegendColumns_ in self.ChartLegendColumns:
            ChartLegendColumns_.export(outfile, level, namespace_, name_='ChartLegendColumns')
        for HeaderSeparator_ in self.HeaderSeparator:
            showIndent(outfile, level)
            outfile.write('<%sHeaderSeparator>%s</%sHeaderSeparator>\n' % (namespace_, self.gds_format_string(quote_xml(HeaderSeparator_).encode(ExternalEncoding), input_name='HeaderSeparator'), namespace_))
        for HeaderSeparatorColor_ in self.HeaderSeparatorColor:
            showIndent(outfile, level)
            outfile.write('<%sHeaderSeparatorColor>%s</%sHeaderSeparatorColor>\n' % (namespace_, self.gds_format_string(quote_xml(HeaderSeparatorColor_).encode(ExternalEncoding), input_name='HeaderSeparatorColor'), namespace_))
        for ColumnSeparator_ in self.ColumnSeparator:
            showIndent(outfile, level)
            outfile.write('<%sColumnSeparator>%s</%sColumnSeparator>\n' % (namespace_, self.gds_format_string(quote_xml(ColumnSeparator_).encode(ExternalEncoding), input_name='ColumnSeparator'), namespace_))
        for ColumnSeparatorColor_ in self.ColumnSeparatorColor:
            showIndent(outfile, level)
            outfile.write('<%sColumnSeparatorColor>%s</%sColumnSeparatorColor>\n' % (namespace_, self.gds_format_string(quote_xml(ColumnSeparatorColor_).encode(ExternalEncoding), input_name='ColumnSeparatorColor'), namespace_))
        for ColumnSpacing_ in self.ColumnSpacing:
            showIndent(outfile, level)
            outfile.write('<%sColumnSpacing>%s</%sColumnSpacing>\n' % (namespace_, self.gds_format_string(quote_xml(ColumnSpacing_).encode(ExternalEncoding), input_name='ColumnSpacing'), namespace_))
        for InterlacedRows_ in self.InterlacedRows:
            showIndent(outfile, level)
            outfile.write('<%sInterlacedRows>%s</%sInterlacedRows>\n' % (namespace_, self.gds_format_string(quote_xml(InterlacedRows_).encode(ExternalEncoding), input_name='InterlacedRows'), namespace_))
        for InterlacedRowsColor_ in self.InterlacedRowsColor:
            showIndent(outfile, level)
            outfile.write('<%sInterlacedRowsColor>%s</%sInterlacedRowsColor>\n' % (namespace_, self.gds_format_string(quote_xml(InterlacedRowsColor_).encode(ExternalEncoding), input_name='InterlacedRowsColor'), namespace_))
        for EquallySpacedItems_ in self.EquallySpacedItems:
            showIndent(outfile, level)
            outfile.write('<%sEquallySpacedItems>%s</%sEquallySpacedItems>\n' % (namespace_, self.gds_format_string(quote_xml(EquallySpacedItems_).encode(ExternalEncoding), input_name='EquallySpacedItems'), namespace_))
        for Reversed_ in self.Reversed:
            showIndent(outfile, level)
            outfile.write('<%sReversed>%s</%sReversed>\n' % (namespace_, self.gds_format_string(quote_xml(Reversed_).encode(ExternalEncoding), input_name='Reversed'), namespace_))
        for MaxAutoSize_ in self.MaxAutoSize:
            showIndent(outfile, level)
            outfile.write('<%sMaxAutoSize>%s</%sMaxAutoSize>\n' % (namespace_, self.gds_format_string(quote_xml(MaxAutoSize_).encode(ExternalEncoding), input_name='MaxAutoSize'), namespace_))
        for TextWrapThreshold_ in self.TextWrapThreshold:
            showIndent(outfile, level)
            outfile.write('<%sTextWrapThreshold>%s</%sTextWrapThreshold>\n' % (namespace_, self.gds_format_string(quote_xml(TextWrapThreshold_).encode(ExternalEncoding), input_name='TextWrapThreshold'), namespace_))
    def hasContent_(self):
        if (
            self.Hidden or
            self.Style or
            self.Position or
            self.Layout or
            self.DockToChartArea or
            self.DockOutsideChartArea or
            self.ChartElementPosition or
            self.ChartLegendTitle or
            self.AutoFitTextDisabled or
            self.MinFontSize or
            self.ChartLegendColumns or
            self.HeaderSeparator or
            self.HeaderSeparatorColor or
            self.ColumnSeparator or
            self.ColumnSeparatorColor or
            self.ColumnSpacing or
            self.InterlacedRows or
            self.InterlacedRowsColor or
            self.EquallySpacedItems or
            self.Reversed or
            self.MaxAutoSize or
            self.TextWrapThreshold
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Layout=[\n')
        level += 1
        for Layout_ in self.Layout:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Layout_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DockToChartArea=[\n')
        level += 1
        for DockToChartArea_ in self.DockToChartArea:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DockToChartArea_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DockOutsideChartArea=[\n')
        level += 1
        for DockOutsideChartArea_ in self.DockOutsideChartArea:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DockOutsideChartArea_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartElementPosition=[\n')
        level += 1
        for ChartElementPosition_ in self.ChartElementPosition:
            showIndent(outfile, level)
            outfile.write('model_.ChartElementPositionType(\n')
            ChartElementPosition_.exportLiteral(outfile, level, name_='ChartElementPositionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartLegendTitle=[\n')
        level += 1
        for ChartLegendTitle_ in self.ChartLegendTitle:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendTitleType(\n')
            ChartLegendTitle_.exportLiteral(outfile, level, name_='ChartLegendTitleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AutoFitTextDisabled=[\n')
        level += 1
        for AutoFitTextDisabled_ in self.AutoFitTextDisabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AutoFitTextDisabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinFontSize=[\n')
        level += 1
        for MinFontSize_ in self.MinFontSize:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MinFontSize_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartLegendColumns=[\n')
        level += 1
        for ChartLegendColumns_ in self.ChartLegendColumns:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendColumnsType(\n')
            ChartLegendColumns_.exportLiteral(outfile, level, name_='ChartLegendColumnsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HeaderSeparator=[\n')
        level += 1
        for HeaderSeparator_ in self.HeaderSeparator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HeaderSeparator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HeaderSeparatorColor=[\n')
        level += 1
        for HeaderSeparatorColor_ in self.HeaderSeparatorColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HeaderSeparatorColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ColumnSeparator=[\n')
        level += 1
        for ColumnSeparator_ in self.ColumnSeparator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ColumnSeparator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ColumnSeparatorColor=[\n')
        level += 1
        for ColumnSeparatorColor_ in self.ColumnSeparatorColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ColumnSeparatorColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ColumnSpacing=[\n')
        level += 1
        for ColumnSpacing_ in self.ColumnSpacing:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ColumnSpacing_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InterlacedRows=[\n')
        level += 1
        for InterlacedRows_ in self.InterlacedRows:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InterlacedRows_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InterlacedRowsColor=[\n')
        level += 1
        for InterlacedRowsColor_ in self.InterlacedRowsColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InterlacedRowsColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EquallySpacedItems=[\n')
        level += 1
        for EquallySpacedItems_ in self.EquallySpacedItems:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EquallySpacedItems_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Reversed=[\n')
        level += 1
        for Reversed_ in self.Reversed:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reversed_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaxAutoSize=[\n')
        level += 1
        for MaxAutoSize_ in self.MaxAutoSize:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MaxAutoSize_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextWrapThreshold=[\n')
        level += 1
        for TextWrapThreshold_ in self.TextWrapThreshold:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextWrapThreshold_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
        elif nodeName_ == 'Layout':
            Layout_ = child_.text
            Layout_ = self.gds_validate_string(Layout_, node, 'Layout')
            self.Layout.append(Layout_)
        elif nodeName_ == 'DockToChartArea':
            DockToChartArea_ = child_.text
            DockToChartArea_ = self.gds_validate_string(DockToChartArea_, node, 'DockToChartArea')
            self.DockToChartArea.append(DockToChartArea_)
        elif nodeName_ == 'DockOutsideChartArea':
            DockOutsideChartArea_ = child_.text
            DockOutsideChartArea_ = self.gds_validate_string(DockOutsideChartArea_, node, 'DockOutsideChartArea')
            self.DockOutsideChartArea.append(DockOutsideChartArea_)
        elif nodeName_ == 'ChartElementPosition':
            obj_ = ChartElementPositionType.factory()
            obj_.build(child_)
            self.ChartElementPosition.append(obj_)
        elif nodeName_ == 'ChartLegendTitle':
            obj_ = ChartLegendTitleType.factory()
            obj_.build(child_)
            self.ChartLegendTitle.append(obj_)
        elif nodeName_ == 'AutoFitTextDisabled':
            AutoFitTextDisabled_ = child_.text
            AutoFitTextDisabled_ = self.gds_validate_string(AutoFitTextDisabled_, node, 'AutoFitTextDisabled')
            self.AutoFitTextDisabled.append(AutoFitTextDisabled_)
        elif nodeName_ == 'MinFontSize':
            MinFontSize_ = child_.text
            MinFontSize_ = self.gds_validate_string(MinFontSize_, node, 'MinFontSize')
            self.MinFontSize.append(MinFontSize_)
        elif nodeName_ == 'ChartLegendColumns':
            obj_ = ChartLegendColumnsType.factory()
            obj_.build(child_)
            self.ChartLegendColumns.append(obj_)
        elif nodeName_ == 'HeaderSeparator':
            HeaderSeparator_ = child_.text
            HeaderSeparator_ = self.gds_validate_string(HeaderSeparator_, node, 'HeaderSeparator')
            self.HeaderSeparator.append(HeaderSeparator_)
        elif nodeName_ == 'HeaderSeparatorColor':
            HeaderSeparatorColor_ = child_.text
            HeaderSeparatorColor_ = self.gds_validate_string(HeaderSeparatorColor_, node, 'HeaderSeparatorColor')
            self.HeaderSeparatorColor.append(HeaderSeparatorColor_)
        elif nodeName_ == 'ColumnSeparator':
            ColumnSeparator_ = child_.text
            ColumnSeparator_ = self.gds_validate_string(ColumnSeparator_, node, 'ColumnSeparator')
            self.ColumnSeparator.append(ColumnSeparator_)
        elif nodeName_ == 'ColumnSeparatorColor':
            ColumnSeparatorColor_ = child_.text
            ColumnSeparatorColor_ = self.gds_validate_string(ColumnSeparatorColor_, node, 'ColumnSeparatorColor')
            self.ColumnSeparatorColor.append(ColumnSeparatorColor_)
        elif nodeName_ == 'ColumnSpacing':
            ColumnSpacing_ = child_.text
            ColumnSpacing_ = self.gds_validate_string(ColumnSpacing_, node, 'ColumnSpacing')
            self.ColumnSpacing.append(ColumnSpacing_)
        elif nodeName_ == 'InterlacedRows':
            InterlacedRows_ = child_.text
            InterlacedRows_ = self.gds_validate_string(InterlacedRows_, node, 'InterlacedRows')
            self.InterlacedRows.append(InterlacedRows_)
        elif nodeName_ == 'InterlacedRowsColor':
            InterlacedRowsColor_ = child_.text
            InterlacedRowsColor_ = self.gds_validate_string(InterlacedRowsColor_, node, 'InterlacedRowsColor')
            self.InterlacedRowsColor.append(InterlacedRowsColor_)
        elif nodeName_ == 'EquallySpacedItems':
            EquallySpacedItems_ = child_.text
            EquallySpacedItems_ = self.gds_validate_string(EquallySpacedItems_, node, 'EquallySpacedItems')
            self.EquallySpacedItems.append(EquallySpacedItems_)
        elif nodeName_ == 'Reversed':
            Reversed_ = child_.text
            Reversed_ = self.gds_validate_string(Reversed_, node, 'Reversed')
            self.Reversed.append(Reversed_)
        elif nodeName_ == 'MaxAutoSize':
            MaxAutoSize_ = child_.text
            MaxAutoSize_ = self.gds_validate_string(MaxAutoSize_, node, 'MaxAutoSize')
            self.MaxAutoSize.append(MaxAutoSize_)
        elif nodeName_ == 'TextWrapThreshold':
            TextWrapThreshold_ = child_.text
            TextWrapThreshold_ = self.gds_validate_string(TextWrapThreshold_, node, 'TextWrapThreshold')
            self.TextWrapThreshold.append(TextWrapThreshold_)
# end class ChartLegendType


class ChartLegendTitleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Caption=None, TitleSeparator=None, Style=None):
        if Caption is None:
            self.Caption = []
        else:
            self.Caption = Caption
        if TitleSeparator is None:
            self.TitleSeparator = []
        else:
            self.TitleSeparator = TitleSeparator
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendTitleType.subclass:
            return ChartLegendTitleType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendTitleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def add_Caption(self, value): self.Caption.append(value)
    def insert_Caption(self, index, value): self.Caption[index] = value
    def get_TitleSeparator(self): return self.TitleSeparator
    def set_TitleSeparator(self, TitleSeparator): self.TitleSeparator = TitleSeparator
    def add_TitleSeparator(self, value): self.TitleSeparator.append(value)
    def insert_TitleSeparator(self, index, value): self.TitleSeparator[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendTitleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendTitleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendTitleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendTitleType', fromsubclass_=False):
        for Caption_ in self.Caption:
            Caption_.export(outfile, level, namespace_, name_='Caption')
        for TitleSeparator_ in self.TitleSeparator:
            showIndent(outfile, level)
            outfile.write('<%sTitleSeparator>%s</%sTitleSeparator>\n' % (namespace_, self.gds_format_string(quote_xml(TitleSeparator_).encode(ExternalEncoding), input_name='TitleSeparator'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.Caption or
            self.TitleSeparator or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendTitleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Caption=[\n')
        level += 1
        for Caption_ in self.Caption:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Caption_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TitleSeparator=[\n')
        level += 1
        for TitleSeparator_ in self.TitleSeparator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TitleSeparator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Caption':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Caption.append(obj_)
        elif nodeName_ == 'TitleSeparator':
            TitleSeparator_ = child_.text
            TitleSeparator_ = self.gds_validate_string(TitleSeparator_, node, 'TitleSeparator')
            self.TitleSeparator.append(TitleSeparator_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class ChartLegendTitleType


class ChartCustomPaletteColorsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartCustomPaletteColor=None):
        if ChartCustomPaletteColor is None:
            self.ChartCustomPaletteColor = []
        else:
            self.ChartCustomPaletteColor = ChartCustomPaletteColor
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartCustomPaletteColorsType.subclass:
            return ChartCustomPaletteColorsType.subclass(*args_, **kwargs_)
        else:
            return ChartCustomPaletteColorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartCustomPaletteColor(self): return self.ChartCustomPaletteColor
    def set_ChartCustomPaletteColor(self, ChartCustomPaletteColor): self.ChartCustomPaletteColor = ChartCustomPaletteColor
    def add_ChartCustomPaletteColor(self, value): self.ChartCustomPaletteColor.append(value)
    def insert_ChartCustomPaletteColor(self, index, value): self.ChartCustomPaletteColor[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartCustomPaletteColorsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartCustomPaletteColorsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartCustomPaletteColorsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartCustomPaletteColorsType', fromsubclass_=False):
        for ChartCustomPaletteColor_ in self.ChartCustomPaletteColor:
            showIndent(outfile, level)
            outfile.write('<%sChartCustomPaletteColor>%s</%sChartCustomPaletteColor>\n' % (namespace_, self.gds_format_string(quote_xml(ChartCustomPaletteColor_).encode(ExternalEncoding), input_name='ChartCustomPaletteColor'), namespace_))
    def hasContent_(self):
        if (
            self.ChartCustomPaletteColor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartCustomPaletteColorsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartCustomPaletteColor=[\n')
        level += 1
        for ChartCustomPaletteColor_ in self.ChartCustomPaletteColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ChartCustomPaletteColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartCustomPaletteColor':
            ChartCustomPaletteColor_ = child_.text
            ChartCustomPaletteColor_ = self.gds_validate_string(ChartCustomPaletteColor_, node, 'ChartCustomPaletteColor')
            self.ChartCustomPaletteColor.append(ChartCustomPaletteColor_)
# end class ChartCustomPaletteColorsType


class ChartBorderSkinType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartBorderSkinType=None, Style=None):
        if ChartBorderSkinType is None:
            self.ChartBorderSkinType = []
        else:
            self.ChartBorderSkinType = ChartBorderSkinType
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
    def factory(*args_, **kwargs_):
        if ChartBorderSkinType.subclass:
            return ChartBorderSkinType.subclass(*args_, **kwargs_)
        else:
            return ChartBorderSkinType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartBorderSkinType(self): return self.ChartBorderSkinType
    def set_ChartBorderSkinType(self, ChartBorderSkinType): self.ChartBorderSkinType = ChartBorderSkinType
    def add_ChartBorderSkinType(self, value): self.ChartBorderSkinType.append(value)
    def insert_ChartBorderSkinType(self, index, value): self.ChartBorderSkinType[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def export(self, outfile, level, namespace_='', name_='ChartBorderSkinType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartBorderSkinType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartBorderSkinType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartBorderSkinType', fromsubclass_=False):
        for ChartBorderSkinType_ in self.ChartBorderSkinType:
            showIndent(outfile, level)
            outfile.write('<%sChartBorderSkinType>%s</%sChartBorderSkinType>\n' % (namespace_, self.gds_format_string(quote_xml(ChartBorderSkinType_).encode(ExternalEncoding), input_name='ChartBorderSkinType'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.ChartBorderSkinType or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartBorderSkinType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartBorderSkinType=[\n')
        level += 1
        for ChartBorderSkinType_ in self.ChartBorderSkinType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ChartBorderSkinType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartBorderSkinType':
            ChartBorderSkinType_ = child_.text
            ChartBorderSkinType_ = self.gds_validate_string(ChartBorderSkinType_, node, 'ChartBorderSkinType')
            self.ChartBorderSkinType.append(ChartBorderSkinType_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class ChartBorderSkinType


class ChartCodeParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartCodeParameter=None):
        if ChartCodeParameter is None:
            self.ChartCodeParameter = []
        else:
            self.ChartCodeParameter = ChartCodeParameter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartCodeParametersType.subclass:
            return ChartCodeParametersType.subclass(*args_, **kwargs_)
        else:
            return ChartCodeParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartCodeParameter(self): return self.ChartCodeParameter
    def set_ChartCodeParameter(self, ChartCodeParameter): self.ChartCodeParameter = ChartCodeParameter
    def add_ChartCodeParameter(self, value): self.ChartCodeParameter.append(value)
    def insert_ChartCodeParameter(self, index, value): self.ChartCodeParameter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartCodeParametersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartCodeParametersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartCodeParametersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartCodeParametersType', fromsubclass_=False):
        for ChartCodeParameter_ in self.ChartCodeParameter:
            ChartCodeParameter_.export(outfile, level, namespace_, name_='ChartCodeParameter')
    def hasContent_(self):
        if (
            self.ChartCodeParameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartCodeParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartCodeParameter=[\n')
        level += 1
        for ChartCodeParameter_ in self.ChartCodeParameter:
            showIndent(outfile, level)
            outfile.write('model_.ChartCodeParameterType(\n')
            ChartCodeParameter_.exportLiteral(outfile, level, name_='ChartCodeParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartCodeParameter':
            obj_ = ChartCodeParameterType.factory()
            obj_.build(child_)
            self.ChartCodeParameter.append(obj_)
# end class ChartCodeParametersType


class ChartCodeParameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None):
        self.Name = _cast(None, Name)
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartCodeParameterType.subclass:
            return ChartCodeParameterType.subclass(*args_, **kwargs_)
        else:
            return ChartCodeParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartCodeParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartCodeParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartCodeParameterType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartCodeParameterType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartCodeParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class ChartCodeParameterType


class ChartLegendColumnsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartLegendColumn=None):
        if ChartLegendColumn is None:
            self.ChartLegendColumn = []
        else:
            self.ChartLegendColumn = ChartLegendColumn
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendColumnsType.subclass:
            return ChartLegendColumnsType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendColumnsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartLegendColumn(self): return self.ChartLegendColumn
    def set_ChartLegendColumn(self, ChartLegendColumn): self.ChartLegendColumn = ChartLegendColumn
    def add_ChartLegendColumn(self, value): self.ChartLegendColumn.append(value)
    def insert_ChartLegendColumn(self, index, value): self.ChartLegendColumn[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendColumnsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendColumnsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendColumnsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendColumnsType', fromsubclass_=False):
        for ChartLegendColumn_ in self.ChartLegendColumn:
            ChartLegendColumn_.export(outfile, level, namespace_, name_='ChartLegendColumn')
    def hasContent_(self):
        if (
            self.ChartLegendColumn
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendColumnsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartLegendColumn=[\n')
        level += 1
        for ChartLegendColumn_ in self.ChartLegendColumn:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendColumnType(\n')
            ChartLegendColumn_.exportLiteral(outfile, level, name_='ChartLegendColumnType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartLegendColumn':
            obj_ = ChartLegendColumnType.factory()
            obj_.build(child_)
            self.ChartLegendColumn.append(obj_)
# end class ChartLegendColumnsType


class ChartLegendColumnType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ColumnType=None, Value=None, Style=None, ActionInfo=None, ToolTip=None, MinimumWidth=None, MaximumWidth=None, SeriesSymbolWidth=None, SeriesSymbolHeight=None):
        self.Name = _cast(None, Name)
        if ColumnType is None:
            self.ColumnType = []
        else:
            self.ColumnType = ColumnType
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if MinimumWidth is None:
            self.MinimumWidth = []
        else:
            self.MinimumWidth = MinimumWidth
        if MaximumWidth is None:
            self.MaximumWidth = []
        else:
            self.MaximumWidth = MaximumWidth
        if SeriesSymbolWidth is None:
            self.SeriesSymbolWidth = []
        else:
            self.SeriesSymbolWidth = SeriesSymbolWidth
        if SeriesSymbolHeight is None:
            self.SeriesSymbolHeight = []
        else:
            self.SeriesSymbolHeight = SeriesSymbolHeight
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendColumnType.subclass:
            return ChartLegendColumnType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ColumnType(self): return self.ColumnType
    def set_ColumnType(self, ColumnType): self.ColumnType = ColumnType
    def add_ColumnType(self, value): self.ColumnType.append(value)
    def insert_ColumnType(self, index, value): self.ColumnType[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_MinimumWidth(self): return self.MinimumWidth
    def set_MinimumWidth(self, MinimumWidth): self.MinimumWidth = MinimumWidth
    def add_MinimumWidth(self, value): self.MinimumWidth.append(value)
    def insert_MinimumWidth(self, index, value): self.MinimumWidth[index] = value
    def get_MaximumWidth(self): return self.MaximumWidth
    def set_MaximumWidth(self, MaximumWidth): self.MaximumWidth = MaximumWidth
    def add_MaximumWidth(self, value): self.MaximumWidth.append(value)
    def insert_MaximumWidth(self, index, value): self.MaximumWidth[index] = value
    def get_SeriesSymbolWidth(self): return self.SeriesSymbolWidth
    def set_SeriesSymbolWidth(self, SeriesSymbolWidth): self.SeriesSymbolWidth = SeriesSymbolWidth
    def add_SeriesSymbolWidth(self, value): self.SeriesSymbolWidth.append(value)
    def insert_SeriesSymbolWidth(self, index, value): self.SeriesSymbolWidth[index] = value
    def get_SeriesSymbolHeight(self): return self.SeriesSymbolHeight
    def set_SeriesSymbolHeight(self, SeriesSymbolHeight): self.SeriesSymbolHeight = SeriesSymbolHeight
    def add_SeriesSymbolHeight(self, value): self.SeriesSymbolHeight.append(value)
    def insert_SeriesSymbolHeight(self, index, value): self.SeriesSymbolHeight[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendColumnType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendColumnType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendColumnType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendColumnType', fromsubclass_=False):
        for ColumnType_ in self.ColumnType:
            showIndent(outfile, level)
            outfile.write('<%sColumnType>%s</%sColumnType>\n' % (namespace_, self.gds_format_string(quote_xml(ColumnType_).encode(ExternalEncoding), input_name='ColumnType'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for MinimumWidth_ in self.MinimumWidth:
            showIndent(outfile, level)
            outfile.write('<%sMinimumWidth>%s</%sMinimumWidth>\n' % (namespace_, self.gds_format_string(quote_xml(MinimumWidth_).encode(ExternalEncoding), input_name='MinimumWidth'), namespace_))
        for MaximumWidth_ in self.MaximumWidth:
            showIndent(outfile, level)
            outfile.write('<%sMaximumWidth>%s</%sMaximumWidth>\n' % (namespace_, self.gds_format_string(quote_xml(MaximumWidth_).encode(ExternalEncoding), input_name='MaximumWidth'), namespace_))
        for SeriesSymbolWidth_ in self.SeriesSymbolWidth:
            showIndent(outfile, level)
            outfile.write('<%sSeriesSymbolWidth>%s</%sSeriesSymbolWidth>\n' % (namespace_, self.gds_format_string(quote_xml(SeriesSymbolWidth_).encode(ExternalEncoding), input_name='SeriesSymbolWidth'), namespace_))
        for SeriesSymbolHeight_ in self.SeriesSymbolHeight:
            showIndent(outfile, level)
            outfile.write('<%sSeriesSymbolHeight>%s</%sSeriesSymbolHeight>\n' % (namespace_, self.gds_format_string(quote_xml(SeriesSymbolHeight_).encode(ExternalEncoding), input_name='SeriesSymbolHeight'), namespace_))
    def hasContent_(self):
        if (
            self.ColumnType or
            self.Value or
            self.Style or
            self.ActionInfo or
            self.ToolTip or
            self.MinimumWidth or
            self.MaximumWidth or
            self.SeriesSymbolWidth or
            self.SeriesSymbolHeight
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendColumnType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ColumnType=[\n')
        level += 1
        for ColumnType_ in self.ColumnType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ColumnType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinimumWidth=[\n')
        level += 1
        for MinimumWidth_ in self.MinimumWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MinimumWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaximumWidth=[\n')
        level += 1
        for MaximumWidth_ in self.MaximumWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MaximumWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SeriesSymbolWidth=[\n')
        level += 1
        for SeriesSymbolWidth_ in self.SeriesSymbolWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SeriesSymbolWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SeriesSymbolHeight=[\n')
        level += 1
        for SeriesSymbolHeight_ in self.SeriesSymbolHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SeriesSymbolHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ColumnType':
            ColumnType_ = child_.text
            ColumnType_ = self.gds_validate_string(ColumnType_, node, 'ColumnType')
            self.ColumnType.append(ColumnType_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'MinimumWidth':
            MinimumWidth_ = child_.text
            MinimumWidth_ = self.gds_validate_string(MinimumWidth_, node, 'MinimumWidth')
            self.MinimumWidth.append(MinimumWidth_)
        elif nodeName_ == 'MaximumWidth':
            MaximumWidth_ = child_.text
            MaximumWidth_ = self.gds_validate_string(MaximumWidth_, node, 'MaximumWidth')
            self.MaximumWidth.append(MaximumWidth_)
        elif nodeName_ == 'SeriesSymbolWidth':
            SeriesSymbolWidth_ = child_.text
            SeriesSymbolWidth_ = self.gds_validate_string(SeriesSymbolWidth_, node, 'SeriesSymbolWidth')
            self.SeriesSymbolWidth.append(SeriesSymbolWidth_)
        elif nodeName_ == 'SeriesSymbolHeight':
            SeriesSymbolHeight_ = child_.text
            SeriesSymbolHeight_ = self.gds_validate_string(SeriesSymbolHeight_, node, 'SeriesSymbolHeight')
            self.SeriesSymbolHeight.append(SeriesSymbolHeight_)
# end class ChartLegendColumnType


class ColumnType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ColumnType.subclass:
            return ColumnType.subclass(*args_, **kwargs_)
        else:
            return ColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ColumnType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ColumnType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ColumnType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ColumnType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ColumnType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ColumnType


class ChartLegendColumnHeaderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None, Style=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendColumnHeaderType.subclass:
            return ChartLegendColumnHeaderType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendColumnHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendColumnHeaderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendColumnHeaderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendColumnHeaderType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendColumnHeaderType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.Value or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendColumnHeaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class ChartLegendColumnHeaderType


class ChartLegendCustomItemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartLegendCustomItem=None):
        if ChartLegendCustomItem is None:
            self.ChartLegendCustomItem = []
        else:
            self.ChartLegendCustomItem = ChartLegendCustomItem
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendCustomItemsType.subclass:
            return ChartLegendCustomItemsType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendCustomItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartLegendCustomItem(self): return self.ChartLegendCustomItem
    def set_ChartLegendCustomItem(self, ChartLegendCustomItem): self.ChartLegendCustomItem = ChartLegendCustomItem
    def add_ChartLegendCustomItem(self, value): self.ChartLegendCustomItem.append(value)
    def insert_ChartLegendCustomItem(self, index, value): self.ChartLegendCustomItem[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendCustomItemsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendCustomItemsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendCustomItemsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendCustomItemsType', fromsubclass_=False):
        for ChartLegendCustomItem_ in self.ChartLegendCustomItem:
            ChartLegendCustomItem_.export(outfile, level, namespace_, name_='ChartLegendCustomItem')
    def hasContent_(self):
        if (
            self.ChartLegendCustomItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendCustomItemsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartLegendCustomItem=[\n')
        level += 1
        for ChartLegendCustomItem_ in self.ChartLegendCustomItem:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendCustomItemType(\n')
            ChartLegendCustomItem_.exportLiteral(outfile, level, name_='ChartLegendCustomItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartLegendCustomItem':
            obj_ = ChartLegendCustomItemType.factory()
            obj_.build(child_)
            self.ChartLegendCustomItem.append(obj_)
# end class ChartLegendCustomItemsType


class ChartLegendCustomItemType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ChartLegendCustomItemCells=None, Style=None, ChartMarker=None, Separator=None, SeparatorColor=None, ToolTip=None, ActionInfo=None):
        self.Name = _cast(None, Name)
        if ChartLegendCustomItemCells is None:
            self.ChartLegendCustomItemCells = []
        else:
            self.ChartLegendCustomItemCells = ChartLegendCustomItemCells
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ChartMarker is None:
            self.ChartMarker = []
        else:
            self.ChartMarker = ChartMarker
        if Separator is None:
            self.Separator = []
        else:
            self.Separator = Separator
        if SeparatorColor is None:
            self.SeparatorColor = []
        else:
            self.SeparatorColor = SeparatorColor
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendCustomItemType.subclass:
            return ChartLegendCustomItemType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendCustomItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartLegendCustomItemCells(self): return self.ChartLegendCustomItemCells
    def set_ChartLegendCustomItemCells(self, ChartLegendCustomItemCells): self.ChartLegendCustomItemCells = ChartLegendCustomItemCells
    def add_ChartLegendCustomItemCells(self, value): self.ChartLegendCustomItemCells.append(value)
    def insert_ChartLegendCustomItemCells(self, index, value): self.ChartLegendCustomItemCells[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ChartMarker(self): return self.ChartMarker
    def set_ChartMarker(self, ChartMarker): self.ChartMarker = ChartMarker
    def add_ChartMarker(self, value): self.ChartMarker.append(value)
    def insert_ChartMarker(self, index, value): self.ChartMarker[index] = value
    def get_Separator(self): return self.Separator
    def set_Separator(self, Separator): self.Separator = Separator
    def add_Separator(self, value): self.Separator.append(value)
    def insert_Separator(self, index, value): self.Separator[index] = value
    def get_SeparatorColor(self): return self.SeparatorColor
    def set_SeparatorColor(self, SeparatorColor): self.SeparatorColor = SeparatorColor
    def add_SeparatorColor(self, value): self.SeparatorColor.append(value)
    def insert_SeparatorColor(self, index, value): self.SeparatorColor[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendCustomItemType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendCustomItemType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendCustomItemType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendCustomItemType', fromsubclass_=False):
        for ChartLegendCustomItemCells_ in self.ChartLegendCustomItemCells:
            ChartLegendCustomItemCells_.export(outfile, level, namespace_, name_='ChartLegendCustomItemCells')
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ChartMarker_ in self.ChartMarker:
            ChartMarker_.export(outfile, level, namespace_, name_='ChartMarker')
        for Separator_ in self.Separator:
            showIndent(outfile, level)
            outfile.write('<%sSeparator>%s</%sSeparator>\n' % (namespace_, self.gds_format_string(quote_xml(Separator_).encode(ExternalEncoding), input_name='Separator'), namespace_))
        for SeparatorColor_ in self.SeparatorColor:
            showIndent(outfile, level)
            outfile.write('<%sSeparatorColor>%s</%sSeparatorColor>\n' % (namespace_, self.gds_format_string(quote_xml(SeparatorColor_).encode(ExternalEncoding), input_name='SeparatorColor'), namespace_))
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
    def hasContent_(self):
        if (
            self.ChartLegendCustomItemCells or
            self.Style or
            self.ChartMarker or
            self.Separator or
            self.SeparatorColor or
            self.ToolTip or
            self.ActionInfo
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendCustomItemType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartLegendCustomItemCells=[\n')
        level += 1
        for ChartLegendCustomItemCells_ in self.ChartLegendCustomItemCells:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendCustomItemCellsType(\n')
            ChartLegendCustomItemCells_.exportLiteral(outfile, level, name_='ChartLegendCustomItemCellsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMarker=[\n')
        level += 1
        for ChartMarker_ in self.ChartMarker:
            showIndent(outfile, level)
            outfile.write('model_.ChartMarkerType(\n')
            ChartMarker_.exportLiteral(outfile, level, name_='ChartMarkerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Separator=[\n')
        level += 1
        for Separator_ in self.Separator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Separator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SeparatorColor=[\n')
        level += 1
        for SeparatorColor_ in self.SeparatorColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SeparatorColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartLegendCustomItemCells':
            obj_ = ChartLegendCustomItemCellsType.factory()
            obj_.build(child_)
            self.ChartLegendCustomItemCells.append(obj_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ChartMarker':
            obj_ = ChartMarkerType.factory()
            obj_.build(child_)
            self.ChartMarker.append(obj_)
        elif nodeName_ == 'Separator':
            Separator_ = child_.text
            Separator_ = self.gds_validate_string(Separator_, node, 'Separator')
            self.Separator.append(Separator_)
        elif nodeName_ == 'SeparatorColor':
            SeparatorColor_ = child_.text
            SeparatorColor_ = self.gds_validate_string(SeparatorColor_, node, 'SeparatorColor')
            self.SeparatorColor.append(SeparatorColor_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
# end class ChartLegendCustomItemType


class ChartLegendCustomItemCellsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartLegendCustomItemCell=None):
        if ChartLegendCustomItemCell is None:
            self.ChartLegendCustomItemCell = []
        else:
            self.ChartLegendCustomItemCell = ChartLegendCustomItemCell
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendCustomItemCellsType.subclass:
            return ChartLegendCustomItemCellsType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendCustomItemCellsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartLegendCustomItemCell(self): return self.ChartLegendCustomItemCell
    def set_ChartLegendCustomItemCell(self, ChartLegendCustomItemCell): self.ChartLegendCustomItemCell = ChartLegendCustomItemCell
    def add_ChartLegendCustomItemCell(self, value): self.ChartLegendCustomItemCell.append(value)
    def insert_ChartLegendCustomItemCell(self, index, value): self.ChartLegendCustomItemCell[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendCustomItemCellsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendCustomItemCellsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendCustomItemCellsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendCustomItemCellsType', fromsubclass_=False):
        for ChartLegendCustomItemCell_ in self.ChartLegendCustomItemCell:
            ChartLegendCustomItemCell_.export(outfile, level, namespace_, name_='ChartLegendCustomItemCell')
    def hasContent_(self):
        if (
            self.ChartLegendCustomItemCell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendCustomItemCellsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartLegendCustomItemCell=[\n')
        level += 1
        for ChartLegendCustomItemCell_ in self.ChartLegendCustomItemCell:
            showIndent(outfile, level)
            outfile.write('model_.ChartLegendCustomItemCellType(\n')
            ChartLegendCustomItemCell_.exportLiteral(outfile, level, name_='ChartLegendCustomItemCellType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartLegendCustomItemCell':
            obj_ = ChartLegendCustomItemCellType.factory()
            obj_.build(child_)
            self.ChartLegendCustomItemCell.append(obj_)
# end class ChartLegendCustomItemCellsType


class ChartLegendCustomItemCellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, CellType=None, Text=None, CellSpan=None, Style=None, ActionInfo=None, ToolTip=None, ImageHeight=None, ImageWidth=None, SymbolHeight=None, SymbolWidth=None, Alignment=None, TopMargin=None, BottomMargin=None, LeftMargin=None, RightMargin=None):
        self.Name = _cast(None, Name)
        if CellType is None:
            self.CellType = []
        else:
            self.CellType = CellType
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if CellSpan is None:
            self.CellSpan = []
        else:
            self.CellSpan = CellSpan
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ImageHeight is None:
            self.ImageHeight = []
        else:
            self.ImageHeight = ImageHeight
        if ImageWidth is None:
            self.ImageWidth = []
        else:
            self.ImageWidth = ImageWidth
        if SymbolHeight is None:
            self.SymbolHeight = []
        else:
            self.SymbolHeight = SymbolHeight
        if SymbolWidth is None:
            self.SymbolWidth = []
        else:
            self.SymbolWidth = SymbolWidth
        if Alignment is None:
            self.Alignment = []
        else:
            self.Alignment = Alignment
        if TopMargin is None:
            self.TopMargin = []
        else:
            self.TopMargin = TopMargin
        if BottomMargin is None:
            self.BottomMargin = []
        else:
            self.BottomMargin = BottomMargin
        if LeftMargin is None:
            self.LeftMargin = []
        else:
            self.LeftMargin = LeftMargin
        if RightMargin is None:
            self.RightMargin = []
        else:
            self.RightMargin = RightMargin
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartLegendCustomItemCellType.subclass:
            return ChartLegendCustomItemCellType.subclass(*args_, **kwargs_)
        else:
            return ChartLegendCustomItemCellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellType(self): return self.CellType
    def set_CellType(self, CellType): self.CellType = CellType
    def add_CellType(self, value): self.CellType.append(value)
    def insert_CellType(self, index, value): self.CellType[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_CellSpan(self): return self.CellSpan
    def set_CellSpan(self, CellSpan): self.CellSpan = CellSpan
    def add_CellSpan(self, value): self.CellSpan.append(value)
    def insert_CellSpan(self, index, value): self.CellSpan[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ImageHeight(self): return self.ImageHeight
    def set_ImageHeight(self, ImageHeight): self.ImageHeight = ImageHeight
    def add_ImageHeight(self, value): self.ImageHeight.append(value)
    def insert_ImageHeight(self, index, value): self.ImageHeight[index] = value
    def get_ImageWidth(self): return self.ImageWidth
    def set_ImageWidth(self, ImageWidth): self.ImageWidth = ImageWidth
    def add_ImageWidth(self, value): self.ImageWidth.append(value)
    def insert_ImageWidth(self, index, value): self.ImageWidth[index] = value
    def get_SymbolHeight(self): return self.SymbolHeight
    def set_SymbolHeight(self, SymbolHeight): self.SymbolHeight = SymbolHeight
    def add_SymbolHeight(self, value): self.SymbolHeight.append(value)
    def insert_SymbolHeight(self, index, value): self.SymbolHeight[index] = value
    def get_SymbolWidth(self): return self.SymbolWidth
    def set_SymbolWidth(self, SymbolWidth): self.SymbolWidth = SymbolWidth
    def add_SymbolWidth(self, value): self.SymbolWidth.append(value)
    def insert_SymbolWidth(self, index, value): self.SymbolWidth[index] = value
    def get_Alignment(self): return self.Alignment
    def set_Alignment(self, Alignment): self.Alignment = Alignment
    def add_Alignment(self, value): self.Alignment.append(value)
    def insert_Alignment(self, index, value): self.Alignment[index] = value
    def get_TopMargin(self): return self.TopMargin
    def set_TopMargin(self, TopMargin): self.TopMargin = TopMargin
    def add_TopMargin(self, value): self.TopMargin.append(value)
    def insert_TopMargin(self, index, value): self.TopMargin[index] = value
    def get_BottomMargin(self): return self.BottomMargin
    def set_BottomMargin(self, BottomMargin): self.BottomMargin = BottomMargin
    def add_BottomMargin(self, value): self.BottomMargin.append(value)
    def insert_BottomMargin(self, index, value): self.BottomMargin[index] = value
    def get_LeftMargin(self): return self.LeftMargin
    def set_LeftMargin(self, LeftMargin): self.LeftMargin = LeftMargin
    def add_LeftMargin(self, value): self.LeftMargin.append(value)
    def insert_LeftMargin(self, index, value): self.LeftMargin[index] = value
    def get_RightMargin(self): return self.RightMargin
    def set_RightMargin(self, RightMargin): self.RightMargin = RightMargin
    def add_RightMargin(self, value): self.RightMargin.append(value)
    def insert_RightMargin(self, index, value): self.RightMargin[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartLegendCustomItemCellType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartLegendCustomItemCellType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartLegendCustomItemCellType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartLegendCustomItemCellType', fromsubclass_=False):
        for CellType_ in self.CellType:
            showIndent(outfile, level)
            outfile.write('<%sCellType>%s</%sCellType>\n' % (namespace_, self.gds_format_string(quote_xml(CellType_).encode(ExternalEncoding), input_name='CellType'), namespace_))
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('<%sText>%s</%sText>\n' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_))
        for CellSpan_ in self.CellSpan:
            showIndent(outfile, level)
            outfile.write('<%sCellSpan>%s</%sCellSpan>\n' % (namespace_, self.gds_format_integer(CellSpan_, input_name='CellSpan'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ImageHeight_ in self.ImageHeight:
            showIndent(outfile, level)
            outfile.write('<%sImageHeight>%s</%sImageHeight>\n' % (namespace_, self.gds_format_string(quote_xml(ImageHeight_).encode(ExternalEncoding), input_name='ImageHeight'), namespace_))
        for ImageWidth_ in self.ImageWidth:
            showIndent(outfile, level)
            outfile.write('<%sImageWidth>%s</%sImageWidth>\n' % (namespace_, self.gds_format_string(quote_xml(ImageWidth_).encode(ExternalEncoding), input_name='ImageWidth'), namespace_))
        for SymbolHeight_ in self.SymbolHeight:
            showIndent(outfile, level)
            outfile.write('<%sSymbolHeight>%s</%sSymbolHeight>\n' % (namespace_, self.gds_format_string(quote_xml(SymbolHeight_).encode(ExternalEncoding), input_name='SymbolHeight'), namespace_))
        for SymbolWidth_ in self.SymbolWidth:
            showIndent(outfile, level)
            outfile.write('<%sSymbolWidth>%s</%sSymbolWidth>\n' % (namespace_, self.gds_format_string(quote_xml(SymbolWidth_).encode(ExternalEncoding), input_name='SymbolWidth'), namespace_))
        for Alignment_ in self.Alignment:
            showIndent(outfile, level)
            outfile.write('<%sAlignment>%s</%sAlignment>\n' % (namespace_, self.gds_format_string(quote_xml(Alignment_).encode(ExternalEncoding), input_name='Alignment'), namespace_))
        for TopMargin_ in self.TopMargin:
            showIndent(outfile, level)
            outfile.write('<%sTopMargin>%s</%sTopMargin>\n' % (namespace_, self.gds_format_string(quote_xml(TopMargin_).encode(ExternalEncoding), input_name='TopMargin'), namespace_))
        for BottomMargin_ in self.BottomMargin:
            showIndent(outfile, level)
            outfile.write('<%sBottomMargin>%s</%sBottomMargin>\n' % (namespace_, self.gds_format_string(quote_xml(BottomMargin_).encode(ExternalEncoding), input_name='BottomMargin'), namespace_))
        for LeftMargin_ in self.LeftMargin:
            showIndent(outfile, level)
            outfile.write('<%sLeftMargin>%s</%sLeftMargin>\n' % (namespace_, self.gds_format_string(quote_xml(LeftMargin_).encode(ExternalEncoding), input_name='LeftMargin'), namespace_))
        for RightMargin_ in self.RightMargin:
            showIndent(outfile, level)
            outfile.write('<%sRightMargin>%s</%sRightMargin>\n' % (namespace_, self.gds_format_string(quote_xml(RightMargin_).encode(ExternalEncoding), input_name='RightMargin'), namespace_))
    def hasContent_(self):
        if (
            self.CellType or
            self.Text or
            self.CellSpan or
            self.Style or
            self.ActionInfo or
            self.ToolTip or
            self.ImageHeight or
            self.ImageWidth or
            self.SymbolHeight or
            self.SymbolWidth or
            self.Alignment or
            self.TopMargin or
            self.BottomMargin or
            self.LeftMargin or
            self.RightMargin
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartLegendCustomItemCellType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CellType=[\n')
        level += 1
        for CellType_ in self.CellType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CellType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CellSpan=[\n')
        level += 1
        for CellSpan_ in self.CellSpan:
            showIndent(outfile, level)
            outfile.write('%d,\n' % CellSpan)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ImageHeight=[\n')
        level += 1
        for ImageHeight_ in self.ImageHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ImageHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ImageWidth=[\n')
        level += 1
        for ImageWidth_ in self.ImageWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ImageWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SymbolHeight=[\n')
        level += 1
        for SymbolHeight_ in self.SymbolHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SymbolHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SymbolWidth=[\n')
        level += 1
        for SymbolWidth_ in self.SymbolWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SymbolWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Alignment=[\n')
        level += 1
        for Alignment_ in self.Alignment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Alignment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TopMargin=[\n')
        level += 1
        for TopMargin_ in self.TopMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TopMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BottomMargin=[\n')
        level += 1
        for BottomMargin_ in self.BottomMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BottomMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LeftMargin=[\n')
        level += 1
        for LeftMargin_ in self.LeftMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LeftMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RightMargin=[\n')
        level += 1
        for RightMargin_ in self.RightMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RightMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellType':
            CellType_ = child_.text
            CellType_ = self.gds_validate_string(CellType_, node, 'CellType')
            self.CellType.append(CellType_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'CellSpan':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CellSpan')
            self.CellSpan.append(ival_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ImageHeight':
            ImageHeight_ = child_.text
            ImageHeight_ = self.gds_validate_string(ImageHeight_, node, 'ImageHeight')
            self.ImageHeight.append(ImageHeight_)
        elif nodeName_ == 'ImageWidth':
            ImageWidth_ = child_.text
            ImageWidth_ = self.gds_validate_string(ImageWidth_, node, 'ImageWidth')
            self.ImageWidth.append(ImageWidth_)
        elif nodeName_ == 'SymbolHeight':
            SymbolHeight_ = child_.text
            SymbolHeight_ = self.gds_validate_string(SymbolHeight_, node, 'SymbolHeight')
            self.SymbolHeight.append(SymbolHeight_)
        elif nodeName_ == 'SymbolWidth':
            SymbolWidth_ = child_.text
            SymbolWidth_ = self.gds_validate_string(SymbolWidth_, node, 'SymbolWidth')
            self.SymbolWidth.append(SymbolWidth_)
        elif nodeName_ == 'Alignment':
            Alignment_ = child_.text
            Alignment_ = self.gds_validate_string(Alignment_, node, 'Alignment')
            self.Alignment.append(Alignment_)
        elif nodeName_ == 'TopMargin':
            TopMargin_ = child_.text
            TopMargin_ = self.gds_validate_string(TopMargin_, node, 'TopMargin')
            self.TopMargin.append(TopMargin_)
        elif nodeName_ == 'BottomMargin':
            BottomMargin_ = child_.text
            BottomMargin_ = self.gds_validate_string(BottomMargin_, node, 'BottomMargin')
            self.BottomMargin.append(BottomMargin_)
        elif nodeName_ == 'LeftMargin':
            LeftMargin_ = child_.text
            LeftMargin_ = self.gds_validate_string(LeftMargin_, node, 'LeftMargin')
            self.LeftMargin.append(LeftMargin_)
        elif nodeName_ == 'RightMargin':
            RightMargin_ = child_.text
            RightMargin_ = self.gds_validate_string(RightMargin_, node, 'RightMargin')
            self.RightMargin.append(RightMargin_)
# end class ChartLegendCustomItemCellType


class CellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if CellType.subclass:
            return CellType.subclass(*args_, **kwargs_)
        else:
            return CellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='CellType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CellType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CellType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CellType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CellType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CellType


class ChartMarkerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Size=None, Style=None):
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if Size is None:
            self.Size = []
        else:
            self.Size = Size
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartMarkerType.subclass:
            return ChartMarkerType.subclass(*args_, **kwargs_)
        else:
            return ChartMarkerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def add_Size(self, value): self.Size.append(value)
    def insert_Size(self, index, value): self.Size[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartMarkerType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartMarkerType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartMarkerType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartMarkerType', fromsubclass_=False):
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(Type_).encode(ExternalEncoding), input_name='Type'), namespace_))
        for Size_ in self.Size:
            showIndent(outfile, level)
            outfile.write('<%sSize>%s</%sSize>\n' % (namespace_, self.gds_format_string(quote_xml(Size_).encode(ExternalEncoding), input_name='Size'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.Type or
            self.Size or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartMarkerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Size=[\n')
        level += 1
        for Size_ in self.Size:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Size_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
        elif nodeName_ == 'Size':
            Size_ = child_.text
            Size_ = self.gds_validate_string(Size_, node, 'Size')
            self.Size.append(Size_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class ChartMarkerType


class ChartCategoryAxesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartAxis=None):
        if ChartAxis is None:
            self.ChartAxis = []
        else:
            self.ChartAxis = ChartAxis
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartCategoryAxesType.subclass:
            return ChartCategoryAxesType.subclass(*args_, **kwargs_)
        else:
            return ChartCategoryAxesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartAxis(self): return self.ChartAxis
    def set_ChartAxis(self, ChartAxis): self.ChartAxis = ChartAxis
    def add_ChartAxis(self, value): self.ChartAxis.append(value)
    def insert_ChartAxis(self, index, value): self.ChartAxis[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartCategoryAxesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartCategoryAxesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartCategoryAxesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartCategoryAxesType', fromsubclass_=False):
        for ChartAxis_ in self.ChartAxis:
            ChartAxis_.export(outfile, level, namespace_, name_='ChartAxis')
    def hasContent_(self):
        if (
            self.ChartAxis
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartCategoryAxesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartAxis=[\n')
        level += 1
        for ChartAxis_ in self.ChartAxis:
            showIndent(outfile, level)
            outfile.write('model_.ChartAxisType(\n')
            ChartAxis_.exportLiteral(outfile, level, name_='ChartAxisType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartAxis':
            obj_ = ChartAxisType.factory()
            obj_.build(child_)
            self.ChartAxis.append(obj_)
# end class ChartCategoryAxesType


class ChartValueAxesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartAxis=None):
        if ChartAxis is None:
            self.ChartAxis = []
        else:
            self.ChartAxis = ChartAxis
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartValueAxesType.subclass:
            return ChartValueAxesType.subclass(*args_, **kwargs_)
        else:
            return ChartValueAxesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartAxis(self): return self.ChartAxis
    def set_ChartAxis(self, ChartAxis): self.ChartAxis = ChartAxis
    def add_ChartAxis(self, value): self.ChartAxis.append(value)
    def insert_ChartAxis(self, index, value): self.ChartAxis[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartValueAxesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartValueAxesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartValueAxesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartValueAxesType', fromsubclass_=False):
        for ChartAxis_ in self.ChartAxis:
            ChartAxis_.export(outfile, level, namespace_, name_='ChartAxis')
    def hasContent_(self):
        if (
            self.ChartAxis
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartValueAxesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartAxis=[\n')
        level += 1
        for ChartAxis_ in self.ChartAxis:
            showIndent(outfile, level)
            outfile.write('model_.ChartAxisType(\n')
            ChartAxis_.exportLiteral(outfile, level, name_='ChartAxisType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartAxis':
            obj_ = ChartAxisType.factory()
            obj_.build(child_)
            self.ChartAxis.append(obj_)
# end class ChartValueAxesType


class ChartAxisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Visible=None, Style=None, ChartAxisTitle=None, Margin=None, Interval=None, IntervalType=None, IntervalOffset=None, IntervalOffsetType=None, VariableAutoInterval=None, LabelInterval=None, LabelIntervalType=None, LabelIntervalOffset=None, LabelIntervalOffsetType=None, ChartMajorGridLines=None, ChartMinorGridLines=None, ChartMajorTickMarks=None, ChartMinorTickMarks=None, MarksAlwaysAtPlotEdge=None, Reverse=None, CrossAt=None, Location=None, Interlaced=None, InterlacedColor=None, ChartStripLines=None, Arrows=None, Scalar=None, Minimum=None, Maximum=None, LogScale=None, LogBase=None, HideLabels=None, Angle=None, PreventFontShrink=None, PreventFontGrow=None, PreventLabelOffset=None, PreventWordWrap=None, AllowLabelRotation=None, IncludeZero=None, LabelsAutoFitDisabled=None, MinFontSize=None, MaxFontSize=None, OffsetLabels=None, HideEndLabels=None, ChartAxisScaleBreak=None, CustomProperties=None):
        self.Name = _cast(None, Name)
        if Visible is None:
            self.Visible = []
        else:
            self.Visible = Visible
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ChartAxisTitle is None:
            self.ChartAxisTitle = []
        else:
            self.ChartAxisTitle = ChartAxisTitle
        if Margin is None:
            self.Margin = []
        else:
            self.Margin = Margin
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalType is None:
            self.IntervalType = []
        else:
            self.IntervalType = IntervalType
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if IntervalOffsetType is None:
            self.IntervalOffsetType = []
        else:
            self.IntervalOffsetType = IntervalOffsetType
        if VariableAutoInterval is None:
            self.VariableAutoInterval = []
        else:
            self.VariableAutoInterval = VariableAutoInterval
        if LabelInterval is None:
            self.LabelInterval = []
        else:
            self.LabelInterval = LabelInterval
        if LabelIntervalType is None:
            self.LabelIntervalType = []
        else:
            self.LabelIntervalType = LabelIntervalType
        if LabelIntervalOffset is None:
            self.LabelIntervalOffset = []
        else:
            self.LabelIntervalOffset = LabelIntervalOffset
        if LabelIntervalOffsetType is None:
            self.LabelIntervalOffsetType = []
        else:
            self.LabelIntervalOffsetType = LabelIntervalOffsetType
        if ChartMajorGridLines is None:
            self.ChartMajorGridLines = []
        else:
            self.ChartMajorGridLines = ChartMajorGridLines
        if ChartMinorGridLines is None:
            self.ChartMinorGridLines = []
        else:
            self.ChartMinorGridLines = ChartMinorGridLines
        if ChartMajorTickMarks is None:
            self.ChartMajorTickMarks = []
        else:
            self.ChartMajorTickMarks = ChartMajorTickMarks
        if ChartMinorTickMarks is None:
            self.ChartMinorTickMarks = []
        else:
            self.ChartMinorTickMarks = ChartMinorTickMarks
        if MarksAlwaysAtPlotEdge is None:
            self.MarksAlwaysAtPlotEdge = []
        else:
            self.MarksAlwaysAtPlotEdge = MarksAlwaysAtPlotEdge
        if Reverse is None:
            self.Reverse = []
        else:
            self.Reverse = Reverse
        if CrossAt is None:
            self.CrossAt = []
        else:
            self.CrossAt = CrossAt
        if Location is None:
            self.Location = []
        else:
            self.Location = Location
        if Interlaced is None:
            self.Interlaced = []
        else:
            self.Interlaced = Interlaced
        if InterlacedColor is None:
            self.InterlacedColor = []
        else:
            self.InterlacedColor = InterlacedColor
        if ChartStripLines is None:
            self.ChartStripLines = []
        else:
            self.ChartStripLines = ChartStripLines
        if Arrows is None:
            self.Arrows = []
        else:
            self.Arrows = Arrows
        if Scalar is None:
            self.Scalar = []
        else:
            self.Scalar = Scalar
        if Minimum is None:
            self.Minimum = []
        else:
            self.Minimum = Minimum
        if Maximum is None:
            self.Maximum = []
        else:
            self.Maximum = Maximum
        if LogScale is None:
            self.LogScale = []
        else:
            self.LogScale = LogScale
        if LogBase is None:
            self.LogBase = []
        else:
            self.LogBase = LogBase
        if HideLabels is None:
            self.HideLabels = []
        else:
            self.HideLabels = HideLabels
        if Angle is None:
            self.Angle = []
        else:
            self.Angle = Angle
        if PreventFontShrink is None:
            self.PreventFontShrink = []
        else:
            self.PreventFontShrink = PreventFontShrink
        if PreventFontGrow is None:
            self.PreventFontGrow = []
        else:
            self.PreventFontGrow = PreventFontGrow
        if PreventLabelOffset is None:
            self.PreventLabelOffset = []
        else:
            self.PreventLabelOffset = PreventLabelOffset
        if PreventWordWrap is None:
            self.PreventWordWrap = []
        else:
            self.PreventWordWrap = PreventWordWrap
        if AllowLabelRotation is None:
            self.AllowLabelRotation = []
        else:
            self.AllowLabelRotation = AllowLabelRotation
        if IncludeZero is None:
            self.IncludeZero = []
        else:
            self.IncludeZero = IncludeZero
        if LabelsAutoFitDisabled is None:
            self.LabelsAutoFitDisabled = []
        else:
            self.LabelsAutoFitDisabled = LabelsAutoFitDisabled
        if MinFontSize is None:
            self.MinFontSize = []
        else:
            self.MinFontSize = MinFontSize
        if MaxFontSize is None:
            self.MaxFontSize = []
        else:
            self.MaxFontSize = MaxFontSize
        if OffsetLabels is None:
            self.OffsetLabels = []
        else:
            self.OffsetLabels = OffsetLabels
        if HideEndLabels is None:
            self.HideEndLabels = []
        else:
            self.HideEndLabels = HideEndLabels
        if ChartAxisScaleBreak is None:
            self.ChartAxisScaleBreak = []
        else:
            self.ChartAxisScaleBreak = ChartAxisScaleBreak
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAxisType.subclass:
            return ChartAxisType.subclass(*args_, **kwargs_)
        else:
            return ChartAxisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def add_Visible(self, value): self.Visible.append(value)
    def insert_Visible(self, index, value): self.Visible[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ChartAxisTitle(self): return self.ChartAxisTitle
    def set_ChartAxisTitle(self, ChartAxisTitle): self.ChartAxisTitle = ChartAxisTitle
    def add_ChartAxisTitle(self, value): self.ChartAxisTitle.append(value)
    def insert_ChartAxisTitle(self, index, value): self.ChartAxisTitle[index] = value
    def get_Margin(self): return self.Margin
    def set_Margin(self, Margin): self.Margin = Margin
    def add_Margin(self, value): self.Margin.append(value)
    def insert_Margin(self, index, value): self.Margin[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalType(self): return self.IntervalType
    def set_IntervalType(self, IntervalType): self.IntervalType = IntervalType
    def add_IntervalType(self, value): self.IntervalType.append(value)
    def insert_IntervalType(self, index, value): self.IntervalType[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_IntervalOffsetType(self): return self.IntervalOffsetType
    def set_IntervalOffsetType(self, IntervalOffsetType): self.IntervalOffsetType = IntervalOffsetType
    def add_IntervalOffsetType(self, value): self.IntervalOffsetType.append(value)
    def insert_IntervalOffsetType(self, index, value): self.IntervalOffsetType[index] = value
    def get_VariableAutoInterval(self): return self.VariableAutoInterval
    def set_VariableAutoInterval(self, VariableAutoInterval): self.VariableAutoInterval = VariableAutoInterval
    def add_VariableAutoInterval(self, value): self.VariableAutoInterval.append(value)
    def insert_VariableAutoInterval(self, index, value): self.VariableAutoInterval[index] = value
    def get_LabelInterval(self): return self.LabelInterval
    def set_LabelInterval(self, LabelInterval): self.LabelInterval = LabelInterval
    def add_LabelInterval(self, value): self.LabelInterval.append(value)
    def insert_LabelInterval(self, index, value): self.LabelInterval[index] = value
    def get_LabelIntervalType(self): return self.LabelIntervalType
    def set_LabelIntervalType(self, LabelIntervalType): self.LabelIntervalType = LabelIntervalType
    def add_LabelIntervalType(self, value): self.LabelIntervalType.append(value)
    def insert_LabelIntervalType(self, index, value): self.LabelIntervalType[index] = value
    def get_LabelIntervalOffset(self): return self.LabelIntervalOffset
    def set_LabelIntervalOffset(self, LabelIntervalOffset): self.LabelIntervalOffset = LabelIntervalOffset
    def add_LabelIntervalOffset(self, value): self.LabelIntervalOffset.append(value)
    def insert_LabelIntervalOffset(self, index, value): self.LabelIntervalOffset[index] = value
    def get_LabelIntervalOffsetType(self): return self.LabelIntervalOffsetType
    def set_LabelIntervalOffsetType(self, LabelIntervalOffsetType): self.LabelIntervalOffsetType = LabelIntervalOffsetType
    def add_LabelIntervalOffsetType(self, value): self.LabelIntervalOffsetType.append(value)
    def insert_LabelIntervalOffsetType(self, index, value): self.LabelIntervalOffsetType[index] = value
    def get_ChartMajorGridLines(self): return self.ChartMajorGridLines
    def set_ChartMajorGridLines(self, ChartMajorGridLines): self.ChartMajorGridLines = ChartMajorGridLines
    def add_ChartMajorGridLines(self, value): self.ChartMajorGridLines.append(value)
    def insert_ChartMajorGridLines(self, index, value): self.ChartMajorGridLines[index] = value
    def get_ChartMinorGridLines(self): return self.ChartMinorGridLines
    def set_ChartMinorGridLines(self, ChartMinorGridLines): self.ChartMinorGridLines = ChartMinorGridLines
    def add_ChartMinorGridLines(self, value): self.ChartMinorGridLines.append(value)
    def insert_ChartMinorGridLines(self, index, value): self.ChartMinorGridLines[index] = value
    def get_ChartMajorTickMarks(self): return self.ChartMajorTickMarks
    def set_ChartMajorTickMarks(self, ChartMajorTickMarks): self.ChartMajorTickMarks = ChartMajorTickMarks
    def add_ChartMajorTickMarks(self, value): self.ChartMajorTickMarks.append(value)
    def insert_ChartMajorTickMarks(self, index, value): self.ChartMajorTickMarks[index] = value
    def get_ChartMinorTickMarks(self): return self.ChartMinorTickMarks
    def set_ChartMinorTickMarks(self, ChartMinorTickMarks): self.ChartMinorTickMarks = ChartMinorTickMarks
    def add_ChartMinorTickMarks(self, value): self.ChartMinorTickMarks.append(value)
    def insert_ChartMinorTickMarks(self, index, value): self.ChartMinorTickMarks[index] = value
    def get_MarksAlwaysAtPlotEdge(self): return self.MarksAlwaysAtPlotEdge
    def set_MarksAlwaysAtPlotEdge(self, MarksAlwaysAtPlotEdge): self.MarksAlwaysAtPlotEdge = MarksAlwaysAtPlotEdge
    def add_MarksAlwaysAtPlotEdge(self, value): self.MarksAlwaysAtPlotEdge.append(value)
    def insert_MarksAlwaysAtPlotEdge(self, index, value): self.MarksAlwaysAtPlotEdge[index] = value
    def get_Reverse(self): return self.Reverse
    def set_Reverse(self, Reverse): self.Reverse = Reverse
    def add_Reverse(self, value): self.Reverse.append(value)
    def insert_Reverse(self, index, value): self.Reverse[index] = value
    def get_CrossAt(self): return self.CrossAt
    def set_CrossAt(self, CrossAt): self.CrossAt = CrossAt
    def add_CrossAt(self, value): self.CrossAt.append(value)
    def insert_CrossAt(self, index, value): self.CrossAt[index] = value
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def add_Location(self, value): self.Location.append(value)
    def insert_Location(self, index, value): self.Location[index] = value
    def get_Interlaced(self): return self.Interlaced
    def set_Interlaced(self, Interlaced): self.Interlaced = Interlaced
    def add_Interlaced(self, value): self.Interlaced.append(value)
    def insert_Interlaced(self, index, value): self.Interlaced[index] = value
    def get_InterlacedColor(self): return self.InterlacedColor
    def set_InterlacedColor(self, InterlacedColor): self.InterlacedColor = InterlacedColor
    def add_InterlacedColor(self, value): self.InterlacedColor.append(value)
    def insert_InterlacedColor(self, index, value): self.InterlacedColor[index] = value
    def get_ChartStripLines(self): return self.ChartStripLines
    def set_ChartStripLines(self, ChartStripLines): self.ChartStripLines = ChartStripLines
    def add_ChartStripLines(self, value): self.ChartStripLines.append(value)
    def insert_ChartStripLines(self, index, value): self.ChartStripLines[index] = value
    def get_Arrows(self): return self.Arrows
    def set_Arrows(self, Arrows): self.Arrows = Arrows
    def add_Arrows(self, value): self.Arrows.append(value)
    def insert_Arrows(self, index, value): self.Arrows[index] = value
    def get_Scalar(self): return self.Scalar
    def set_Scalar(self, Scalar): self.Scalar = Scalar
    def add_Scalar(self, value): self.Scalar.append(value)
    def insert_Scalar(self, index, value): self.Scalar[index] = value
    def get_Minimum(self): return self.Minimum
    def set_Minimum(self, Minimum): self.Minimum = Minimum
    def add_Minimum(self, value): self.Minimum.append(value)
    def insert_Minimum(self, index, value): self.Minimum[index] = value
    def get_Maximum(self): return self.Maximum
    def set_Maximum(self, Maximum): self.Maximum = Maximum
    def add_Maximum(self, value): self.Maximum.append(value)
    def insert_Maximum(self, index, value): self.Maximum[index] = value
    def get_LogScale(self): return self.LogScale
    def set_LogScale(self, LogScale): self.LogScale = LogScale
    def add_LogScale(self, value): self.LogScale.append(value)
    def insert_LogScale(self, index, value): self.LogScale[index] = value
    def get_LogBase(self): return self.LogBase
    def set_LogBase(self, LogBase): self.LogBase = LogBase
    def add_LogBase(self, value): self.LogBase.append(value)
    def insert_LogBase(self, index, value): self.LogBase[index] = value
    def get_HideLabels(self): return self.HideLabels
    def set_HideLabels(self, HideLabels): self.HideLabels = HideLabels
    def add_HideLabels(self, value): self.HideLabels.append(value)
    def insert_HideLabels(self, index, value): self.HideLabels[index] = value
    def get_Angle(self): return self.Angle
    def set_Angle(self, Angle): self.Angle = Angle
    def add_Angle(self, value): self.Angle.append(value)
    def insert_Angle(self, index, value): self.Angle[index] = value
    def get_PreventFontShrink(self): return self.PreventFontShrink
    def set_PreventFontShrink(self, PreventFontShrink): self.PreventFontShrink = PreventFontShrink
    def add_PreventFontShrink(self, value): self.PreventFontShrink.append(value)
    def insert_PreventFontShrink(self, index, value): self.PreventFontShrink[index] = value
    def get_PreventFontGrow(self): return self.PreventFontGrow
    def set_PreventFontGrow(self, PreventFontGrow): self.PreventFontGrow = PreventFontGrow
    def add_PreventFontGrow(self, value): self.PreventFontGrow.append(value)
    def insert_PreventFontGrow(self, index, value): self.PreventFontGrow[index] = value
    def get_PreventLabelOffset(self): return self.PreventLabelOffset
    def set_PreventLabelOffset(self, PreventLabelOffset): self.PreventLabelOffset = PreventLabelOffset
    def add_PreventLabelOffset(self, value): self.PreventLabelOffset.append(value)
    def insert_PreventLabelOffset(self, index, value): self.PreventLabelOffset[index] = value
    def get_PreventWordWrap(self): return self.PreventWordWrap
    def set_PreventWordWrap(self, PreventWordWrap): self.PreventWordWrap = PreventWordWrap
    def add_PreventWordWrap(self, value): self.PreventWordWrap.append(value)
    def insert_PreventWordWrap(self, index, value): self.PreventWordWrap[index] = value
    def get_AllowLabelRotation(self): return self.AllowLabelRotation
    def set_AllowLabelRotation(self, AllowLabelRotation): self.AllowLabelRotation = AllowLabelRotation
    def add_AllowLabelRotation(self, value): self.AllowLabelRotation.append(value)
    def insert_AllowLabelRotation(self, index, value): self.AllowLabelRotation[index] = value
    def get_IncludeZero(self): return self.IncludeZero
    def set_IncludeZero(self, IncludeZero): self.IncludeZero = IncludeZero
    def add_IncludeZero(self, value): self.IncludeZero.append(value)
    def insert_IncludeZero(self, index, value): self.IncludeZero[index] = value
    def get_LabelsAutoFitDisabled(self): return self.LabelsAutoFitDisabled
    def set_LabelsAutoFitDisabled(self, LabelsAutoFitDisabled): self.LabelsAutoFitDisabled = LabelsAutoFitDisabled
    def add_LabelsAutoFitDisabled(self, value): self.LabelsAutoFitDisabled.append(value)
    def insert_LabelsAutoFitDisabled(self, index, value): self.LabelsAutoFitDisabled[index] = value
    def get_MinFontSize(self): return self.MinFontSize
    def set_MinFontSize(self, MinFontSize): self.MinFontSize = MinFontSize
    def add_MinFontSize(self, value): self.MinFontSize.append(value)
    def insert_MinFontSize(self, index, value): self.MinFontSize[index] = value
    def get_MaxFontSize(self): return self.MaxFontSize
    def set_MaxFontSize(self, MaxFontSize): self.MaxFontSize = MaxFontSize
    def add_MaxFontSize(self, value): self.MaxFontSize.append(value)
    def insert_MaxFontSize(self, index, value): self.MaxFontSize[index] = value
    def get_OffsetLabels(self): return self.OffsetLabels
    def set_OffsetLabels(self, OffsetLabels): self.OffsetLabels = OffsetLabels
    def add_OffsetLabels(self, value): self.OffsetLabels.append(value)
    def insert_OffsetLabels(self, index, value): self.OffsetLabels[index] = value
    def get_HideEndLabels(self): return self.HideEndLabels
    def set_HideEndLabels(self, HideEndLabels): self.HideEndLabels = HideEndLabels
    def add_HideEndLabels(self, value): self.HideEndLabels.append(value)
    def insert_HideEndLabels(self, index, value): self.HideEndLabels[index] = value
    def get_ChartAxisScaleBreak(self): return self.ChartAxisScaleBreak
    def set_ChartAxisScaleBreak(self, ChartAxisScaleBreak): self.ChartAxisScaleBreak = ChartAxisScaleBreak
    def add_ChartAxisScaleBreak(self, value): self.ChartAxisScaleBreak.append(value)
    def insert_ChartAxisScaleBreak(self, index, value): self.ChartAxisScaleBreak[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAxisType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAxisType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAxisType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAxisType', fromsubclass_=False):
        for Visible_ in self.Visible:
            showIndent(outfile, level)
            outfile.write('<%sVisible>%s</%sVisible>\n' % (namespace_, self.gds_format_string(quote_xml(Visible_).encode(ExternalEncoding), input_name='Visible'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ChartAxisTitle_ in self.ChartAxisTitle:
            ChartAxisTitle_.export(outfile, level, namespace_, name_='ChartAxisTitle')
        for Margin_ in self.Margin:
            showIndent(outfile, level)
            outfile.write('<%sMargin>%s</%sMargin>\n' % (namespace_, self.gds_format_string(quote_xml(Margin_).encode(ExternalEncoding), input_name='Margin'), namespace_))
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalType>%s</%sIntervalType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalType_).encode(ExternalEncoding), input_name='IntervalType'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffsetType>%s</%sIntervalOffsetType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffsetType_).encode(ExternalEncoding), input_name='IntervalOffsetType'), namespace_))
        for VariableAutoInterval_ in self.VariableAutoInterval:
            showIndent(outfile, level)
            outfile.write('<%sVariableAutoInterval>%s</%sVariableAutoInterval>\n' % (namespace_, self.gds_format_string(quote_xml(VariableAutoInterval_).encode(ExternalEncoding), input_name='VariableAutoInterval'), namespace_))
        for LabelInterval_ in self.LabelInterval:
            showIndent(outfile, level)
            outfile.write('<%sLabelInterval>%s</%sLabelInterval>\n' % (namespace_, self.gds_format_string(quote_xml(LabelInterval_).encode(ExternalEncoding), input_name='LabelInterval'), namespace_))
        for LabelIntervalType_ in self.LabelIntervalType:
            showIndent(outfile, level)
            outfile.write('<%sLabelIntervalType>%s</%sLabelIntervalType>\n' % (namespace_, self.gds_format_string(quote_xml(LabelIntervalType_).encode(ExternalEncoding), input_name='LabelIntervalType'), namespace_))
        for LabelIntervalOffset_ in self.LabelIntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sLabelIntervalOffset>%s</%sLabelIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(LabelIntervalOffset_).encode(ExternalEncoding), input_name='LabelIntervalOffset'), namespace_))
        for LabelIntervalOffsetType_ in self.LabelIntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('<%sLabelIntervalOffsetType>%s</%sLabelIntervalOffsetType>\n' % (namespace_, self.gds_format_string(quote_xml(LabelIntervalOffsetType_).encode(ExternalEncoding), input_name='LabelIntervalOffsetType'), namespace_))
        for ChartMajorGridLines_ in self.ChartMajorGridLines:
            ChartMajorGridLines_.export(outfile, level, namespace_, name_='ChartMajorGridLines')
        for ChartMinorGridLines_ in self.ChartMinorGridLines:
            ChartMinorGridLines_.export(outfile, level, namespace_, name_='ChartMinorGridLines')
        for ChartMajorTickMarks_ in self.ChartMajorTickMarks:
            ChartMajorTickMarks_.export(outfile, level, namespace_, name_='ChartMajorTickMarks')
        for ChartMinorTickMarks_ in self.ChartMinorTickMarks:
            ChartMinorTickMarks_.export(outfile, level, namespace_, name_='ChartMinorTickMarks')
        for MarksAlwaysAtPlotEdge_ in self.MarksAlwaysAtPlotEdge:
            showIndent(outfile, level)
            outfile.write('<%sMarksAlwaysAtPlotEdge>%s</%sMarksAlwaysAtPlotEdge>\n' % (namespace_, self.gds_format_string(quote_xml(MarksAlwaysAtPlotEdge_).encode(ExternalEncoding), input_name='MarksAlwaysAtPlotEdge'), namespace_))
        for Reverse_ in self.Reverse:
            showIndent(outfile, level)
            outfile.write('<%sReverse>%s</%sReverse>\n' % (namespace_, self.gds_format_string(quote_xml(Reverse_).encode(ExternalEncoding), input_name='Reverse'), namespace_))
        for CrossAt_ in self.CrossAt:
            showIndent(outfile, level)
            outfile.write('<%sCrossAt>%s</%sCrossAt>\n' % (namespace_, self.gds_format_string(quote_xml(CrossAt_).encode(ExternalEncoding), input_name='CrossAt'), namespace_))
        for Location_ in self.Location:
            showIndent(outfile, level)
            outfile.write('<%sLocation>%s</%sLocation>\n' % (namespace_, self.gds_format_string(quote_xml(Location_).encode(ExternalEncoding), input_name='Location'), namespace_))
        for Interlaced_ in self.Interlaced:
            showIndent(outfile, level)
            outfile.write('<%sInterlaced>%s</%sInterlaced>\n' % (namespace_, self.gds_format_string(quote_xml(Interlaced_).encode(ExternalEncoding), input_name='Interlaced'), namespace_))
        for InterlacedColor_ in self.InterlacedColor:
            showIndent(outfile, level)
            outfile.write('<%sInterlacedColor>%s</%sInterlacedColor>\n' % (namespace_, self.gds_format_string(quote_xml(InterlacedColor_).encode(ExternalEncoding), input_name='InterlacedColor'), namespace_))
        for ChartStripLines_ in self.ChartStripLines:
            ChartStripLines_.export(outfile, level, namespace_, name_='ChartStripLines')
        for Arrows_ in self.Arrows:
            showIndent(outfile, level)
            outfile.write('<%sArrows>%s</%sArrows>\n' % (namespace_, self.gds_format_string(quote_xml(Arrows_).encode(ExternalEncoding), input_name='Arrows'), namespace_))
        for Scalar_ in self.Scalar:
            showIndent(outfile, level)
            outfile.write('<%sScalar>%s</%sScalar>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(Scalar_)), input_name='Scalar'), namespace_))
        for Minimum_ in self.Minimum:
            showIndent(outfile, level)
            outfile.write('<%sMinimum>%s</%sMinimum>\n' % (namespace_, self.gds_format_string(quote_xml(Minimum_).encode(ExternalEncoding), input_name='Minimum'), namespace_))
        for Maximum_ in self.Maximum:
            showIndent(outfile, level)
            outfile.write('<%sMaximum>%s</%sMaximum>\n' % (namespace_, self.gds_format_string(quote_xml(Maximum_).encode(ExternalEncoding), input_name='Maximum'), namespace_))
        for LogScale_ in self.LogScale:
            showIndent(outfile, level)
            outfile.write('<%sLogScale>%s</%sLogScale>\n' % (namespace_, self.gds_format_string(quote_xml(LogScale_).encode(ExternalEncoding), input_name='LogScale'), namespace_))
        for LogBase_ in self.LogBase:
            showIndent(outfile, level)
            outfile.write('<%sLogBase>%s</%sLogBase>\n' % (namespace_, self.gds_format_string(quote_xml(LogBase_).encode(ExternalEncoding), input_name='LogBase'), namespace_))
        for HideLabels_ in self.HideLabels:
            showIndent(outfile, level)
            outfile.write('<%sHideLabels>%s</%sHideLabels>\n' % (namespace_, self.gds_format_string(quote_xml(HideLabels_).encode(ExternalEncoding), input_name='HideLabels'), namespace_))
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('<%sAngle>%s</%sAngle>\n' % (namespace_, self.gds_format_string(quote_xml(Angle_).encode(ExternalEncoding), input_name='Angle'), namespace_))
        for PreventFontShrink_ in self.PreventFontShrink:
            showIndent(outfile, level)
            outfile.write('<%sPreventFontShrink>%s</%sPreventFontShrink>\n' % (namespace_, self.gds_format_string(quote_xml(PreventFontShrink_).encode(ExternalEncoding), input_name='PreventFontShrink'), namespace_))
        for PreventFontGrow_ in self.PreventFontGrow:
            showIndent(outfile, level)
            outfile.write('<%sPreventFontGrow>%s</%sPreventFontGrow>\n' % (namespace_, self.gds_format_string(quote_xml(PreventFontGrow_).encode(ExternalEncoding), input_name='PreventFontGrow'), namespace_))
        for PreventLabelOffset_ in self.PreventLabelOffset:
            showIndent(outfile, level)
            outfile.write('<%sPreventLabelOffset>%s</%sPreventLabelOffset>\n' % (namespace_, self.gds_format_string(quote_xml(PreventLabelOffset_).encode(ExternalEncoding), input_name='PreventLabelOffset'), namespace_))
        for PreventWordWrap_ in self.PreventWordWrap:
            showIndent(outfile, level)
            outfile.write('<%sPreventWordWrap>%s</%sPreventWordWrap>\n' % (namespace_, self.gds_format_string(quote_xml(PreventWordWrap_).encode(ExternalEncoding), input_name='PreventWordWrap'), namespace_))
        for AllowLabelRotation_ in self.AllowLabelRotation:
            showIndent(outfile, level)
            outfile.write('<%sAllowLabelRotation>%s</%sAllowLabelRotation>\n' % (namespace_, self.gds_format_string(quote_xml(AllowLabelRotation_).encode(ExternalEncoding), input_name='AllowLabelRotation'), namespace_))
        for IncludeZero_ in self.IncludeZero:
            showIndent(outfile, level)
            outfile.write('<%sIncludeZero>%s</%sIncludeZero>\n' % (namespace_, self.gds_format_string(quote_xml(IncludeZero_).encode(ExternalEncoding), input_name='IncludeZero'), namespace_))
        for LabelsAutoFitDisabled_ in self.LabelsAutoFitDisabled:
            showIndent(outfile, level)
            outfile.write('<%sLabelsAutoFitDisabled>%s</%sLabelsAutoFitDisabled>\n' % (namespace_, self.gds_format_string(quote_xml(LabelsAutoFitDisabled_).encode(ExternalEncoding), input_name='LabelsAutoFitDisabled'), namespace_))
        for MinFontSize_ in self.MinFontSize:
            showIndent(outfile, level)
            outfile.write('<%sMinFontSize>%s</%sMinFontSize>\n' % (namespace_, self.gds_format_string(quote_xml(MinFontSize_).encode(ExternalEncoding), input_name='MinFontSize'), namespace_))
        for MaxFontSize_ in self.MaxFontSize:
            showIndent(outfile, level)
            outfile.write('<%sMaxFontSize>%s</%sMaxFontSize>\n' % (namespace_, self.gds_format_string(quote_xml(MaxFontSize_).encode(ExternalEncoding), input_name='MaxFontSize'), namespace_))
        for OffsetLabels_ in self.OffsetLabels:
            showIndent(outfile, level)
            outfile.write('<%sOffsetLabels>%s</%sOffsetLabels>\n' % (namespace_, self.gds_format_string(quote_xml(OffsetLabels_).encode(ExternalEncoding), input_name='OffsetLabels'), namespace_))
        for HideEndLabels_ in self.HideEndLabels:
            showIndent(outfile, level)
            outfile.write('<%sHideEndLabels>%s</%sHideEndLabels>\n' % (namespace_, self.gds_format_string(quote_xml(HideEndLabels_).encode(ExternalEncoding), input_name='HideEndLabels'), namespace_))
        for ChartAxisScaleBreak_ in self.ChartAxisScaleBreak:
            ChartAxisScaleBreak_.export(outfile, level, namespace_, name_='ChartAxisScaleBreak')
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
    def hasContent_(self):
        if (
            self.Visible or
            self.Style or
            self.ChartAxisTitle or
            self.Margin or
            self.Interval or
            self.IntervalType or
            self.IntervalOffset or
            self.IntervalOffsetType or
            self.VariableAutoInterval or
            self.LabelInterval or
            self.LabelIntervalType or
            self.LabelIntervalOffset or
            self.LabelIntervalOffsetType or
            self.ChartMajorGridLines or
            self.ChartMinorGridLines or
            self.ChartMajorTickMarks or
            self.ChartMinorTickMarks or
            self.MarksAlwaysAtPlotEdge or
            self.Reverse or
            self.CrossAt or
            self.Location or
            self.Interlaced or
            self.InterlacedColor or
            self.ChartStripLines or
            self.Arrows or
            self.Scalar or
            self.Minimum or
            self.Maximum or
            self.LogScale or
            self.LogBase or
            self.HideLabels or
            self.Angle or
            self.PreventFontShrink or
            self.PreventFontGrow or
            self.PreventLabelOffset or
            self.PreventWordWrap or
            self.AllowLabelRotation or
            self.IncludeZero or
            self.LabelsAutoFitDisabled or
            self.MinFontSize or
            self.MaxFontSize or
            self.OffsetLabels or
            self.HideEndLabels or
            self.ChartAxisScaleBreak or
            self.CustomProperties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAxisType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Visible=[\n')
        level += 1
        for Visible_ in self.Visible:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Visible_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartAxisTitle=[\n')
        level += 1
        for ChartAxisTitle_ in self.ChartAxisTitle:
            showIndent(outfile, level)
            outfile.write('model_.ChartAxisTitleType(\n')
            ChartAxisTitle_.exportLiteral(outfile, level, name_='ChartAxisTitleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Margin=[\n')
        level += 1
        for Margin_ in self.Margin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Margin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalType=[\n')
        level += 1
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffsetType=[\n')
        level += 1
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffsetType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('VariableAutoInterval=[\n')
        level += 1
        for VariableAutoInterval_ in self.VariableAutoInterval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(VariableAutoInterval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LabelInterval=[\n')
        level += 1
        for LabelInterval_ in self.LabelInterval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LabelInterval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LabelIntervalType=[\n')
        level += 1
        for LabelIntervalType_ in self.LabelIntervalType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LabelIntervalType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LabelIntervalOffset=[\n')
        level += 1
        for LabelIntervalOffset_ in self.LabelIntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LabelIntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LabelIntervalOffsetType=[\n')
        level += 1
        for LabelIntervalOffsetType_ in self.LabelIntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LabelIntervalOffsetType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMajorGridLines=[\n')
        level += 1
        for ChartMajorGridLines_ in self.ChartMajorGridLines:
            showIndent(outfile, level)
            outfile.write('model_.ChartGridLinesType(\n')
            ChartMajorGridLines_.exportLiteral(outfile, level, name_='ChartGridLinesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMinorGridLines=[\n')
        level += 1
        for ChartMinorGridLines_ in self.ChartMinorGridLines:
            showIndent(outfile, level)
            outfile.write('model_.ChartGridLinesType(\n')
            ChartMinorGridLines_.exportLiteral(outfile, level, name_='ChartGridLinesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMajorTickMarks=[\n')
        level += 1
        for ChartMajorTickMarks_ in self.ChartMajorTickMarks:
            showIndent(outfile, level)
            outfile.write('model_.ChartTickMarksType(\n')
            ChartMajorTickMarks_.exportLiteral(outfile, level, name_='ChartTickMarksType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMinorTickMarks=[\n')
        level += 1
        for ChartMinorTickMarks_ in self.ChartMinorTickMarks:
            showIndent(outfile, level)
            outfile.write('model_.ChartTickMarksType(\n')
            ChartMinorTickMarks_.exportLiteral(outfile, level, name_='ChartTickMarksType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarksAlwaysAtPlotEdge=[\n')
        level += 1
        for MarksAlwaysAtPlotEdge_ in self.MarksAlwaysAtPlotEdge:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarksAlwaysAtPlotEdge_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Reverse=[\n')
        level += 1
        for Reverse_ in self.Reverse:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reverse_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CrossAt=[\n')
        level += 1
        for CrossAt_ in self.CrossAt:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CrossAt_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Location=[\n')
        level += 1
        for Location_ in self.Location:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Location_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interlaced=[\n')
        level += 1
        for Interlaced_ in self.Interlaced:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interlaced_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InterlacedColor=[\n')
        level += 1
        for InterlacedColor_ in self.InterlacedColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InterlacedColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartStripLines=[\n')
        level += 1
        for ChartStripLines_ in self.ChartStripLines:
            showIndent(outfile, level)
            outfile.write('model_.ChartStripLinesType(\n')
            ChartStripLines_.exportLiteral(outfile, level, name_='ChartStripLinesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Arrows=[\n')
        level += 1
        for Arrows_ in self.Arrows:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Arrows_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Scalar=[\n')
        level += 1
        for Scalar_ in self.Scalar:
            showIndent(outfile, level)
            outfile.write('%s,\n' % Scalar)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Minimum=[\n')
        level += 1
        for Minimum_ in self.Minimum:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Minimum_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Maximum=[\n')
        level += 1
        for Maximum_ in self.Maximum:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Maximum_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LogScale=[\n')
        level += 1
        for LogScale_ in self.LogScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LogScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LogBase=[\n')
        level += 1
        for LogBase_ in self.LogBase:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LogBase_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HideLabels=[\n')
        level += 1
        for HideLabels_ in self.HideLabels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HideLabels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Angle=[\n')
        level += 1
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Angle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PreventFontShrink=[\n')
        level += 1
        for PreventFontShrink_ in self.PreventFontShrink:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PreventFontShrink_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PreventFontGrow=[\n')
        level += 1
        for PreventFontGrow_ in self.PreventFontGrow:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PreventFontGrow_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PreventLabelOffset=[\n')
        level += 1
        for PreventLabelOffset_ in self.PreventLabelOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PreventLabelOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PreventWordWrap=[\n')
        level += 1
        for PreventWordWrap_ in self.PreventWordWrap:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PreventWordWrap_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllowLabelRotation=[\n')
        level += 1
        for AllowLabelRotation_ in self.AllowLabelRotation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllowLabelRotation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IncludeZero=[\n')
        level += 1
        for IncludeZero_ in self.IncludeZero:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IncludeZero_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LabelsAutoFitDisabled=[\n')
        level += 1
        for LabelsAutoFitDisabled_ in self.LabelsAutoFitDisabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LabelsAutoFitDisabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinFontSize=[\n')
        level += 1
        for MinFontSize_ in self.MinFontSize:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MinFontSize_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaxFontSize=[\n')
        level += 1
        for MaxFontSize_ in self.MaxFontSize:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MaxFontSize_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffsetLabels=[\n')
        level += 1
        for OffsetLabels_ in self.OffsetLabels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OffsetLabels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HideEndLabels=[\n')
        level += 1
        for HideEndLabels_ in self.HideEndLabels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HideEndLabels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartAxisScaleBreak=[\n')
        level += 1
        for ChartAxisScaleBreak_ in self.ChartAxisScaleBreak:
            showIndent(outfile, level)
            outfile.write('model_.ChartAxisScaleBreakType(\n')
            ChartAxisScaleBreak_.exportLiteral(outfile, level, name_='ChartAxisScaleBreakType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Visible':
            Visible_ = child_.text
            Visible_ = self.gds_validate_string(Visible_, node, 'Visible')
            self.Visible.append(Visible_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ChartAxisTitle':
            obj_ = ChartAxisTitleType.factory()
            obj_.build(child_)
            self.ChartAxisTitle.append(obj_)
        elif nodeName_ == 'Margin':
            Margin_ = child_.text
            Margin_ = self.gds_validate_string(Margin_, node, 'Margin')
            self.Margin.append(Margin_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalType':
            IntervalType_ = child_.text
            IntervalType_ = self.gds_validate_string(IntervalType_, node, 'IntervalType')
            self.IntervalType.append(IntervalType_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'IntervalOffsetType':
            IntervalOffsetType_ = child_.text
            IntervalOffsetType_ = self.gds_validate_string(IntervalOffsetType_, node, 'IntervalOffsetType')
            self.IntervalOffsetType.append(IntervalOffsetType_)
        elif nodeName_ == 'VariableAutoInterval':
            VariableAutoInterval_ = child_.text
            VariableAutoInterval_ = self.gds_validate_string(VariableAutoInterval_, node, 'VariableAutoInterval')
            self.VariableAutoInterval.append(VariableAutoInterval_)
        elif nodeName_ == 'LabelInterval':
            LabelInterval_ = child_.text
            LabelInterval_ = self.gds_validate_string(LabelInterval_, node, 'LabelInterval')
            self.LabelInterval.append(LabelInterval_)
        elif nodeName_ == 'LabelIntervalType':
            LabelIntervalType_ = child_.text
            LabelIntervalType_ = self.gds_validate_string(LabelIntervalType_, node, 'LabelIntervalType')
            self.LabelIntervalType.append(LabelIntervalType_)
        elif nodeName_ == 'LabelIntervalOffset':
            LabelIntervalOffset_ = child_.text
            LabelIntervalOffset_ = self.gds_validate_string(LabelIntervalOffset_, node, 'LabelIntervalOffset')
            self.LabelIntervalOffset.append(LabelIntervalOffset_)
        elif nodeName_ == 'LabelIntervalOffsetType':
            LabelIntervalOffsetType_ = child_.text
            LabelIntervalOffsetType_ = self.gds_validate_string(LabelIntervalOffsetType_, node, 'LabelIntervalOffsetType')
            self.LabelIntervalOffsetType.append(LabelIntervalOffsetType_)
        elif nodeName_ == 'ChartMajorGridLines':
            obj_ = ChartGridLinesType.factory()
            obj_.build(child_)
            self.ChartMajorGridLines.append(obj_)
        elif nodeName_ == 'ChartMinorGridLines':
            obj_ = ChartGridLinesType.factory()
            obj_.build(child_)
            self.ChartMinorGridLines.append(obj_)
        elif nodeName_ == 'ChartMajorTickMarks':
            obj_ = ChartTickMarksType.factory()
            obj_.build(child_)
            self.ChartMajorTickMarks.append(obj_)
        elif nodeName_ == 'ChartMinorTickMarks':
            obj_ = ChartTickMarksType.factory()
            obj_.build(child_)
            self.ChartMinorTickMarks.append(obj_)
        elif nodeName_ == 'MarksAlwaysAtPlotEdge':
            MarksAlwaysAtPlotEdge_ = child_.text
            MarksAlwaysAtPlotEdge_ = self.gds_validate_string(MarksAlwaysAtPlotEdge_, node, 'MarksAlwaysAtPlotEdge')
            self.MarksAlwaysAtPlotEdge.append(MarksAlwaysAtPlotEdge_)
        elif nodeName_ == 'Reverse':
            Reverse_ = child_.text
            Reverse_ = self.gds_validate_string(Reverse_, node, 'Reverse')
            self.Reverse.append(Reverse_)
        elif nodeName_ == 'CrossAt':
            CrossAt_ = child_.text
            CrossAt_ = self.gds_validate_string(CrossAt_, node, 'CrossAt')
            self.CrossAt.append(CrossAt_)
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location.append(Location_)
        elif nodeName_ == 'Interlaced':
            Interlaced_ = child_.text
            Interlaced_ = self.gds_validate_string(Interlaced_, node, 'Interlaced')
            self.Interlaced.append(Interlaced_)
        elif nodeName_ == 'InterlacedColor':
            InterlacedColor_ = child_.text
            InterlacedColor_ = self.gds_validate_string(InterlacedColor_, node, 'InterlacedColor')
            self.InterlacedColor.append(InterlacedColor_)
        elif nodeName_ == 'ChartStripLines':
            obj_ = ChartStripLinesType.factory()
            obj_.build(child_)
            self.ChartStripLines.append(obj_)
        elif nodeName_ == 'Arrows':
            Arrows_ = child_.text
            Arrows_ = self.gds_validate_string(Arrows_, node, 'Arrows')
            self.Arrows.append(Arrows_)
        elif nodeName_ == 'Scalar':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Scalar')
            self.Scalar.append(ival_)
        elif nodeName_ == 'Minimum':
            Minimum_ = child_.text
            Minimum_ = self.gds_validate_string(Minimum_, node, 'Minimum')
            self.Minimum.append(Minimum_)
        elif nodeName_ == 'Maximum':
            Maximum_ = child_.text
            Maximum_ = self.gds_validate_string(Maximum_, node, 'Maximum')
            self.Maximum.append(Maximum_)
        elif nodeName_ == 'LogScale':
            LogScale_ = child_.text
            LogScale_ = self.gds_validate_string(LogScale_, node, 'LogScale')
            self.LogScale.append(LogScale_)
        elif nodeName_ == 'LogBase':
            LogBase_ = child_.text
            LogBase_ = self.gds_validate_string(LogBase_, node, 'LogBase')
            self.LogBase.append(LogBase_)
        elif nodeName_ == 'HideLabels':
            HideLabels_ = child_.text
            HideLabels_ = self.gds_validate_string(HideLabels_, node, 'HideLabels')
            self.HideLabels.append(HideLabels_)
        elif nodeName_ == 'Angle':
            Angle_ = child_.text
            Angle_ = self.gds_validate_string(Angle_, node, 'Angle')
            self.Angle.append(Angle_)
        elif nodeName_ == 'PreventFontShrink':
            PreventFontShrink_ = child_.text
            PreventFontShrink_ = self.gds_validate_string(PreventFontShrink_, node, 'PreventFontShrink')
            self.PreventFontShrink.append(PreventFontShrink_)
        elif nodeName_ == 'PreventFontGrow':
            PreventFontGrow_ = child_.text
            PreventFontGrow_ = self.gds_validate_string(PreventFontGrow_, node, 'PreventFontGrow')
            self.PreventFontGrow.append(PreventFontGrow_)
        elif nodeName_ == 'PreventLabelOffset':
            PreventLabelOffset_ = child_.text
            PreventLabelOffset_ = self.gds_validate_string(PreventLabelOffset_, node, 'PreventLabelOffset')
            self.PreventLabelOffset.append(PreventLabelOffset_)
        elif nodeName_ == 'PreventWordWrap':
            PreventWordWrap_ = child_.text
            PreventWordWrap_ = self.gds_validate_string(PreventWordWrap_, node, 'PreventWordWrap')
            self.PreventWordWrap.append(PreventWordWrap_)
        elif nodeName_ == 'AllowLabelRotation':
            AllowLabelRotation_ = child_.text
            AllowLabelRotation_ = self.gds_validate_string(AllowLabelRotation_, node, 'AllowLabelRotation')
            self.AllowLabelRotation.append(AllowLabelRotation_)
        elif nodeName_ == 'IncludeZero':
            IncludeZero_ = child_.text
            IncludeZero_ = self.gds_validate_string(IncludeZero_, node, 'IncludeZero')
            self.IncludeZero.append(IncludeZero_)
        elif nodeName_ == 'LabelsAutoFitDisabled':
            LabelsAutoFitDisabled_ = child_.text
            LabelsAutoFitDisabled_ = self.gds_validate_string(LabelsAutoFitDisabled_, node, 'LabelsAutoFitDisabled')
            self.LabelsAutoFitDisabled.append(LabelsAutoFitDisabled_)
        elif nodeName_ == 'MinFontSize':
            MinFontSize_ = child_.text
            MinFontSize_ = self.gds_validate_string(MinFontSize_, node, 'MinFontSize')
            self.MinFontSize.append(MinFontSize_)
        elif nodeName_ == 'MaxFontSize':
            MaxFontSize_ = child_.text
            MaxFontSize_ = self.gds_validate_string(MaxFontSize_, node, 'MaxFontSize')
            self.MaxFontSize.append(MaxFontSize_)
        elif nodeName_ == 'OffsetLabels':
            OffsetLabels_ = child_.text
            OffsetLabels_ = self.gds_validate_string(OffsetLabels_, node, 'OffsetLabels')
            self.OffsetLabels.append(OffsetLabels_)
        elif nodeName_ == 'HideEndLabels':
            HideEndLabels_ = child_.text
            HideEndLabels_ = self.gds_validate_string(HideEndLabels_, node, 'HideEndLabels')
            self.HideEndLabels.append(HideEndLabels_)
        elif nodeName_ == 'ChartAxisScaleBreak':
            obj_ = ChartAxisScaleBreakType.factory()
            obj_.build(child_)
            self.ChartAxisScaleBreak.append(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
# end class ChartAxisType


class ChartAxisTitleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Caption=None, Position=None, Style=None, TextOrientation=None):
        if Caption is None:
            self.Caption = []
        else:
            self.Caption = Caption
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if TextOrientation is None:
            self.TextOrientation = []
        else:
            self.TextOrientation = TextOrientation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAxisTitleType.subclass:
            return ChartAxisTitleType.subclass(*args_, **kwargs_)
        else:
            return ChartAxisTitleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def add_Caption(self, value): self.Caption.append(value)
    def insert_Caption(self, index, value): self.Caption[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_TextOrientation(self): return self.TextOrientation
    def set_TextOrientation(self, TextOrientation): self.TextOrientation = TextOrientation
    def add_TextOrientation(self, value): self.TextOrientation.append(value)
    def insert_TextOrientation(self, index, value): self.TextOrientation[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAxisTitleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAxisTitleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAxisTitleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAxisTitleType', fromsubclass_=False):
        for Caption_ in self.Caption:
            Caption_.export(outfile, level, namespace_, name_='Caption')
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for TextOrientation_ in self.TextOrientation:
            showIndent(outfile, level)
            outfile.write('<%sTextOrientation>%s</%sTextOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(TextOrientation_).encode(ExternalEncoding), input_name='TextOrientation'), namespace_))
    def hasContent_(self):
        if (
            self.Caption or
            self.Position or
            self.Style or
            self.TextOrientation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAxisTitleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Caption=[\n')
        level += 1
        for Caption_ in self.Caption:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Caption_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextOrientation=[\n')
        level += 1
        for TextOrientation_ in self.TextOrientation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextOrientation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Caption':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Caption.append(obj_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'TextOrientation':
            TextOrientation_ = child_.text
            TextOrientation_ = self.gds_validate_string(TextOrientation_, node, 'TextOrientation')
            self.TextOrientation.append(TextOrientation_)
# end class ChartAxisTitleType


class ChartStripLinesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartStripLine=None):
        if ChartStripLine is None:
            self.ChartStripLine = []
        else:
            self.ChartStripLine = ChartStripLine
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartStripLinesType.subclass:
            return ChartStripLinesType.subclass(*args_, **kwargs_)
        else:
            return ChartStripLinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartStripLine(self): return self.ChartStripLine
    def set_ChartStripLine(self, ChartStripLine): self.ChartStripLine = ChartStripLine
    def add_ChartStripLine(self, value): self.ChartStripLine.append(value)
    def insert_ChartStripLine(self, index, value): self.ChartStripLine[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartStripLinesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartStripLinesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartStripLinesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartStripLinesType', fromsubclass_=False):
        for ChartStripLine_ in self.ChartStripLine:
            ChartStripLine_.export(outfile, level, namespace_, name_='ChartStripLine')
    def hasContent_(self):
        if (
            self.ChartStripLine
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartStripLinesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartStripLine=[\n')
        level += 1
        for ChartStripLine_ in self.ChartStripLine:
            showIndent(outfile, level)
            outfile.write('model_.ChartStripLineType(\n')
            ChartStripLine_.exportLiteral(outfile, level, name_='ChartStripLineType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartStripLine':
            obj_ = ChartStripLineType.factory()
            obj_.build(child_)
            self.ChartStripLine.append(obj_)
# end class ChartStripLinesType


class ChartStripLineType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, Title=None, TitleAngle=None, TextOrientation=None, ActionInfo=None, ToolTip=None, Interval=None, IntervalType=None, IntervalOffset=None, IntervalOffsetType=None, StripWidth=None, StripWidthType=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Title is None:
            self.Title = []
        else:
            self.Title = Title
        if TitleAngle is None:
            self.TitleAngle = []
        else:
            self.TitleAngle = TitleAngle
        if TextOrientation is None:
            self.TextOrientation = []
        else:
            self.TextOrientation = TextOrientation
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalType is None:
            self.IntervalType = []
        else:
            self.IntervalType = IntervalType
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if IntervalOffsetType is None:
            self.IntervalOffsetType = []
        else:
            self.IntervalOffsetType = IntervalOffsetType
        if StripWidth is None:
            self.StripWidth = []
        else:
            self.StripWidth = StripWidth
        if StripWidthType is None:
            self.StripWidthType = []
        else:
            self.StripWidthType = StripWidthType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartStripLineType.subclass:
            return ChartStripLineType.subclass(*args_, **kwargs_)
        else:
            return ChartStripLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def add_Title(self, value): self.Title.append(value)
    def insert_Title(self, index, value): self.Title[index] = value
    def get_TitleAngle(self): return self.TitleAngle
    def set_TitleAngle(self, TitleAngle): self.TitleAngle = TitleAngle
    def add_TitleAngle(self, value): self.TitleAngle.append(value)
    def insert_TitleAngle(self, index, value): self.TitleAngle[index] = value
    def get_TextOrientation(self): return self.TextOrientation
    def set_TextOrientation(self, TextOrientation): self.TextOrientation = TextOrientation
    def add_TextOrientation(self, value): self.TextOrientation.append(value)
    def insert_TextOrientation(self, index, value): self.TextOrientation[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalType(self): return self.IntervalType
    def set_IntervalType(self, IntervalType): self.IntervalType = IntervalType
    def add_IntervalType(self, value): self.IntervalType.append(value)
    def insert_IntervalType(self, index, value): self.IntervalType[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_IntervalOffsetType(self): return self.IntervalOffsetType
    def set_IntervalOffsetType(self, IntervalOffsetType): self.IntervalOffsetType = IntervalOffsetType
    def add_IntervalOffsetType(self, value): self.IntervalOffsetType.append(value)
    def insert_IntervalOffsetType(self, index, value): self.IntervalOffsetType[index] = value
    def get_StripWidth(self): return self.StripWidth
    def set_StripWidth(self, StripWidth): self.StripWidth = StripWidth
    def add_StripWidth(self, value): self.StripWidth.append(value)
    def insert_StripWidth(self, index, value): self.StripWidth[index] = value
    def get_StripWidthType(self): return self.StripWidthType
    def set_StripWidthType(self, StripWidthType): self.StripWidthType = StripWidthType
    def add_StripWidthType(self, value): self.StripWidthType.append(value)
    def insert_StripWidthType(self, index, value): self.StripWidthType[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartStripLineType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartStripLineType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartStripLineType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartStripLineType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Title_ in self.Title:
            showIndent(outfile, level)
            outfile.write('<%sTitle>%s</%sTitle>\n' % (namespace_, self.gds_format_string(quote_xml(Title_).encode(ExternalEncoding), input_name='Title'), namespace_))
        for TitleAngle_ in self.TitleAngle:
            showIndent(outfile, level)
            outfile.write('<%sTitleAngle>%s</%sTitleAngle>\n' % (namespace_, self.gds_format_string(quote_xml(TitleAngle_).encode(ExternalEncoding), input_name='TitleAngle'), namespace_))
        for TextOrientation_ in self.TextOrientation:
            showIndent(outfile, level)
            outfile.write('<%sTextOrientation>%s</%sTextOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(TextOrientation_).encode(ExternalEncoding), input_name='TextOrientation'), namespace_))
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalType>%s</%sIntervalType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalType_).encode(ExternalEncoding), input_name='IntervalType'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffsetType>%s</%sIntervalOffsetType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffsetType_).encode(ExternalEncoding), input_name='IntervalOffsetType'), namespace_))
        for StripWidth_ in self.StripWidth:
            showIndent(outfile, level)
            outfile.write('<%sStripWidth>%s</%sStripWidth>\n' % (namespace_, self.gds_format_string(quote_xml(StripWidth_).encode(ExternalEncoding), input_name='StripWidth'), namespace_))
        for StripWidthType_ in self.StripWidthType:
            showIndent(outfile, level)
            outfile.write('<%sStripWidthType>%s</%sStripWidthType>\n' % (namespace_, self.gds_format_string(quote_xml(StripWidthType_).encode(ExternalEncoding), input_name='StripWidthType'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.Title or
            self.TitleAngle or
            self.TextOrientation or
            self.ActionInfo or
            self.ToolTip or
            self.Interval or
            self.IntervalType or
            self.IntervalOffset or
            self.IntervalOffsetType or
            self.StripWidth or
            self.StripWidthType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartStripLineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Title=[\n')
        level += 1
        for Title_ in self.Title:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Title_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TitleAngle=[\n')
        level += 1
        for TitleAngle_ in self.TitleAngle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TitleAngle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextOrientation=[\n')
        level += 1
        for TextOrientation_ in self.TextOrientation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextOrientation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalType=[\n')
        level += 1
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffsetType=[\n')
        level += 1
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffsetType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StripWidth=[\n')
        level += 1
        for StripWidth_ in self.StripWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StripWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StripWidthType=[\n')
        level += 1
        for StripWidthType_ in self.StripWidthType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StripWidthType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title.append(Title_)
        elif nodeName_ == 'TitleAngle':
            TitleAngle_ = child_.text
            TitleAngle_ = self.gds_validate_string(TitleAngle_, node, 'TitleAngle')
            self.TitleAngle.append(TitleAngle_)
        elif nodeName_ == 'TextOrientation':
            TextOrientation_ = child_.text
            TextOrientation_ = self.gds_validate_string(TextOrientation_, node, 'TextOrientation')
            self.TextOrientation.append(TextOrientation_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalType':
            IntervalType_ = child_.text
            IntervalType_ = self.gds_validate_string(IntervalType_, node, 'IntervalType')
            self.IntervalType.append(IntervalType_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'IntervalOffsetType':
            IntervalOffsetType_ = child_.text
            IntervalOffsetType_ = self.gds_validate_string(IntervalOffsetType_, node, 'IntervalOffsetType')
            self.IntervalOffsetType.append(IntervalOffsetType_)
        elif nodeName_ == 'StripWidth':
            StripWidth_ = child_.text
            StripWidth_ = self.gds_validate_string(StripWidth_, node, 'StripWidth')
            self.StripWidth.append(StripWidth_)
        elif nodeName_ == 'StripWidthType':
            StripWidthType_ = child_.text
            StripWidthType_ = self.gds_validate_string(StripWidthType_, node, 'StripWidthType')
            self.StripWidthType.append(StripWidthType_)
# end class ChartStripLineType


class ChartAxisScaleBreakType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Enabled=None, BreakLineType=None, CollapsibleSpaceThreshold=None, MaxNumberOfBreaks=None, Spacing=None, IncludeZero=None, Style=None):
        if Enabled is None:
            self.Enabled = []
        else:
            self.Enabled = Enabled
        if BreakLineType is None:
            self.BreakLineType = []
        else:
            self.BreakLineType = BreakLineType
        if CollapsibleSpaceThreshold is None:
            self.CollapsibleSpaceThreshold = []
        else:
            self.CollapsibleSpaceThreshold = CollapsibleSpaceThreshold
        if MaxNumberOfBreaks is None:
            self.MaxNumberOfBreaks = []
        else:
            self.MaxNumberOfBreaks = MaxNumberOfBreaks
        if Spacing is None:
            self.Spacing = []
        else:
            self.Spacing = Spacing
        if IncludeZero is None:
            self.IncludeZero = []
        else:
            self.IncludeZero = IncludeZero
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAxisScaleBreakType.subclass:
            return ChartAxisScaleBreakType.subclass(*args_, **kwargs_)
        else:
            return ChartAxisScaleBreakType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def add_Enabled(self, value): self.Enabled.append(value)
    def insert_Enabled(self, index, value): self.Enabled[index] = value
    def get_BreakLineType(self): return self.BreakLineType
    def set_BreakLineType(self, BreakLineType): self.BreakLineType = BreakLineType
    def add_BreakLineType(self, value): self.BreakLineType.append(value)
    def insert_BreakLineType(self, index, value): self.BreakLineType[index] = value
    def get_CollapsibleSpaceThreshold(self): return self.CollapsibleSpaceThreshold
    def set_CollapsibleSpaceThreshold(self, CollapsibleSpaceThreshold): self.CollapsibleSpaceThreshold = CollapsibleSpaceThreshold
    def add_CollapsibleSpaceThreshold(self, value): self.CollapsibleSpaceThreshold.append(value)
    def insert_CollapsibleSpaceThreshold(self, index, value): self.CollapsibleSpaceThreshold[index] = value
    def get_MaxNumberOfBreaks(self): return self.MaxNumberOfBreaks
    def set_MaxNumberOfBreaks(self, MaxNumberOfBreaks): self.MaxNumberOfBreaks = MaxNumberOfBreaks
    def add_MaxNumberOfBreaks(self, value): self.MaxNumberOfBreaks.append(value)
    def insert_MaxNumberOfBreaks(self, index, value): self.MaxNumberOfBreaks[index] = value
    def get_Spacing(self): return self.Spacing
    def set_Spacing(self, Spacing): self.Spacing = Spacing
    def add_Spacing(self, value): self.Spacing.append(value)
    def insert_Spacing(self, index, value): self.Spacing[index] = value
    def get_IncludeZero(self): return self.IncludeZero
    def set_IncludeZero(self, IncludeZero): self.IncludeZero = IncludeZero
    def add_IncludeZero(self, value): self.IncludeZero.append(value)
    def insert_IncludeZero(self, index, value): self.IncludeZero[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAxisScaleBreakType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAxisScaleBreakType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAxisScaleBreakType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAxisScaleBreakType', fromsubclass_=False):
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('<%sEnabled>%s</%sEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(Enabled_).encode(ExternalEncoding), input_name='Enabled'), namespace_))
        for BreakLineType_ in self.BreakLineType:
            showIndent(outfile, level)
            outfile.write('<%sBreakLineType>%s</%sBreakLineType>\n' % (namespace_, self.gds_format_string(quote_xml(BreakLineType_).encode(ExternalEncoding), input_name='BreakLineType'), namespace_))
        for CollapsibleSpaceThreshold_ in self.CollapsibleSpaceThreshold:
            showIndent(outfile, level)
            outfile.write('<%sCollapsibleSpaceThreshold>%s</%sCollapsibleSpaceThreshold>\n' % (namespace_, self.gds_format_string(quote_xml(CollapsibleSpaceThreshold_).encode(ExternalEncoding), input_name='CollapsibleSpaceThreshold'), namespace_))
        for MaxNumberOfBreaks_ in self.MaxNumberOfBreaks:
            showIndent(outfile, level)
            outfile.write('<%sMaxNumberOfBreaks>%s</%sMaxNumberOfBreaks>\n' % (namespace_, self.gds_format_string(quote_xml(MaxNumberOfBreaks_).encode(ExternalEncoding), input_name='MaxNumberOfBreaks'), namespace_))
        for Spacing_ in self.Spacing:
            showIndent(outfile, level)
            outfile.write('<%sSpacing>%s</%sSpacing>\n' % (namespace_, self.gds_format_string(quote_xml(Spacing_).encode(ExternalEncoding), input_name='Spacing'), namespace_))
        for IncludeZero_ in self.IncludeZero:
            showIndent(outfile, level)
            outfile.write('<%sIncludeZero>%s</%sIncludeZero>\n' % (namespace_, self.gds_format_string(quote_xml(IncludeZero_).encode(ExternalEncoding), input_name='IncludeZero'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.Enabled or
            self.BreakLineType or
            self.CollapsibleSpaceThreshold or
            self.MaxNumberOfBreaks or
            self.Spacing or
            self.IncludeZero or
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAxisScaleBreakType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Enabled=[\n')
        level += 1
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Enabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BreakLineType=[\n')
        level += 1
        for BreakLineType_ in self.BreakLineType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BreakLineType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CollapsibleSpaceThreshold=[\n')
        level += 1
        for CollapsibleSpaceThreshold_ in self.CollapsibleSpaceThreshold:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CollapsibleSpaceThreshold_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaxNumberOfBreaks=[\n')
        level += 1
        for MaxNumberOfBreaks_ in self.MaxNumberOfBreaks:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MaxNumberOfBreaks_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Spacing=[\n')
        level += 1
        for Spacing_ in self.Spacing:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Spacing_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IncludeZero=[\n')
        level += 1
        for IncludeZero_ in self.IncludeZero:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IncludeZero_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            Enabled_ = child_.text
            Enabled_ = self.gds_validate_string(Enabled_, node, 'Enabled')
            self.Enabled.append(Enabled_)
        elif nodeName_ == 'BreakLineType':
            BreakLineType_ = child_.text
            BreakLineType_ = self.gds_validate_string(BreakLineType_, node, 'BreakLineType')
            self.BreakLineType.append(BreakLineType_)
        elif nodeName_ == 'CollapsibleSpaceThreshold':
            CollapsibleSpaceThreshold_ = child_.text
            CollapsibleSpaceThreshold_ = self.gds_validate_string(CollapsibleSpaceThreshold_, node, 'CollapsibleSpaceThreshold')
            self.CollapsibleSpaceThreshold.append(CollapsibleSpaceThreshold_)
        elif nodeName_ == 'MaxNumberOfBreaks':
            MaxNumberOfBreaks_ = child_.text
            MaxNumberOfBreaks_ = self.gds_validate_string(MaxNumberOfBreaks_, node, 'MaxNumberOfBreaks')
            self.MaxNumberOfBreaks.append(MaxNumberOfBreaks_)
        elif nodeName_ == 'Spacing':
            Spacing_ = child_.text
            Spacing_ = self.gds_validate_string(Spacing_, node, 'Spacing')
            self.Spacing.append(Spacing_)
        elif nodeName_ == 'IncludeZero':
            IncludeZero_ = child_.text
            IncludeZero_ = self.gds_validate_string(IncludeZero_, node, 'IncludeZero')
            self.IncludeZero.append(IncludeZero_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class ChartAxisScaleBreakType


class ChartDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartSeriesCollection=None, ChartDerivedSeriesCollection=None):
        self.ChartSeriesCollection = ChartSeriesCollection
        if ChartDerivedSeriesCollection is None:
            self.ChartDerivedSeriesCollection = []
        else:
            self.ChartDerivedSeriesCollection = ChartDerivedSeriesCollection
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDataType.subclass:
            return ChartDataType.subclass(*args_, **kwargs_)
        else:
            return ChartDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartSeriesCollection(self): return self.ChartSeriesCollection
    def set_ChartSeriesCollection(self, ChartSeriesCollection): self.ChartSeriesCollection = ChartSeriesCollection
    def get_ChartDerivedSeriesCollection(self): return self.ChartDerivedSeriesCollection
    def set_ChartDerivedSeriesCollection(self, ChartDerivedSeriesCollection): self.ChartDerivedSeriesCollection = ChartDerivedSeriesCollection
    def add_ChartDerivedSeriesCollection(self, value): self.ChartDerivedSeriesCollection.append(value)
    def insert_ChartDerivedSeriesCollection(self, index, value): self.ChartDerivedSeriesCollection[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDataType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDataType', fromsubclass_=False):
        if self.ChartSeriesCollection:
            self.ChartSeriesCollection.export(outfile, level, namespace_, name_='ChartSeriesCollection', )
        for ChartDerivedSeriesCollection_ in self.ChartDerivedSeriesCollection:
            ChartDerivedSeriesCollection_.export(outfile, level, namespace_, name_='ChartDerivedSeriesCollection')
    def hasContent_(self):
        if (
            self.ChartSeriesCollection is not None or
            self.ChartDerivedSeriesCollection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ChartSeriesCollection is not None:
            showIndent(outfile, level)
            outfile.write('ChartSeriesCollection=model_.ChartSeriesCollectionType(\n')
            self.ChartSeriesCollection.exportLiteral(outfile, level, name_='ChartSeriesCollection')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ChartDerivedSeriesCollection=[\n')
        level += 1
        for ChartDerivedSeriesCollection_ in self.ChartDerivedSeriesCollection:
            showIndent(outfile, level)
            outfile.write('model_.ChartDerivedSeriesCollectionType(\n')
            ChartDerivedSeriesCollection_.exportLiteral(outfile, level, name_='ChartDerivedSeriesCollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartSeriesCollection':
            obj_ = ChartSeriesCollectionType.factory()
            obj_.build(child_)
            self.set_ChartSeriesCollection(obj_)
        elif nodeName_ == 'ChartDerivedSeriesCollection':
            obj_ = ChartDerivedSeriesCollectionType.factory()
            obj_.build(child_)
            self.ChartDerivedSeriesCollection.append(obj_)
# end class ChartDataType


class ChartSeriesCollectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartSeries=None):
        if ChartSeries is None:
            self.ChartSeries = []
        else:
            self.ChartSeries = ChartSeries
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartSeriesCollectionType.subclass:
            return ChartSeriesCollectionType.subclass(*args_, **kwargs_)
        else:
            return ChartSeriesCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartSeries(self): return self.ChartSeries
    def set_ChartSeries(self, ChartSeries): self.ChartSeries = ChartSeries
    def add_ChartSeries(self, value): self.ChartSeries.append(value)
    def insert_ChartSeries(self, index, value): self.ChartSeries[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartSeriesCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartSeriesCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartSeriesCollectionType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartSeriesCollectionType', fromsubclass_=False):
        for ChartSeries_ in self.ChartSeries:
            ChartSeries_.export(outfile, level, namespace_, name_='ChartSeries')
    def hasContent_(self):
        if (
            self.ChartSeries
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartSeriesCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartSeries=[\n')
        level += 1
        for ChartSeries_ in self.ChartSeries:
            showIndent(outfile, level)
            outfile.write('model_.ChartSeriesType(\n')
            ChartSeries_.exportLiteral(outfile, level, name_='ChartSeriesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartSeries':
            obj_ = ChartSeriesType.factory()
            obj_.build(child_)
            self.ChartSeries.append(obj_)
# end class ChartSeriesCollectionType


class ChartDerivedSeriesCollectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartDerivedSeries=None):
        if ChartDerivedSeries is None:
            self.ChartDerivedSeries = []
        else:
            self.ChartDerivedSeries = ChartDerivedSeries
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDerivedSeriesCollectionType.subclass:
            return ChartDerivedSeriesCollectionType.subclass(*args_, **kwargs_)
        else:
            return ChartDerivedSeriesCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartDerivedSeries(self): return self.ChartDerivedSeries
    def set_ChartDerivedSeries(self, ChartDerivedSeries): self.ChartDerivedSeries = ChartDerivedSeries
    def add_ChartDerivedSeries(self, value): self.ChartDerivedSeries.append(value)
    def insert_ChartDerivedSeries(self, index, value): self.ChartDerivedSeries[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDerivedSeriesCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDerivedSeriesCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDerivedSeriesCollectionType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDerivedSeriesCollectionType', fromsubclass_=False):
        for ChartDerivedSeries_ in self.ChartDerivedSeries:
            ChartDerivedSeries_.export(outfile, level, namespace_, name_='ChartDerivedSeries')
    def hasContent_(self):
        if (
            self.ChartDerivedSeries
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDerivedSeriesCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartDerivedSeries=[\n')
        level += 1
        for ChartDerivedSeries_ in self.ChartDerivedSeries:
            showIndent(outfile, level)
            outfile.write('model_.ChartDerivedSeriesType(\n')
            ChartDerivedSeries_.exportLiteral(outfile, level, name_='ChartDerivedSeriesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartDerivedSeries':
            obj_ = ChartDerivedSeriesType.factory()
            obj_.build(child_)
            self.ChartDerivedSeries.append(obj_)
# end class ChartDerivedSeriesCollectionType


class ChartSeriesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Hidden=None, ChartDataPoints=None, Type=None, Subtype=None, Style=None, ChartEmptyPoints=None, CustomProperties=None, LegendName=None, ChartItemInLegend=None, ChartAreaName=None, ValueAxisName=None, CategoryAxisName=None, ChartSmartLabel=None, ChartDataLabel=None, ChartMarker=None):
        self.Name = _cast(None, Name)
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ChartDataPoints is None:
            self.ChartDataPoints = []
        else:
            self.ChartDataPoints = ChartDataPoints
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if Subtype is None:
            self.Subtype = []
        else:
            self.Subtype = Subtype
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ChartEmptyPoints is None:
            self.ChartEmptyPoints = []
        else:
            self.ChartEmptyPoints = ChartEmptyPoints
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if LegendName is None:
            self.LegendName = []
        else:
            self.LegendName = LegendName
        if ChartItemInLegend is None:
            self.ChartItemInLegend = []
        else:
            self.ChartItemInLegend = ChartItemInLegend
        if ChartAreaName is None:
            self.ChartAreaName = []
        else:
            self.ChartAreaName = ChartAreaName
        if ValueAxisName is None:
            self.ValueAxisName = []
        else:
            self.ValueAxisName = ValueAxisName
        if CategoryAxisName is None:
            self.CategoryAxisName = []
        else:
            self.CategoryAxisName = CategoryAxisName
        if ChartSmartLabel is None:
            self.ChartSmartLabel = []
        else:
            self.ChartSmartLabel = ChartSmartLabel
        if ChartDataLabel is None:
            self.ChartDataLabel = []
        else:
            self.ChartDataLabel = ChartDataLabel
        if ChartMarker is None:
            self.ChartMarker = []
        else:
            self.ChartMarker = ChartMarker
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartSeriesType.subclass:
            return ChartSeriesType.subclass(*args_, **kwargs_)
        else:
            return ChartSeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ChartDataPoints(self): return self.ChartDataPoints
    def set_ChartDataPoints(self, ChartDataPoints): self.ChartDataPoints = ChartDataPoints
    def add_ChartDataPoints(self, value): self.ChartDataPoints.append(value)
    def insert_ChartDataPoints(self, index, value): self.ChartDataPoints[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Subtype(self): return self.Subtype
    def set_Subtype(self, Subtype): self.Subtype = Subtype
    def add_Subtype(self, value): self.Subtype.append(value)
    def insert_Subtype(self, index, value): self.Subtype[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ChartEmptyPoints(self): return self.ChartEmptyPoints
    def set_ChartEmptyPoints(self, ChartEmptyPoints): self.ChartEmptyPoints = ChartEmptyPoints
    def add_ChartEmptyPoints(self, value): self.ChartEmptyPoints.append(value)
    def insert_ChartEmptyPoints(self, index, value): self.ChartEmptyPoints[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_LegendName(self): return self.LegendName
    def set_LegendName(self, LegendName): self.LegendName = LegendName
    def add_LegendName(self, value): self.LegendName.append(value)
    def insert_LegendName(self, index, value): self.LegendName[index] = value
    def get_ChartItemInLegend(self): return self.ChartItemInLegend
    def set_ChartItemInLegend(self, ChartItemInLegend): self.ChartItemInLegend = ChartItemInLegend
    def add_ChartItemInLegend(self, value): self.ChartItemInLegend.append(value)
    def insert_ChartItemInLegend(self, index, value): self.ChartItemInLegend[index] = value
    def get_ChartAreaName(self): return self.ChartAreaName
    def set_ChartAreaName(self, ChartAreaName): self.ChartAreaName = ChartAreaName
    def add_ChartAreaName(self, value): self.ChartAreaName.append(value)
    def insert_ChartAreaName(self, index, value): self.ChartAreaName[index] = value
    def get_ValueAxisName(self): return self.ValueAxisName
    def set_ValueAxisName(self, ValueAxisName): self.ValueAxisName = ValueAxisName
    def add_ValueAxisName(self, value): self.ValueAxisName.append(value)
    def insert_ValueAxisName(self, index, value): self.ValueAxisName[index] = value
    def get_CategoryAxisName(self): return self.CategoryAxisName
    def set_CategoryAxisName(self, CategoryAxisName): self.CategoryAxisName = CategoryAxisName
    def add_CategoryAxisName(self, value): self.CategoryAxisName.append(value)
    def insert_CategoryAxisName(self, index, value): self.CategoryAxisName[index] = value
    def get_ChartSmartLabel(self): return self.ChartSmartLabel
    def set_ChartSmartLabel(self, ChartSmartLabel): self.ChartSmartLabel = ChartSmartLabel
    def add_ChartSmartLabel(self, value): self.ChartSmartLabel.append(value)
    def insert_ChartSmartLabel(self, index, value): self.ChartSmartLabel[index] = value
    def get_ChartDataLabel(self): return self.ChartDataLabel
    def set_ChartDataLabel(self, ChartDataLabel): self.ChartDataLabel = ChartDataLabel
    def add_ChartDataLabel(self, value): self.ChartDataLabel.append(value)
    def insert_ChartDataLabel(self, index, value): self.ChartDataLabel[index] = value
    def get_ChartMarker(self): return self.ChartMarker
    def set_ChartMarker(self, ChartMarker): self.ChartMarker = ChartMarker
    def add_ChartMarker(self, value): self.ChartMarker.append(value)
    def insert_ChartMarker(self, index, value): self.ChartMarker[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartSeriesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartSeriesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartSeriesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartSeriesType', fromsubclass_=False):
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ChartDataPoints_ in self.ChartDataPoints:
            ChartDataPoints_.export(outfile, level, namespace_, name_='ChartDataPoints')
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(Type_).encode(ExternalEncoding), input_name='Type'), namespace_))
        for Subtype_ in self.Subtype:
            showIndent(outfile, level)
            outfile.write('<%sSubtype>%s</%sSubtype>\n' % (namespace_, self.gds_format_string(quote_xml(Subtype_).encode(ExternalEncoding), input_name='Subtype'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ChartEmptyPoints_ in self.ChartEmptyPoints:
            ChartEmptyPoints_.export(outfile, level, namespace_, name_='ChartEmptyPoints')
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for LegendName_ in self.LegendName:
            showIndent(outfile, level)
            outfile.write('<%sLegendName>%s</%sLegendName>\n' % (namespace_, self.gds_format_string(quote_xml(LegendName_).encode(ExternalEncoding), input_name='LegendName'), namespace_))
        for ChartItemInLegend_ in self.ChartItemInLegend:
            ChartItemInLegend_.export(outfile, level, namespace_, name_='ChartItemInLegend')
        for ChartAreaName_ in self.ChartAreaName:
            showIndent(outfile, level)
            outfile.write('<%sChartAreaName>%s</%sChartAreaName>\n' % (namespace_, self.gds_format_string(quote_xml(ChartAreaName_).encode(ExternalEncoding), input_name='ChartAreaName'), namespace_))
        for ValueAxisName_ in self.ValueAxisName:
            showIndent(outfile, level)
            outfile.write('<%sValueAxisName>%s</%sValueAxisName>\n' % (namespace_, self.gds_format_string(quote_xml(ValueAxisName_).encode(ExternalEncoding), input_name='ValueAxisName'), namespace_))
        for CategoryAxisName_ in self.CategoryAxisName:
            showIndent(outfile, level)
            outfile.write('<%sCategoryAxisName>%s</%sCategoryAxisName>\n' % (namespace_, self.gds_format_string(quote_xml(CategoryAxisName_).encode(ExternalEncoding), input_name='CategoryAxisName'), namespace_))
        for ChartSmartLabel_ in self.ChartSmartLabel:
            ChartSmartLabel_.export(outfile, level, namespace_, name_='ChartSmartLabel')
        for ChartDataLabel_ in self.ChartDataLabel:
            ChartDataLabel_.export(outfile, level, namespace_, name_='ChartDataLabel')
        for ChartMarker_ in self.ChartMarker:
            ChartMarker_.export(outfile, level, namespace_, name_='ChartMarker')
    def hasContent_(self):
        if (
            self.Hidden or
            self.ChartDataPoints or
            self.Type or
            self.Subtype or
            self.Style or
            self.ChartEmptyPoints or
            self.CustomProperties or
            self.LegendName or
            self.ChartItemInLegend or
            self.ChartAreaName or
            self.ValueAxisName or
            self.CategoryAxisName or
            self.ChartSmartLabel or
            self.ChartDataLabel or
            self.ChartMarker
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartSeriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartDataPoints=[\n')
        level += 1
        for ChartDataPoints_ in self.ChartDataPoints:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataPointsType(\n')
            ChartDataPoints_.exportLiteral(outfile, level, name_='ChartDataPointsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Subtype=[\n')
        level += 1
        for Subtype_ in self.Subtype:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Subtype_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartEmptyPoints=[\n')
        level += 1
        for ChartEmptyPoints_ in self.ChartEmptyPoints:
            showIndent(outfile, level)
            outfile.write('model_.ChartEmptyPointsType(\n')
            ChartEmptyPoints_.exportLiteral(outfile, level, name_='ChartEmptyPointsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LegendName=[\n')
        level += 1
        for LegendName_ in self.LegendName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LegendName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartItemInLegend=[\n')
        level += 1
        for ChartItemInLegend_ in self.ChartItemInLegend:
            showIndent(outfile, level)
            outfile.write('model_.ChartItemInLegendType(\n')
            ChartItemInLegend_.exportLiteral(outfile, level, name_='ChartItemInLegendType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartAreaName=[\n')
        level += 1
        for ChartAreaName_ in self.ChartAreaName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ChartAreaName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ValueAxisName=[\n')
        level += 1
        for ValueAxisName_ in self.ValueAxisName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ValueAxisName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategoryAxisName=[\n')
        level += 1
        for CategoryAxisName_ in self.CategoryAxisName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CategoryAxisName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartSmartLabel=[\n')
        level += 1
        for ChartSmartLabel_ in self.ChartSmartLabel:
            showIndent(outfile, level)
            outfile.write('model_.ChartSmartLabelType(\n')
            ChartSmartLabel_.exportLiteral(outfile, level, name_='ChartSmartLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartDataLabel=[\n')
        level += 1
        for ChartDataLabel_ in self.ChartDataLabel:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataLabelType(\n')
            ChartDataLabel_.exportLiteral(outfile, level, name_='ChartDataLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMarker=[\n')
        level += 1
        for ChartMarker_ in self.ChartMarker:
            showIndent(outfile, level)
            outfile.write('model_.ChartMarkerType(\n')
            ChartMarker_.exportLiteral(outfile, level, name_='ChartMarkerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ChartDataPoints':
            obj_ = ChartDataPointsType.factory()
            obj_.build(child_)
            self.ChartDataPoints.append(obj_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
        elif nodeName_ == 'Subtype':
            Subtype_ = child_.text
            Subtype_ = self.gds_validate_string(Subtype_, node, 'Subtype')
            self.Subtype.append(Subtype_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ChartEmptyPoints':
            obj_ = ChartEmptyPointsType.factory()
            obj_.build(child_)
            self.ChartEmptyPoints.append(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'LegendName':
            LegendName_ = child_.text
            LegendName_ = self.gds_validate_string(LegendName_, node, 'LegendName')
            self.LegendName.append(LegendName_)
        elif nodeName_ == 'ChartItemInLegend':
            obj_ = ChartItemInLegendType.factory()
            obj_.build(child_)
            self.ChartItemInLegend.append(obj_)
        elif nodeName_ == 'ChartAreaName':
            ChartAreaName_ = child_.text
            ChartAreaName_ = self.gds_validate_string(ChartAreaName_, node, 'ChartAreaName')
            self.ChartAreaName.append(ChartAreaName_)
        elif nodeName_ == 'ValueAxisName':
            ValueAxisName_ = child_.text
            ValueAxisName_ = self.gds_validate_string(ValueAxisName_, node, 'ValueAxisName')
            self.ValueAxisName.append(ValueAxisName_)
        elif nodeName_ == 'CategoryAxisName':
            CategoryAxisName_ = child_.text
            CategoryAxisName_ = self.gds_validate_string(CategoryAxisName_, node, 'CategoryAxisName')
            self.CategoryAxisName.append(CategoryAxisName_)
        elif nodeName_ == 'ChartSmartLabel':
            obj_ = ChartSmartLabelType.factory()
            obj_.build(child_)
            self.ChartSmartLabel.append(obj_)
        elif nodeName_ == 'ChartDataLabel':
            obj_ = ChartDataLabelType.factory()
            obj_.build(child_)
            self.ChartDataLabel.append(obj_)
        elif nodeName_ == 'ChartMarker':
            obj_ = ChartMarkerType.factory()
            obj_.build(child_)
            self.ChartMarker.append(obj_)
# end class ChartSeriesType


class ChartDerivedSeriesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartSeries=None, SourceChartSeriesName=None, DerivedSeriesFormula=None, ChartFormulaParameters=None):
        if ChartSeries is None:
            self.ChartSeries = []
        else:
            self.ChartSeries = ChartSeries
        if SourceChartSeriesName is None:
            self.SourceChartSeriesName = []
        else:
            self.SourceChartSeriesName = SourceChartSeriesName
        if DerivedSeriesFormula is None:
            self.DerivedSeriesFormula = []
        else:
            self.DerivedSeriesFormula = DerivedSeriesFormula
        if ChartFormulaParameters is None:
            self.ChartFormulaParameters = []
        else:
            self.ChartFormulaParameters = ChartFormulaParameters
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDerivedSeriesType.subclass:
            return ChartDerivedSeriesType.subclass(*args_, **kwargs_)
        else:
            return ChartDerivedSeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartSeries(self): return self.ChartSeries
    def set_ChartSeries(self, ChartSeries): self.ChartSeries = ChartSeries
    def add_ChartSeries(self, value): self.ChartSeries.append(value)
    def insert_ChartSeries(self, index, value): self.ChartSeries[index] = value
    def get_SourceChartSeriesName(self): return self.SourceChartSeriesName
    def set_SourceChartSeriesName(self, SourceChartSeriesName): self.SourceChartSeriesName = SourceChartSeriesName
    def add_SourceChartSeriesName(self, value): self.SourceChartSeriesName.append(value)
    def insert_SourceChartSeriesName(self, index, value): self.SourceChartSeriesName[index] = value
    def get_DerivedSeriesFormula(self): return self.DerivedSeriesFormula
    def set_DerivedSeriesFormula(self, DerivedSeriesFormula): self.DerivedSeriesFormula = DerivedSeriesFormula
    def add_DerivedSeriesFormula(self, value): self.DerivedSeriesFormula.append(value)
    def insert_DerivedSeriesFormula(self, index, value): self.DerivedSeriesFormula[index] = value
    def get_ChartFormulaParameters(self): return self.ChartFormulaParameters
    def set_ChartFormulaParameters(self, ChartFormulaParameters): self.ChartFormulaParameters = ChartFormulaParameters
    def add_ChartFormulaParameters(self, value): self.ChartFormulaParameters.append(value)
    def insert_ChartFormulaParameters(self, index, value): self.ChartFormulaParameters[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDerivedSeriesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDerivedSeriesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDerivedSeriesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDerivedSeriesType', fromsubclass_=False):
        for ChartSeries_ in self.ChartSeries:
            ChartSeries_.export(outfile, level, namespace_, name_='ChartSeries')
        for SourceChartSeriesName_ in self.SourceChartSeriesName:
            showIndent(outfile, level)
            outfile.write('<%sSourceChartSeriesName>%s</%sSourceChartSeriesName>\n' % (namespace_, self.gds_format_string(quote_xml(SourceChartSeriesName_).encode(ExternalEncoding), input_name='SourceChartSeriesName'), namespace_))
        for DerivedSeriesFormula_ in self.DerivedSeriesFormula:
            showIndent(outfile, level)
            outfile.write('<%sDerivedSeriesFormula>%s</%sDerivedSeriesFormula>\n' % (namespace_, self.gds_format_string(quote_xml(DerivedSeriesFormula_).encode(ExternalEncoding), input_name='DerivedSeriesFormula'), namespace_))
        for ChartFormulaParameters_ in self.ChartFormulaParameters:
            ChartFormulaParameters_.export(outfile, level, namespace_, name_='ChartFormulaParameters')
    def hasContent_(self):
        if (
            self.ChartSeries or
            self.SourceChartSeriesName or
            self.DerivedSeriesFormula or
            self.ChartFormulaParameters
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDerivedSeriesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartSeries=[\n')
        level += 1
        for ChartSeries_ in self.ChartSeries:
            showIndent(outfile, level)
            outfile.write('model_.ChartSeriesType(\n')
            ChartSeries_.exportLiteral(outfile, level, name_='ChartSeriesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SourceChartSeriesName=[\n')
        level += 1
        for SourceChartSeriesName_ in self.SourceChartSeriesName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SourceChartSeriesName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DerivedSeriesFormula=[\n')
        level += 1
        for DerivedSeriesFormula_ in self.DerivedSeriesFormula:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DerivedSeriesFormula_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartFormulaParameters=[\n')
        level += 1
        for ChartFormulaParameters_ in self.ChartFormulaParameters:
            showIndent(outfile, level)
            outfile.write('model_.ChartFormulaParametersType(\n')
            ChartFormulaParameters_.exportLiteral(outfile, level, name_='ChartFormulaParametersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartSeries':
            obj_ = ChartSeriesType.factory()
            obj_.build(child_)
            self.ChartSeries.append(obj_)
        elif nodeName_ == 'SourceChartSeriesName':
            SourceChartSeriesName_ = child_.text
            SourceChartSeriesName_ = self.gds_validate_string(SourceChartSeriesName_, node, 'SourceChartSeriesName')
            self.SourceChartSeriesName.append(SourceChartSeriesName_)
        elif nodeName_ == 'DerivedSeriesFormula':
            DerivedSeriesFormula_ = child_.text
            DerivedSeriesFormula_ = self.gds_validate_string(DerivedSeriesFormula_, node, 'DerivedSeriesFormula')
            self.DerivedSeriesFormula.append(DerivedSeriesFormula_)
        elif nodeName_ == 'ChartFormulaParameters':
            obj_ = ChartFormulaParametersType.factory()
            obj_.build(child_)
            self.ChartFormulaParameters.append(obj_)
# end class ChartDerivedSeriesType


class DerivedSeriesFormula(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DerivedSeriesFormula.subclass:
            return DerivedSeriesFormula.subclass(*args_, **kwargs_)
        else:
            return DerivedSeriesFormula(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DerivedSeriesFormula', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DerivedSeriesFormula')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DerivedSeriesFormula'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DerivedSeriesFormula', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DerivedSeriesFormula'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DerivedSeriesFormula


class ChartFormulaParametersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartFormulaParameter=None):
        if ChartFormulaParameter is None:
            self.ChartFormulaParameter = []
        else:
            self.ChartFormulaParameter = ChartFormulaParameter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartFormulaParametersType.subclass:
            return ChartFormulaParametersType.subclass(*args_, **kwargs_)
        else:
            return ChartFormulaParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartFormulaParameter(self): return self.ChartFormulaParameter
    def set_ChartFormulaParameter(self, ChartFormulaParameter): self.ChartFormulaParameter = ChartFormulaParameter
    def add_ChartFormulaParameter(self, value): self.ChartFormulaParameter.append(value)
    def insert_ChartFormulaParameter(self, index, value): self.ChartFormulaParameter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartFormulaParametersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartFormulaParametersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartFormulaParametersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartFormulaParametersType', fromsubclass_=False):
        for ChartFormulaParameter_ in self.ChartFormulaParameter:
            ChartFormulaParameter_.export(outfile, level, namespace_, name_='ChartFormulaParameter')
    def hasContent_(self):
        if (
            self.ChartFormulaParameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartFormulaParametersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartFormulaParameter=[\n')
        level += 1
        for ChartFormulaParameter_ in self.ChartFormulaParameter:
            showIndent(outfile, level)
            outfile.write('model_.ChartFormulaParameterType(\n')
            ChartFormulaParameter_.exportLiteral(outfile, level, name_='ChartFormulaParameterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartFormulaParameter':
            obj_ = ChartFormulaParameterType.factory()
            obj_.build(child_)
            self.ChartFormulaParameter.append(obj_)
# end class ChartFormulaParametersType


class ChartFormulaParameterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None, Source=None):
        self.Name = _cast(None, Name)
        self.Value = Value
        self.Source = Source
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartFormulaParameterType.subclass:
            return ChartFormulaParameterType.subclass(*args_, **kwargs_)
        else:
            return ChartFormulaParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartFormulaParameterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartFormulaParameterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartFormulaParameterType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ChartFormulaParameterType', fromsubclass_=False):
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), namespace_))
    def hasContent_(self):
        if (
            self.Value is not None or
            self.Source is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartFormulaParameterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=%s,\n' % quote_python(self.Source).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
# end class ChartFormulaParameterType


class ChartEmptyPointsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, ChartMarker=None, ChartDataLabel=None, AxisLabel=None, ToolTip=None, ActionInfo=None, CustomProperties=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ChartMarker is None:
            self.ChartMarker = []
        else:
            self.ChartMarker = ChartMarker
        if ChartDataLabel is None:
            self.ChartDataLabel = []
        else:
            self.ChartDataLabel = ChartDataLabel
        if AxisLabel is None:
            self.AxisLabel = []
        else:
            self.AxisLabel = AxisLabel
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartEmptyPointsType.subclass:
            return ChartEmptyPointsType.subclass(*args_, **kwargs_)
        else:
            return ChartEmptyPointsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ChartMarker(self): return self.ChartMarker
    def set_ChartMarker(self, ChartMarker): self.ChartMarker = ChartMarker
    def add_ChartMarker(self, value): self.ChartMarker.append(value)
    def insert_ChartMarker(self, index, value): self.ChartMarker[index] = value
    def get_ChartDataLabel(self): return self.ChartDataLabel
    def set_ChartDataLabel(self, ChartDataLabel): self.ChartDataLabel = ChartDataLabel
    def add_ChartDataLabel(self, value): self.ChartDataLabel.append(value)
    def insert_ChartDataLabel(self, index, value): self.ChartDataLabel[index] = value
    def get_AxisLabel(self): return self.AxisLabel
    def set_AxisLabel(self, AxisLabel): self.AxisLabel = AxisLabel
    def add_AxisLabel(self, value): self.AxisLabel.append(value)
    def insert_AxisLabel(self, index, value): self.AxisLabel[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartEmptyPointsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartEmptyPointsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartEmptyPointsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartEmptyPointsType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ChartMarker_ in self.ChartMarker:
            ChartMarker_.export(outfile, level, namespace_, name_='ChartMarker')
        for ChartDataLabel_ in self.ChartDataLabel:
            ChartDataLabel_.export(outfile, level, namespace_, name_='ChartDataLabel')
        for AxisLabel_ in self.AxisLabel:
            showIndent(outfile, level)
            outfile.write('<%sAxisLabel>%s</%sAxisLabel>\n' % (namespace_, self.gds_format_string(quote_xml(AxisLabel_).encode(ExternalEncoding), input_name='AxisLabel'), namespace_))
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
    def hasContent_(self):
        if (
            self.Style or
            self.ChartMarker or
            self.ChartDataLabel or
            self.AxisLabel or
            self.ToolTip or
            self.ActionInfo or
            self.CustomProperties
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartEmptyPointsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMarker=[\n')
        level += 1
        for ChartMarker_ in self.ChartMarker:
            showIndent(outfile, level)
            outfile.write('model_.ChartMarkerType(\n')
            ChartMarker_.exportLiteral(outfile, level, name_='ChartMarkerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartDataLabel=[\n')
        level += 1
        for ChartDataLabel_ in self.ChartDataLabel:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataLabelType(\n')
            ChartDataLabel_.exportLiteral(outfile, level, name_='ChartDataLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AxisLabel=[\n')
        level += 1
        for AxisLabel_ in self.AxisLabel:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AxisLabel_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ChartMarker':
            obj_ = ChartMarkerType.factory()
            obj_.build(child_)
            self.ChartMarker.append(obj_)
        elif nodeName_ == 'ChartDataLabel':
            obj_ = ChartDataLabelType.factory()
            obj_.build(child_)
            self.ChartDataLabel.append(obj_)
        elif nodeName_ == 'AxisLabel':
            AxisLabel_ = child_.text
            AxisLabel_ = self.gds_validate_string(AxisLabel_, node, 'AxisLabel')
            self.AxisLabel.append(AxisLabel_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
# end class ChartEmptyPointsType


class ChartItemInLegendType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LegendText=None, ToolTip=None, ActionInfo=None, Hidden=None):
        if LegendText is None:
            self.LegendText = []
        else:
            self.LegendText = LegendText
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartItemInLegendType.subclass:
            return ChartItemInLegendType.subclass(*args_, **kwargs_)
        else:
            return ChartItemInLegendType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LegendText(self): return self.LegendText
    def set_LegendText(self, LegendText): self.LegendText = LegendText
    def add_LegendText(self, value): self.LegendText.append(value)
    def insert_LegendText(self, index, value): self.LegendText[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartItemInLegendType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartItemInLegendType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartItemInLegendType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartItemInLegendType', fromsubclass_=False):
        for LegendText_ in self.LegendText:
            showIndent(outfile, level)
            outfile.write('<%sLegendText>%s</%sLegendText>\n' % (namespace_, self.gds_format_string(quote_xml(LegendText_).encode(ExternalEncoding), input_name='LegendText'), namespace_))
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
    def hasContent_(self):
        if (
            self.LegendText or
            self.ToolTip or
            self.ActionInfo or
            self.Hidden
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartItemInLegendType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LegendText=[\n')
        level += 1
        for LegendText_ in self.LegendText:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LegendText_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LegendText':
            LegendText_ = child_.text
            LegendText_ = self.gds_validate_string(LegendText_, node, 'LegendText')
            self.LegendText.append(LegendText_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
# end class ChartItemInLegendType


class ChartDataPointsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartDataPoint=None):
        if ChartDataPoint is None:
            self.ChartDataPoint = []
        else:
            self.ChartDataPoint = ChartDataPoint
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDataPointsType.subclass:
            return ChartDataPointsType.subclass(*args_, **kwargs_)
        else:
            return ChartDataPointsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartDataPoint(self): return self.ChartDataPoint
    def set_ChartDataPoint(self, ChartDataPoint): self.ChartDataPoint = ChartDataPoint
    def add_ChartDataPoint(self, value): self.ChartDataPoint.append(value)
    def insert_ChartDataPoint(self, index, value): self.ChartDataPoint[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDataPointsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDataPointsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDataPointsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDataPointsType', fromsubclass_=False):
        for ChartDataPoint_ in self.ChartDataPoint:
            ChartDataPoint_.export(outfile, level, namespace_, name_='ChartDataPoint')
    def hasContent_(self):
        if (
            self.ChartDataPoint
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDataPointsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartDataPoint=[\n')
        level += 1
        for ChartDataPoint_ in self.ChartDataPoint:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataPointType(\n')
            ChartDataPoint_.exportLiteral(outfile, level, name_='ChartDataPointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartDataPoint':
            obj_ = ChartDataPointType.factory()
            obj_.build(child_)
            self.ChartDataPoint.append(obj_)
# end class ChartDataPointsType


class ChartDataPointType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartDataPointValues=None, ChartDataLabel=None, AxisLabel=None, ToolTip=None, ActionInfo=None, Style=None, ChartMarker=None, ChartItemInLegend=None, CustomProperties=None, DataElementName=None, DataElementOutput=None):
        if ChartDataPointValues is None:
            self.ChartDataPointValues = []
        else:
            self.ChartDataPointValues = ChartDataPointValues
        if ChartDataLabel is None:
            self.ChartDataLabel = []
        else:
            self.ChartDataLabel = ChartDataLabel
        if AxisLabel is None:
            self.AxisLabel = []
        else:
            self.AxisLabel = AxisLabel
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ChartMarker is None:
            self.ChartMarker = []
        else:
            self.ChartMarker = ChartMarker
        if ChartItemInLegend is None:
            self.ChartItemInLegend = []
        else:
            self.ChartItemInLegend = ChartItemInLegend
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDataPointType.subclass:
            return ChartDataPointType.subclass(*args_, **kwargs_)
        else:
            return ChartDataPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartDataPointValues(self): return self.ChartDataPointValues
    def set_ChartDataPointValues(self, ChartDataPointValues): self.ChartDataPointValues = ChartDataPointValues
    def add_ChartDataPointValues(self, value): self.ChartDataPointValues.append(value)
    def insert_ChartDataPointValues(self, index, value): self.ChartDataPointValues[index] = value
    def get_ChartDataLabel(self): return self.ChartDataLabel
    def set_ChartDataLabel(self, ChartDataLabel): self.ChartDataLabel = ChartDataLabel
    def add_ChartDataLabel(self, value): self.ChartDataLabel.append(value)
    def insert_ChartDataLabel(self, index, value): self.ChartDataLabel[index] = value
    def get_AxisLabel(self): return self.AxisLabel
    def set_AxisLabel(self, AxisLabel): self.AxisLabel = AxisLabel
    def add_AxisLabel(self, value): self.AxisLabel.append(value)
    def insert_AxisLabel(self, index, value): self.AxisLabel[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ChartMarker(self): return self.ChartMarker
    def set_ChartMarker(self, ChartMarker): self.ChartMarker = ChartMarker
    def add_ChartMarker(self, value): self.ChartMarker.append(value)
    def insert_ChartMarker(self, index, value): self.ChartMarker[index] = value
    def get_ChartItemInLegend(self): return self.ChartItemInLegend
    def set_ChartItemInLegend(self, ChartItemInLegend): self.ChartItemInLegend = ChartItemInLegend
    def add_ChartItemInLegend(self, value): self.ChartItemInLegend.append(value)
    def insert_ChartItemInLegend(self, index, value): self.ChartItemInLegend[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDataPointType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDataPointType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDataPointType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDataPointType', fromsubclass_=False):
        for ChartDataPointValues_ in self.ChartDataPointValues:
            ChartDataPointValues_.export(outfile, level, namespace_, name_='ChartDataPointValues')
        for ChartDataLabel_ in self.ChartDataLabel:
            ChartDataLabel_.export(outfile, level, namespace_, name_='ChartDataLabel')
        for AxisLabel_ in self.AxisLabel:
            showIndent(outfile, level)
            outfile.write('<%sAxisLabel>%s</%sAxisLabel>\n' % (namespace_, self.gds_format_string(quote_xml(AxisLabel_).encode(ExternalEncoding), input_name='AxisLabel'), namespace_))
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ChartMarker_ in self.ChartMarker:
            ChartMarker_.export(outfile, level, namespace_, name_='ChartMarker')
        for ChartItemInLegend_ in self.ChartItemInLegend:
            ChartItemInLegend_.export(outfile, level, namespace_, name_='ChartItemInLegend')
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.ChartDataPointValues or
            self.ChartDataLabel or
            self.AxisLabel or
            self.ToolTip or
            self.ActionInfo or
            self.Style or
            self.ChartMarker or
            self.ChartItemInLegend or
            self.CustomProperties or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDataPointType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartDataPointValues=[\n')
        level += 1
        for ChartDataPointValues_ in self.ChartDataPointValues:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataPointValuesType(\n')
            ChartDataPointValues_.exportLiteral(outfile, level, name_='ChartDataPointValuesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartDataLabel=[\n')
        level += 1
        for ChartDataLabel_ in self.ChartDataLabel:
            showIndent(outfile, level)
            outfile.write('model_.ChartDataLabelType(\n')
            ChartDataLabel_.exportLiteral(outfile, level, name_='ChartDataLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AxisLabel=[\n')
        level += 1
        for AxisLabel_ in self.AxisLabel:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AxisLabel_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartMarker=[\n')
        level += 1
        for ChartMarker_ in self.ChartMarker:
            showIndent(outfile, level)
            outfile.write('model_.ChartMarkerType(\n')
            ChartMarker_.exportLiteral(outfile, level, name_='ChartMarkerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartItemInLegend=[\n')
        level += 1
        for ChartItemInLegend_ in self.ChartItemInLegend:
            showIndent(outfile, level)
            outfile.write('model_.ChartItemInLegendType(\n')
            ChartItemInLegend_.exportLiteral(outfile, level, name_='ChartItemInLegendType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartDataPointValues':
            obj_ = ChartDataPointValuesType.factory()
            obj_.build(child_)
            self.ChartDataPointValues.append(obj_)
        elif nodeName_ == 'ChartDataLabel':
            obj_ = ChartDataLabelType.factory()
            obj_.build(child_)
            self.ChartDataLabel.append(obj_)
        elif nodeName_ == 'AxisLabel':
            AxisLabel_ = child_.text
            AxisLabel_ = self.gds_validate_string(AxisLabel_, node, 'AxisLabel')
            self.AxisLabel.append(AxisLabel_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ChartMarker':
            obj_ = ChartMarkerType.factory()
            obj_.build(child_)
            self.ChartMarker.append(obj_)
        elif nodeName_ == 'ChartItemInLegend':
            obj_ = ChartItemInLegendType.factory()
            obj_.build(child_)
            self.ChartItemInLegend.append(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class ChartDataPointType


class ChartDataPointValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X=None, Y=None, Size=None, High=None, Low=None, Start=None, End=None, Mean=None, Median=None):
        if X is None:
            self.X = []
        else:
            self.X = X
        if Y is None:
            self.Y = []
        else:
            self.Y = Y
        if Size is None:
            self.Size = []
        else:
            self.Size = Size
        if High is None:
            self.High = []
        else:
            self.High = High
        if Low is None:
            self.Low = []
        else:
            self.Low = Low
        if Start is None:
            self.Start = []
        else:
            self.Start = Start
        if End is None:
            self.End = []
        else:
            self.End = End
        if Mean is None:
            self.Mean = []
        else:
            self.Mean = Mean
        if Median is None:
            self.Median = []
        else:
            self.Median = Median
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDataPointValuesType.subclass:
            return ChartDataPointValuesType.subclass(*args_, **kwargs_)
        else:
            return ChartDataPointValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X(self): return self.X
    def set_X(self, X): self.X = X
    def add_X(self, value): self.X.append(value)
    def insert_X(self, index, value): self.X[index] = value
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def add_Y(self, value): self.Y.append(value)
    def insert_Y(self, index, value): self.Y[index] = value
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def add_Size(self, value): self.Size.append(value)
    def insert_Size(self, index, value): self.Size[index] = value
    def get_High(self): return self.High
    def set_High(self, High): self.High = High
    def add_High(self, value): self.High.append(value)
    def insert_High(self, index, value): self.High[index] = value
    def get_Low(self): return self.Low
    def set_Low(self, Low): self.Low = Low
    def add_Low(self, value): self.Low.append(value)
    def insert_Low(self, index, value): self.Low[index] = value
    def get_Start(self): return self.Start
    def set_Start(self, Start): self.Start = Start
    def add_Start(self, value): self.Start.append(value)
    def insert_Start(self, index, value): self.Start[index] = value
    def get_End(self): return self.End
    def set_End(self, End): self.End = End
    def add_End(self, value): self.End.append(value)
    def insert_End(self, index, value): self.End[index] = value
    def get_Mean(self): return self.Mean
    def set_Mean(self, Mean): self.Mean = Mean
    def add_Mean(self, value): self.Mean.append(value)
    def insert_Mean(self, index, value): self.Mean[index] = value
    def get_Median(self): return self.Median
    def set_Median(self, Median): self.Median = Median
    def add_Median(self, value): self.Median.append(value)
    def insert_Median(self, index, value): self.Median[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDataPointValuesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDataPointValuesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDataPointValuesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDataPointValuesType', fromsubclass_=False):
        for X_ in self.X:
            showIndent(outfile, level)
            outfile.write('<%sX>%s</%sX>\n' % (namespace_, self.gds_format_string(quote_xml(X_).encode(ExternalEncoding), input_name='X'), namespace_))
        for Y_ in self.Y:
            showIndent(outfile, level)
            outfile.write('<%sY>%s</%sY>\n' % (namespace_, self.gds_format_string(quote_xml(Y_).encode(ExternalEncoding), input_name='Y'), namespace_))
        for Size_ in self.Size:
            showIndent(outfile, level)
            outfile.write('<%sSize>%s</%sSize>\n' % (namespace_, self.gds_format_string(quote_xml(Size_).encode(ExternalEncoding), input_name='Size'), namespace_))
        for High_ in self.High:
            showIndent(outfile, level)
            outfile.write('<%sHigh>%s</%sHigh>\n' % (namespace_, self.gds_format_string(quote_xml(High_).encode(ExternalEncoding), input_name='High'), namespace_))
        for Low_ in self.Low:
            showIndent(outfile, level)
            outfile.write('<%sLow>%s</%sLow>\n' % (namespace_, self.gds_format_string(quote_xml(Low_).encode(ExternalEncoding), input_name='Low'), namespace_))
        for Start_ in self.Start:
            showIndent(outfile, level)
            outfile.write('<%sStart>%s</%sStart>\n' % (namespace_, self.gds_format_string(quote_xml(Start_).encode(ExternalEncoding), input_name='Start'), namespace_))
        for End_ in self.End:
            showIndent(outfile, level)
            outfile.write('<%sEnd>%s</%sEnd>\n' % (namespace_, self.gds_format_string(quote_xml(End_).encode(ExternalEncoding), input_name='End'), namespace_))
        for Mean_ in self.Mean:
            showIndent(outfile, level)
            outfile.write('<%sMean>%s</%sMean>\n' % (namespace_, self.gds_format_string(quote_xml(Mean_).encode(ExternalEncoding), input_name='Mean'), namespace_))
        for Median_ in self.Median:
            showIndent(outfile, level)
            outfile.write('<%sMedian>%s</%sMedian>\n' % (namespace_, self.gds_format_string(quote_xml(Median_).encode(ExternalEncoding), input_name='Median'), namespace_))
    def hasContent_(self):
        if (
            self.X or
            self.Y or
            self.Size or
            self.High or
            self.Low or
            self.Start or
            self.End or
            self.Mean or
            self.Median
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDataPointValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('X=[\n')
        level += 1
        for X_ in self.X:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(X_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Y=[\n')
        level += 1
        for Y_ in self.Y:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Y_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Size=[\n')
        level += 1
        for Size_ in self.Size:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Size_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('High=[\n')
        level += 1
        for High_ in self.High:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(High_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Low=[\n')
        level += 1
        for Low_ in self.Low:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Low_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Start=[\n')
        level += 1
        for Start_ in self.Start:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Start_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('End=[\n')
        level += 1
        for End_ in self.End:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(End_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Mean=[\n')
        level += 1
        for Mean_ in self.Mean:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Mean_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Median=[\n')
        level += 1
        for Median_ in self.Median:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Median_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X':
            X_ = child_.text
            X_ = self.gds_validate_string(X_, node, 'X')
            self.X.append(X_)
        elif nodeName_ == 'Y':
            Y_ = child_.text
            Y_ = self.gds_validate_string(Y_, node, 'Y')
            self.Y.append(Y_)
        elif nodeName_ == 'Size':
            Size_ = child_.text
            Size_ = self.gds_validate_string(Size_, node, 'Size')
            self.Size.append(Size_)
        elif nodeName_ == 'High':
            High_ = child_.text
            High_ = self.gds_validate_string(High_, node, 'High')
            self.High.append(High_)
        elif nodeName_ == 'Low':
            Low_ = child_.text
            Low_ = self.gds_validate_string(Low_, node, 'Low')
            self.Low.append(Low_)
        elif nodeName_ == 'Start':
            Start_ = child_.text
            Start_ = self.gds_validate_string(Start_, node, 'Start')
            self.Start.append(Start_)
        elif nodeName_ == 'End':
            End_ = child_.text
            End_ = self.gds_validate_string(End_, node, 'End')
            self.End.append(End_)
        elif nodeName_ == 'Mean':
            Mean_ = child_.text
            Mean_ = self.gds_validate_string(Mean_, node, 'Mean')
            self.Mean.append(Mean_)
        elif nodeName_ == 'Median':
            Median_ = child_.text
            Median_ = self.gds_validate_string(Median_, node, 'Median')
            self.Median.append(Median_)
# end class ChartDataPointValuesType


class DataValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None):
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if DataValueType.subclass:
            return DataValueType.subclass(*args_, **kwargs_)
        else:
            return DataValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='DataValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataValueType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataValueType', fromsubclass_=False):
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(Name_).encode(ExternalEncoding), input_name='Name'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Name or
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name.append(Name_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class DataValueType


class ChartDataLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Visible=None, Style=None, Label=None, UseValueAsLabel=None, Position=None, Rotation=None, ToolTip=None, ActionInfo=None):
        if Visible is None:
            self.Visible = []
        else:
            self.Visible = Visible
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Label is None:
            self.Label = []
        else:
            self.Label = Label
        if UseValueAsLabel is None:
            self.UseValueAsLabel = []
        else:
            self.UseValueAsLabel = UseValueAsLabel
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        if Rotation is None:
            self.Rotation = []
        else:
            self.Rotation = Rotation
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartDataLabelType.subclass:
            return ChartDataLabelType.subclass(*args_, **kwargs_)
        else:
            return ChartDataLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Visible(self): return self.Visible
    def set_Visible(self, Visible): self.Visible = Visible
    def add_Visible(self, value): self.Visible.append(value)
    def insert_Visible(self, index, value): self.Visible[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def add_Label(self, value): self.Label.append(value)
    def insert_Label(self, index, value): self.Label[index] = value
    def get_UseValueAsLabel(self): return self.UseValueAsLabel
    def set_UseValueAsLabel(self, UseValueAsLabel): self.UseValueAsLabel = UseValueAsLabel
    def add_UseValueAsLabel(self, value): self.UseValueAsLabel.append(value)
    def insert_UseValueAsLabel(self, index, value): self.UseValueAsLabel[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_Rotation(self): return self.Rotation
    def set_Rotation(self, Rotation): self.Rotation = Rotation
    def add_Rotation(self, value): self.Rotation.append(value)
    def insert_Rotation(self, index, value): self.Rotation[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartDataLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartDataLabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartDataLabelType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartDataLabelType', fromsubclass_=False):
        for Visible_ in self.Visible:
            showIndent(outfile, level)
            outfile.write('<%sVisible>%s</%sVisible>\n' % (namespace_, self.gds_format_string(quote_xml(Visible_).encode(ExternalEncoding), input_name='Visible'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Label_ in self.Label:
            Label_.export(outfile, level, namespace_, name_='Label')
        for UseValueAsLabel_ in self.UseValueAsLabel:
            showIndent(outfile, level)
            outfile.write('<%sUseValueAsLabel>%s</%sUseValueAsLabel>\n' % (namespace_, self.gds_format_string(quote_xml(UseValueAsLabel_).encode(ExternalEncoding), input_name='UseValueAsLabel'), namespace_))
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
        for Rotation_ in self.Rotation:
            showIndent(outfile, level)
            outfile.write('<%sRotation>%s</%sRotation>\n' % (namespace_, self.gds_format_string(quote_xml(Rotation_).encode(ExternalEncoding), input_name='Rotation'), namespace_))
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
    def hasContent_(self):
        if (
            self.Visible or
            self.Style or
            self.Label or
            self.UseValueAsLabel or
            self.Position or
            self.Rotation or
            self.ToolTip or
            self.ActionInfo
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartDataLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Visible=[\n')
        level += 1
        for Visible_ in self.Visible:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Visible_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Label=[\n')
        level += 1
        for Label_ in self.Label:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            Label_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseValueAsLabel=[\n')
        level += 1
        for UseValueAsLabel_ in self.UseValueAsLabel:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseValueAsLabel_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Rotation=[\n')
        level += 1
        for Rotation_ in self.Rotation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Rotation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Visible':
            Visible_ = child_.text
            Visible_ = self.gds_validate_string(Visible_, node, 'Visible')
            self.Visible.append(Visible_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Label':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.Label.append(obj_)
        elif nodeName_ == 'UseValueAsLabel':
            UseValueAsLabel_ = child_.text
            UseValueAsLabel_ = self.gds_validate_string(UseValueAsLabel_, node, 'UseValueAsLabel')
            self.UseValueAsLabel.append(UseValueAsLabel_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
        elif nodeName_ == 'Rotation':
            Rotation_ = child_.text
            Rotation_ = self.gds_validate_string(Rotation_, node, 'Rotation')
            self.Rotation.append(Rotation_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
# end class ChartDataLabelType


class ChartSmartLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Disabled=None, AllowOutSidePlotArea=None, CalloutBackColor=None, CalloutLineAnchor=None, CalloutLineColor=None, CalloutLineStyle=None, CalloutLineWidth=None, CalloutStyle=None, ShowOverlapped=None, MarkerOverlapping=None, MaxMovingDistance=None, MinMovingDistance=None, ChartNoMoveDirections=None):
        if Disabled is None:
            self.Disabled = []
        else:
            self.Disabled = Disabled
        if AllowOutSidePlotArea is None:
            self.AllowOutSidePlotArea = []
        else:
            self.AllowOutSidePlotArea = AllowOutSidePlotArea
        if CalloutBackColor is None:
            self.CalloutBackColor = []
        else:
            self.CalloutBackColor = CalloutBackColor
        if CalloutLineAnchor is None:
            self.CalloutLineAnchor = []
        else:
            self.CalloutLineAnchor = CalloutLineAnchor
        if CalloutLineColor is None:
            self.CalloutLineColor = []
        else:
            self.CalloutLineColor = CalloutLineColor
        if CalloutLineStyle is None:
            self.CalloutLineStyle = []
        else:
            self.CalloutLineStyle = CalloutLineStyle
        if CalloutLineWidth is None:
            self.CalloutLineWidth = []
        else:
            self.CalloutLineWidth = CalloutLineWidth
        if CalloutStyle is None:
            self.CalloutStyle = []
        else:
            self.CalloutStyle = CalloutStyle
        if ShowOverlapped is None:
            self.ShowOverlapped = []
        else:
            self.ShowOverlapped = ShowOverlapped
        if MarkerOverlapping is None:
            self.MarkerOverlapping = []
        else:
            self.MarkerOverlapping = MarkerOverlapping
        if MaxMovingDistance is None:
            self.MaxMovingDistance = []
        else:
            self.MaxMovingDistance = MaxMovingDistance
        if MinMovingDistance is None:
            self.MinMovingDistance = []
        else:
            self.MinMovingDistance = MinMovingDistance
        if ChartNoMoveDirections is None:
            self.ChartNoMoveDirections = []
        else:
            self.ChartNoMoveDirections = ChartNoMoveDirections
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartSmartLabelType.subclass:
            return ChartSmartLabelType.subclass(*args_, **kwargs_)
        else:
            return ChartSmartLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disabled(self): return self.Disabled
    def set_Disabled(self, Disabled): self.Disabled = Disabled
    def add_Disabled(self, value): self.Disabled.append(value)
    def insert_Disabled(self, index, value): self.Disabled[index] = value
    def get_AllowOutSidePlotArea(self): return self.AllowOutSidePlotArea
    def set_AllowOutSidePlotArea(self, AllowOutSidePlotArea): self.AllowOutSidePlotArea = AllowOutSidePlotArea
    def add_AllowOutSidePlotArea(self, value): self.AllowOutSidePlotArea.append(value)
    def insert_AllowOutSidePlotArea(self, index, value): self.AllowOutSidePlotArea[index] = value
    def get_CalloutBackColor(self): return self.CalloutBackColor
    def set_CalloutBackColor(self, CalloutBackColor): self.CalloutBackColor = CalloutBackColor
    def add_CalloutBackColor(self, value): self.CalloutBackColor.append(value)
    def insert_CalloutBackColor(self, index, value): self.CalloutBackColor[index] = value
    def get_CalloutLineAnchor(self): return self.CalloutLineAnchor
    def set_CalloutLineAnchor(self, CalloutLineAnchor): self.CalloutLineAnchor = CalloutLineAnchor
    def add_CalloutLineAnchor(self, value): self.CalloutLineAnchor.append(value)
    def insert_CalloutLineAnchor(self, index, value): self.CalloutLineAnchor[index] = value
    def get_CalloutLineColor(self): return self.CalloutLineColor
    def set_CalloutLineColor(self, CalloutLineColor): self.CalloutLineColor = CalloutLineColor
    def add_CalloutLineColor(self, value): self.CalloutLineColor.append(value)
    def insert_CalloutLineColor(self, index, value): self.CalloutLineColor[index] = value
    def get_CalloutLineStyle(self): return self.CalloutLineStyle
    def set_CalloutLineStyle(self, CalloutLineStyle): self.CalloutLineStyle = CalloutLineStyle
    def add_CalloutLineStyle(self, value): self.CalloutLineStyle.append(value)
    def insert_CalloutLineStyle(self, index, value): self.CalloutLineStyle[index] = value
    def get_CalloutLineWidth(self): return self.CalloutLineWidth
    def set_CalloutLineWidth(self, CalloutLineWidth): self.CalloutLineWidth = CalloutLineWidth
    def add_CalloutLineWidth(self, value): self.CalloutLineWidth.append(value)
    def insert_CalloutLineWidth(self, index, value): self.CalloutLineWidth[index] = value
    def get_CalloutStyle(self): return self.CalloutStyle
    def set_CalloutStyle(self, CalloutStyle): self.CalloutStyle = CalloutStyle
    def add_CalloutStyle(self, value): self.CalloutStyle.append(value)
    def insert_CalloutStyle(self, index, value): self.CalloutStyle[index] = value
    def get_ShowOverlapped(self): return self.ShowOverlapped
    def set_ShowOverlapped(self, ShowOverlapped): self.ShowOverlapped = ShowOverlapped
    def add_ShowOverlapped(self, value): self.ShowOverlapped.append(value)
    def insert_ShowOverlapped(self, index, value): self.ShowOverlapped[index] = value
    def get_MarkerOverlapping(self): return self.MarkerOverlapping
    def set_MarkerOverlapping(self, MarkerOverlapping): self.MarkerOverlapping = MarkerOverlapping
    def add_MarkerOverlapping(self, value): self.MarkerOverlapping.append(value)
    def insert_MarkerOverlapping(self, index, value): self.MarkerOverlapping[index] = value
    def get_MaxMovingDistance(self): return self.MaxMovingDistance
    def set_MaxMovingDistance(self, MaxMovingDistance): self.MaxMovingDistance = MaxMovingDistance
    def add_MaxMovingDistance(self, value): self.MaxMovingDistance.append(value)
    def insert_MaxMovingDistance(self, index, value): self.MaxMovingDistance[index] = value
    def get_MinMovingDistance(self): return self.MinMovingDistance
    def set_MinMovingDistance(self, MinMovingDistance): self.MinMovingDistance = MinMovingDistance
    def add_MinMovingDistance(self, value): self.MinMovingDistance.append(value)
    def insert_MinMovingDistance(self, index, value): self.MinMovingDistance[index] = value
    def get_ChartNoMoveDirections(self): return self.ChartNoMoveDirections
    def set_ChartNoMoveDirections(self, ChartNoMoveDirections): self.ChartNoMoveDirections = ChartNoMoveDirections
    def add_ChartNoMoveDirections(self, value): self.ChartNoMoveDirections.append(value)
    def insert_ChartNoMoveDirections(self, index, value): self.ChartNoMoveDirections[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartSmartLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartSmartLabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartSmartLabelType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartSmartLabelType', fromsubclass_=False):
        for Disabled_ in self.Disabled:
            showIndent(outfile, level)
            outfile.write('<%sDisabled>%s</%sDisabled>\n' % (namespace_, self.gds_format_string(quote_xml(Disabled_).encode(ExternalEncoding), input_name='Disabled'), namespace_))
        for AllowOutSidePlotArea_ in self.AllowOutSidePlotArea:
            showIndent(outfile, level)
            outfile.write('<%sAllowOutSidePlotArea>%s</%sAllowOutSidePlotArea>\n' % (namespace_, self.gds_format_string(quote_xml(AllowOutSidePlotArea_).encode(ExternalEncoding), input_name='AllowOutSidePlotArea'), namespace_))
        for CalloutBackColor_ in self.CalloutBackColor:
            showIndent(outfile, level)
            outfile.write('<%sCalloutBackColor>%s</%sCalloutBackColor>\n' % (namespace_, self.gds_format_string(quote_xml(CalloutBackColor_).encode(ExternalEncoding), input_name='CalloutBackColor'), namespace_))
        for CalloutLineAnchor_ in self.CalloutLineAnchor:
            showIndent(outfile, level)
            outfile.write('<%sCalloutLineAnchor>%s</%sCalloutLineAnchor>\n' % (namespace_, self.gds_format_string(quote_xml(CalloutLineAnchor_).encode(ExternalEncoding), input_name='CalloutLineAnchor'), namespace_))
        for CalloutLineColor_ in self.CalloutLineColor:
            showIndent(outfile, level)
            outfile.write('<%sCalloutLineColor>%s</%sCalloutLineColor>\n' % (namespace_, self.gds_format_string(quote_xml(CalloutLineColor_).encode(ExternalEncoding), input_name='CalloutLineColor'), namespace_))
        for CalloutLineStyle_ in self.CalloutLineStyle:
            showIndent(outfile, level)
            outfile.write('<%sCalloutLineStyle>%s</%sCalloutLineStyle>\n' % (namespace_, self.gds_format_string(quote_xml(CalloutLineStyle_).encode(ExternalEncoding), input_name='CalloutLineStyle'), namespace_))
        for CalloutLineWidth_ in self.CalloutLineWidth:
            showIndent(outfile, level)
            outfile.write('<%sCalloutLineWidth>%s</%sCalloutLineWidth>\n' % (namespace_, self.gds_format_string(quote_xml(CalloutLineWidth_).encode(ExternalEncoding), input_name='CalloutLineWidth'), namespace_))
        for CalloutStyle_ in self.CalloutStyle:
            showIndent(outfile, level)
            outfile.write('<%sCalloutStyle>%s</%sCalloutStyle>\n' % (namespace_, self.gds_format_string(quote_xml(CalloutStyle_).encode(ExternalEncoding), input_name='CalloutStyle'), namespace_))
        for ShowOverlapped_ in self.ShowOverlapped:
            showIndent(outfile, level)
            outfile.write('<%sShowOverlapped>%s</%sShowOverlapped>\n' % (namespace_, self.gds_format_string(quote_xml(ShowOverlapped_).encode(ExternalEncoding), input_name='ShowOverlapped'), namespace_))
        for MarkerOverlapping_ in self.MarkerOverlapping:
            showIndent(outfile, level)
            outfile.write('<%sMarkerOverlapping>%s</%sMarkerOverlapping>\n' % (namespace_, self.gds_format_string(quote_xml(MarkerOverlapping_).encode(ExternalEncoding), input_name='MarkerOverlapping'), namespace_))
        for MaxMovingDistance_ in self.MaxMovingDistance:
            showIndent(outfile, level)
            outfile.write('<%sMaxMovingDistance>%s</%sMaxMovingDistance>\n' % (namespace_, self.gds_format_string(quote_xml(MaxMovingDistance_).encode(ExternalEncoding), input_name='MaxMovingDistance'), namespace_))
        for MinMovingDistance_ in self.MinMovingDistance:
            showIndent(outfile, level)
            outfile.write('<%sMinMovingDistance>%s</%sMinMovingDistance>\n' % (namespace_, self.gds_format_string(quote_xml(MinMovingDistance_).encode(ExternalEncoding), input_name='MinMovingDistance'), namespace_))
        for ChartNoMoveDirections_ in self.ChartNoMoveDirections:
            ChartNoMoveDirections_.export(outfile, level, namespace_, name_='ChartNoMoveDirections')
    def hasContent_(self):
        if (
            self.Disabled or
            self.AllowOutSidePlotArea or
            self.CalloutBackColor or
            self.CalloutLineAnchor or
            self.CalloutLineColor or
            self.CalloutLineStyle or
            self.CalloutLineWidth or
            self.CalloutStyle or
            self.ShowOverlapped or
            self.MarkerOverlapping or
            self.MaxMovingDistance or
            self.MinMovingDistance or
            self.ChartNoMoveDirections
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartSmartLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Disabled=[\n')
        level += 1
        for Disabled_ in self.Disabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Disabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllowOutSidePlotArea=[\n')
        level += 1
        for AllowOutSidePlotArea_ in self.AllowOutSidePlotArea:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllowOutSidePlotArea_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalloutBackColor=[\n')
        level += 1
        for CalloutBackColor_ in self.CalloutBackColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CalloutBackColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalloutLineAnchor=[\n')
        level += 1
        for CalloutLineAnchor_ in self.CalloutLineAnchor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CalloutLineAnchor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalloutLineColor=[\n')
        level += 1
        for CalloutLineColor_ in self.CalloutLineColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CalloutLineColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalloutLineStyle=[\n')
        level += 1
        for CalloutLineStyle_ in self.CalloutLineStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CalloutLineStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalloutLineWidth=[\n')
        level += 1
        for CalloutLineWidth_ in self.CalloutLineWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CalloutLineWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CalloutStyle=[\n')
        level += 1
        for CalloutStyle_ in self.CalloutStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CalloutStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShowOverlapped=[\n')
        level += 1
        for ShowOverlapped_ in self.ShowOverlapped:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShowOverlapped_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarkerOverlapping=[\n')
        level += 1
        for MarkerOverlapping_ in self.MarkerOverlapping:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarkerOverlapping_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaxMovingDistance=[\n')
        level += 1
        for MaxMovingDistance_ in self.MaxMovingDistance:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MaxMovingDistance_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinMovingDistance=[\n')
        level += 1
        for MinMovingDistance_ in self.MinMovingDistance:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MinMovingDistance_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ChartNoMoveDirections=[\n')
        level += 1
        for ChartNoMoveDirections_ in self.ChartNoMoveDirections:
            showIndent(outfile, level)
            outfile.write('model_.ChartNoMoveDirectionsType(\n')
            ChartNoMoveDirections_.exportLiteral(outfile, level, name_='ChartNoMoveDirectionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disabled':
            Disabled_ = child_.text
            Disabled_ = self.gds_validate_string(Disabled_, node, 'Disabled')
            self.Disabled.append(Disabled_)
        elif nodeName_ == 'AllowOutSidePlotArea':
            AllowOutSidePlotArea_ = child_.text
            AllowOutSidePlotArea_ = self.gds_validate_string(AllowOutSidePlotArea_, node, 'AllowOutSidePlotArea')
            self.AllowOutSidePlotArea.append(AllowOutSidePlotArea_)
        elif nodeName_ == 'CalloutBackColor':
            CalloutBackColor_ = child_.text
            CalloutBackColor_ = self.gds_validate_string(CalloutBackColor_, node, 'CalloutBackColor')
            self.CalloutBackColor.append(CalloutBackColor_)
        elif nodeName_ == 'CalloutLineAnchor':
            CalloutLineAnchor_ = child_.text
            CalloutLineAnchor_ = self.gds_validate_string(CalloutLineAnchor_, node, 'CalloutLineAnchor')
            self.CalloutLineAnchor.append(CalloutLineAnchor_)
        elif nodeName_ == 'CalloutLineColor':
            CalloutLineColor_ = child_.text
            CalloutLineColor_ = self.gds_validate_string(CalloutLineColor_, node, 'CalloutLineColor')
            self.CalloutLineColor.append(CalloutLineColor_)
        elif nodeName_ == 'CalloutLineStyle':
            CalloutLineStyle_ = child_.text
            CalloutLineStyle_ = self.gds_validate_string(CalloutLineStyle_, node, 'CalloutLineStyle')
            self.CalloutLineStyle.append(CalloutLineStyle_)
        elif nodeName_ == 'CalloutLineWidth':
            CalloutLineWidth_ = child_.text
            CalloutLineWidth_ = self.gds_validate_string(CalloutLineWidth_, node, 'CalloutLineWidth')
            self.CalloutLineWidth.append(CalloutLineWidth_)
        elif nodeName_ == 'CalloutStyle':
            CalloutStyle_ = child_.text
            CalloutStyle_ = self.gds_validate_string(CalloutStyle_, node, 'CalloutStyle')
            self.CalloutStyle.append(CalloutStyle_)
        elif nodeName_ == 'ShowOverlapped':
            ShowOverlapped_ = child_.text
            ShowOverlapped_ = self.gds_validate_string(ShowOverlapped_, node, 'ShowOverlapped')
            self.ShowOverlapped.append(ShowOverlapped_)
        elif nodeName_ == 'MarkerOverlapping':
            MarkerOverlapping_ = child_.text
            MarkerOverlapping_ = self.gds_validate_string(MarkerOverlapping_, node, 'MarkerOverlapping')
            self.MarkerOverlapping.append(MarkerOverlapping_)
        elif nodeName_ == 'MaxMovingDistance':
            MaxMovingDistance_ = child_.text
            MaxMovingDistance_ = self.gds_validate_string(MaxMovingDistance_, node, 'MaxMovingDistance')
            self.MaxMovingDistance.append(MaxMovingDistance_)
        elif nodeName_ == 'MinMovingDistance':
            MinMovingDistance_ = child_.text
            MinMovingDistance_ = self.gds_validate_string(MinMovingDistance_, node, 'MinMovingDistance')
            self.MinMovingDistance.append(MinMovingDistance_)
        elif nodeName_ == 'ChartNoMoveDirections':
            obj_ = ChartNoMoveDirectionsType.factory()
            obj_.build(child_)
            self.ChartNoMoveDirections.append(obj_)
# end class ChartSmartLabelType


class ChartNoMoveDirectionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Up=None, Left=None, Right=None, Down=None, UpLeft=None, UpRight=None, DownLeft=None, DownRight=None):
        if Up is None:
            self.Up = []
        else:
            self.Up = Up
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Right is None:
            self.Right = []
        else:
            self.Right = Right
        if Down is None:
            self.Down = []
        else:
            self.Down = Down
        if UpLeft is None:
            self.UpLeft = []
        else:
            self.UpLeft = UpLeft
        if UpRight is None:
            self.UpRight = []
        else:
            self.UpRight = UpRight
        if DownLeft is None:
            self.DownLeft = []
        else:
            self.DownLeft = DownLeft
        if DownRight is None:
            self.DownRight = []
        else:
            self.DownRight = DownRight
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartNoMoveDirectionsType.subclass:
            return ChartNoMoveDirectionsType.subclass(*args_, **kwargs_)
        else:
            return ChartNoMoveDirectionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Up(self): return self.Up
    def set_Up(self, Up): self.Up = Up
    def add_Up(self, value): self.Up.append(value)
    def insert_Up(self, index, value): self.Up[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Right(self): return self.Right
    def set_Right(self, Right): self.Right = Right
    def add_Right(self, value): self.Right.append(value)
    def insert_Right(self, index, value): self.Right[index] = value
    def get_Down(self): return self.Down
    def set_Down(self, Down): self.Down = Down
    def add_Down(self, value): self.Down.append(value)
    def insert_Down(self, index, value): self.Down[index] = value
    def get_UpLeft(self): return self.UpLeft
    def set_UpLeft(self, UpLeft): self.UpLeft = UpLeft
    def add_UpLeft(self, value): self.UpLeft.append(value)
    def insert_UpLeft(self, index, value): self.UpLeft[index] = value
    def get_UpRight(self): return self.UpRight
    def set_UpRight(self, UpRight): self.UpRight = UpRight
    def add_UpRight(self, value): self.UpRight.append(value)
    def insert_UpRight(self, index, value): self.UpRight[index] = value
    def get_DownLeft(self): return self.DownLeft
    def set_DownLeft(self, DownLeft): self.DownLeft = DownLeft
    def add_DownLeft(self, value): self.DownLeft.append(value)
    def insert_DownLeft(self, index, value): self.DownLeft[index] = value
    def get_DownRight(self): return self.DownRight
    def set_DownRight(self, DownRight): self.DownRight = DownRight
    def add_DownRight(self, value): self.DownRight.append(value)
    def insert_DownRight(self, index, value): self.DownRight[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartNoMoveDirectionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartNoMoveDirectionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartNoMoveDirectionsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartNoMoveDirectionsType', fromsubclass_=False):
        for Up_ in self.Up:
            showIndent(outfile, level)
            outfile.write('<%sUp>%s</%sUp>\n' % (namespace_, self.gds_format_string(quote_xml(Up_).encode(ExternalEncoding), input_name='Up'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Right_ in self.Right:
            showIndent(outfile, level)
            outfile.write('<%sRight>%s</%sRight>\n' % (namespace_, self.gds_format_string(quote_xml(Right_).encode(ExternalEncoding), input_name='Right'), namespace_))
        for Down_ in self.Down:
            showIndent(outfile, level)
            outfile.write('<%sDown>%s</%sDown>\n' % (namespace_, self.gds_format_string(quote_xml(Down_).encode(ExternalEncoding), input_name='Down'), namespace_))
        for UpLeft_ in self.UpLeft:
            showIndent(outfile, level)
            outfile.write('<%sUpLeft>%s</%sUpLeft>\n' % (namespace_, self.gds_format_string(quote_xml(UpLeft_).encode(ExternalEncoding), input_name='UpLeft'), namespace_))
        for UpRight_ in self.UpRight:
            showIndent(outfile, level)
            outfile.write('<%sUpRight>%s</%sUpRight>\n' % (namespace_, self.gds_format_string(quote_xml(UpRight_).encode(ExternalEncoding), input_name='UpRight'), namespace_))
        for DownLeft_ in self.DownLeft:
            showIndent(outfile, level)
            outfile.write('<%sDownLeft>%s</%sDownLeft>\n' % (namespace_, self.gds_format_string(quote_xml(DownLeft_).encode(ExternalEncoding), input_name='DownLeft'), namespace_))
        for DownRight_ in self.DownRight:
            showIndent(outfile, level)
            outfile.write('<%sDownRight>%s</%sDownRight>\n' % (namespace_, self.gds_format_string(quote_xml(DownRight_).encode(ExternalEncoding), input_name='DownRight'), namespace_))
    def hasContent_(self):
        if (
            self.Up or
            self.Left or
            self.Right or
            self.Down or
            self.UpLeft or
            self.UpRight or
            self.DownLeft or
            self.DownRight
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartNoMoveDirectionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Up=[\n')
        level += 1
        for Up_ in self.Up:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Up_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Right=[\n')
        level += 1
        for Right_ in self.Right:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Right_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Down=[\n')
        level += 1
        for Down_ in self.Down:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Down_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UpLeft=[\n')
        level += 1
        for UpLeft_ in self.UpLeft:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UpLeft_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UpRight=[\n')
        level += 1
        for UpRight_ in self.UpRight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UpRight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DownLeft=[\n')
        level += 1
        for DownLeft_ in self.DownLeft:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DownLeft_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DownRight=[\n')
        level += 1
        for DownRight_ in self.DownRight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DownRight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Up':
            Up_ = child_.text
            Up_ = self.gds_validate_string(Up_, node, 'Up')
            self.Up.append(Up_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Right':
            Right_ = child_.text
            Right_ = self.gds_validate_string(Right_, node, 'Right')
            self.Right.append(Right_)
        elif nodeName_ == 'Down':
            Down_ = child_.text
            Down_ = self.gds_validate_string(Down_, node, 'Down')
            self.Down.append(Down_)
        elif nodeName_ == 'UpLeft':
            UpLeft_ = child_.text
            UpLeft_ = self.gds_validate_string(UpLeft_, node, 'UpLeft')
            self.UpLeft.append(UpLeft_)
        elif nodeName_ == 'UpRight':
            UpRight_ = child_.text
            UpRight_ = self.gds_validate_string(UpRight_, node, 'UpRight')
            self.UpRight.append(UpRight_)
        elif nodeName_ == 'DownLeft':
            DownLeft_ = child_.text
            DownLeft_ = self.gds_validate_string(DownLeft_, node, 'DownLeft')
            self.DownLeft.append(DownLeft_)
        elif nodeName_ == 'DownRight':
            DownRight_ = child_.text
            DownRight_ = self.gds_validate_string(DownRight_, node, 'DownRight')
            self.DownRight.append(DownRight_)
# end class ChartNoMoveDirectionsType


class ChartThreeDPropertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Enabled=None, ProjectionMode=None, Rotation=None, Inclination=None, Perspective=None, DepthRatio=None, Shading=None, GapDepth=None, WallThickness=None, Clustered=None):
        if Enabled is None:
            self.Enabled = []
        else:
            self.Enabled = Enabled
        if ProjectionMode is None:
            self.ProjectionMode = []
        else:
            self.ProjectionMode = ProjectionMode
        if Rotation is None:
            self.Rotation = []
        else:
            self.Rotation = Rotation
        if Inclination is None:
            self.Inclination = []
        else:
            self.Inclination = Inclination
        if Perspective is None:
            self.Perspective = []
        else:
            self.Perspective = Perspective
        if DepthRatio is None:
            self.DepthRatio = []
        else:
            self.DepthRatio = DepthRatio
        if Shading is None:
            self.Shading = []
        else:
            self.Shading = Shading
        if GapDepth is None:
            self.GapDepth = []
        else:
            self.GapDepth = GapDepth
        if WallThickness is None:
            self.WallThickness = []
        else:
            self.WallThickness = WallThickness
        if Clustered is None:
            self.Clustered = []
        else:
            self.Clustered = Clustered
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartThreeDPropertiesType.subclass:
            return ChartThreeDPropertiesType.subclass(*args_, **kwargs_)
        else:
            return ChartThreeDPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def add_Enabled(self, value): self.Enabled.append(value)
    def insert_Enabled(self, index, value): self.Enabled[index] = value
    def get_ProjectionMode(self): return self.ProjectionMode
    def set_ProjectionMode(self, ProjectionMode): self.ProjectionMode = ProjectionMode
    def add_ProjectionMode(self, value): self.ProjectionMode.append(value)
    def insert_ProjectionMode(self, index, value): self.ProjectionMode[index] = value
    def get_Rotation(self): return self.Rotation
    def set_Rotation(self, Rotation): self.Rotation = Rotation
    def add_Rotation(self, value): self.Rotation.append(value)
    def insert_Rotation(self, index, value): self.Rotation[index] = value
    def get_Inclination(self): return self.Inclination
    def set_Inclination(self, Inclination): self.Inclination = Inclination
    def add_Inclination(self, value): self.Inclination.append(value)
    def insert_Inclination(self, index, value): self.Inclination[index] = value
    def get_Perspective(self): return self.Perspective
    def set_Perspective(self, Perspective): self.Perspective = Perspective
    def add_Perspective(self, value): self.Perspective.append(value)
    def insert_Perspective(self, index, value): self.Perspective[index] = value
    def get_DepthRatio(self): return self.DepthRatio
    def set_DepthRatio(self, DepthRatio): self.DepthRatio = DepthRatio
    def add_DepthRatio(self, value): self.DepthRatio.append(value)
    def insert_DepthRatio(self, index, value): self.DepthRatio[index] = value
    def get_Shading(self): return self.Shading
    def set_Shading(self, Shading): self.Shading = Shading
    def add_Shading(self, value): self.Shading.append(value)
    def insert_Shading(self, index, value): self.Shading[index] = value
    def get_GapDepth(self): return self.GapDepth
    def set_GapDepth(self, GapDepth): self.GapDepth = GapDepth
    def add_GapDepth(self, value): self.GapDepth.append(value)
    def insert_GapDepth(self, index, value): self.GapDepth[index] = value
    def get_WallThickness(self): return self.WallThickness
    def set_WallThickness(self, WallThickness): self.WallThickness = WallThickness
    def add_WallThickness(self, value): self.WallThickness.append(value)
    def insert_WallThickness(self, index, value): self.WallThickness[index] = value
    def get_Clustered(self): return self.Clustered
    def set_Clustered(self, Clustered): self.Clustered = Clustered
    def add_Clustered(self, value): self.Clustered.append(value)
    def insert_Clustered(self, index, value): self.Clustered[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartThreeDPropertiesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartThreeDPropertiesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartThreeDPropertiesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartThreeDPropertiesType', fromsubclass_=False):
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('<%sEnabled>%s</%sEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(Enabled_).encode(ExternalEncoding), input_name='Enabled'), namespace_))
        for ProjectionMode_ in self.ProjectionMode:
            showIndent(outfile, level)
            outfile.write('<%sProjectionMode>%s</%sProjectionMode>\n' % (namespace_, self.gds_format_string(quote_xml(ProjectionMode_).encode(ExternalEncoding), input_name='ProjectionMode'), namespace_))
        for Rotation_ in self.Rotation:
            showIndent(outfile, level)
            outfile.write('<%sRotation>%s</%sRotation>\n' % (namespace_, self.gds_format_string(quote_xml(Rotation_).encode(ExternalEncoding), input_name='Rotation'), namespace_))
        for Inclination_ in self.Inclination:
            showIndent(outfile, level)
            outfile.write('<%sInclination>%s</%sInclination>\n' % (namespace_, self.gds_format_string(quote_xml(Inclination_).encode(ExternalEncoding), input_name='Inclination'), namespace_))
        for Perspective_ in self.Perspective:
            showIndent(outfile, level)
            outfile.write('<%sPerspective>%s</%sPerspective>\n' % (namespace_, self.gds_format_string(quote_xml(Perspective_).encode(ExternalEncoding), input_name='Perspective'), namespace_))
        for DepthRatio_ in self.DepthRatio:
            showIndent(outfile, level)
            outfile.write('<%sDepthRatio>%s</%sDepthRatio>\n' % (namespace_, self.gds_format_string(quote_xml(DepthRatio_).encode(ExternalEncoding), input_name='DepthRatio'), namespace_))
        for Shading_ in self.Shading:
            showIndent(outfile, level)
            outfile.write('<%sShading>%s</%sShading>\n' % (namespace_, self.gds_format_string(quote_xml(Shading_).encode(ExternalEncoding), input_name='Shading'), namespace_))
        for GapDepth_ in self.GapDepth:
            showIndent(outfile, level)
            outfile.write('<%sGapDepth>%s</%sGapDepth>\n' % (namespace_, self.gds_format_string(quote_xml(GapDepth_).encode(ExternalEncoding), input_name='GapDepth'), namespace_))
        for WallThickness_ in self.WallThickness:
            showIndent(outfile, level)
            outfile.write('<%sWallThickness>%s</%sWallThickness>\n' % (namespace_, self.gds_format_string(quote_xml(WallThickness_).encode(ExternalEncoding), input_name='WallThickness'), namespace_))
        for Clustered_ in self.Clustered:
            showIndent(outfile, level)
            outfile.write('<%sClustered>%s</%sClustered>\n' % (namespace_, self.gds_format_string(quote_xml(Clustered_).encode(ExternalEncoding), input_name='Clustered'), namespace_))
    def hasContent_(self):
        if (
            self.Enabled or
            self.ProjectionMode or
            self.Rotation or
            self.Inclination or
            self.Perspective or
            self.DepthRatio or
            self.Shading or
            self.GapDepth or
            self.WallThickness or
            self.Clustered
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartThreeDPropertiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Enabled=[\n')
        level += 1
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Enabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProjectionMode=[\n')
        level += 1
        for ProjectionMode_ in self.ProjectionMode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProjectionMode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Rotation=[\n')
        level += 1
        for Rotation_ in self.Rotation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Rotation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Inclination=[\n')
        level += 1
        for Inclination_ in self.Inclination:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Inclination_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Perspective=[\n')
        level += 1
        for Perspective_ in self.Perspective:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Perspective_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DepthRatio=[\n')
        level += 1
        for DepthRatio_ in self.DepthRatio:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DepthRatio_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Shading=[\n')
        level += 1
        for Shading_ in self.Shading:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Shading_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GapDepth=[\n')
        level += 1
        for GapDepth_ in self.GapDepth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GapDepth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('WallThickness=[\n')
        level += 1
        for WallThickness_ in self.WallThickness:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(WallThickness_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Clustered=[\n')
        level += 1
        for Clustered_ in self.Clustered:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Clustered_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            Enabled_ = child_.text
            Enabled_ = self.gds_validate_string(Enabled_, node, 'Enabled')
            self.Enabled.append(Enabled_)
        elif nodeName_ == 'ProjectionMode':
            ProjectionMode_ = child_.text
            ProjectionMode_ = self.gds_validate_string(ProjectionMode_, node, 'ProjectionMode')
            self.ProjectionMode.append(ProjectionMode_)
        elif nodeName_ == 'Rotation':
            Rotation_ = child_.text
            Rotation_ = self.gds_validate_string(Rotation_, node, 'Rotation')
            self.Rotation.append(Rotation_)
        elif nodeName_ == 'Inclination':
            Inclination_ = child_.text
            Inclination_ = self.gds_validate_string(Inclination_, node, 'Inclination')
            self.Inclination.append(Inclination_)
        elif nodeName_ == 'Perspective':
            Perspective_ = child_.text
            Perspective_ = self.gds_validate_string(Perspective_, node, 'Perspective')
            self.Perspective.append(Perspective_)
        elif nodeName_ == 'DepthRatio':
            DepthRatio_ = child_.text
            DepthRatio_ = self.gds_validate_string(DepthRatio_, node, 'DepthRatio')
            self.DepthRatio.append(DepthRatio_)
        elif nodeName_ == 'Shading':
            Shading_ = child_.text
            Shading_ = self.gds_validate_string(Shading_, node, 'Shading')
            self.Shading.append(Shading_)
        elif nodeName_ == 'GapDepth':
            GapDepth_ = child_.text
            GapDepth_ = self.gds_validate_string(GapDepth_, node, 'GapDepth')
            self.GapDepth.append(GapDepth_)
        elif nodeName_ == 'WallThickness':
            WallThickness_ = child_.text
            WallThickness_ = self.gds_validate_string(WallThickness_, node, 'WallThickness')
            self.WallThickness.append(WallThickness_)
        elif nodeName_ == 'Clustered':
            Clustered_ = child_.text
            Clustered_ = self.gds_validate_string(Clustered_, node, 'Clustered')
            self.Clustered.append(Clustered_)
# end class ChartThreeDPropertiesType


class ChartGridLinesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Enabled=None, Style=None, Interval=None, IntervalType=None, IntervalOffset=None, IntervalOffsetType=None):
        if Enabled is None:
            self.Enabled = []
        else:
            self.Enabled = Enabled
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalType is None:
            self.IntervalType = []
        else:
            self.IntervalType = IntervalType
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if IntervalOffsetType is None:
            self.IntervalOffsetType = []
        else:
            self.IntervalOffsetType = IntervalOffsetType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartGridLinesType.subclass:
            return ChartGridLinesType.subclass(*args_, **kwargs_)
        else:
            return ChartGridLinesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def add_Enabled(self, value): self.Enabled.append(value)
    def insert_Enabled(self, index, value): self.Enabled[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalType(self): return self.IntervalType
    def set_IntervalType(self, IntervalType): self.IntervalType = IntervalType
    def add_IntervalType(self, value): self.IntervalType.append(value)
    def insert_IntervalType(self, index, value): self.IntervalType[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_IntervalOffsetType(self): return self.IntervalOffsetType
    def set_IntervalOffsetType(self, IntervalOffsetType): self.IntervalOffsetType = IntervalOffsetType
    def add_IntervalOffsetType(self, value): self.IntervalOffsetType.append(value)
    def insert_IntervalOffsetType(self, index, value): self.IntervalOffsetType[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartGridLinesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartGridLinesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartGridLinesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartGridLinesType', fromsubclass_=False):
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('<%sEnabled>%s</%sEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(Enabled_).encode(ExternalEncoding), input_name='Enabled'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalType>%s</%sIntervalType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalType_).encode(ExternalEncoding), input_name='IntervalType'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffsetType>%s</%sIntervalOffsetType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffsetType_).encode(ExternalEncoding), input_name='IntervalOffsetType'), namespace_))
    def hasContent_(self):
        if (
            self.Enabled or
            self.Style or
            self.Interval or
            self.IntervalType or
            self.IntervalOffset or
            self.IntervalOffsetType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartGridLinesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Enabled=[\n')
        level += 1
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Enabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalType=[\n')
        level += 1
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffsetType=[\n')
        level += 1
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffsetType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            Enabled_ = child_.text
            Enabled_ = self.gds_validate_string(Enabled_, node, 'Enabled')
            self.Enabled.append(Enabled_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalType':
            IntervalType_ = child_.text
            IntervalType_ = self.gds_validate_string(IntervalType_, node, 'IntervalType')
            self.IntervalType.append(IntervalType_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'IntervalOffsetType':
            IntervalOffsetType_ = child_.text
            IntervalOffsetType_ = self.gds_validate_string(IntervalOffsetType_, node, 'IntervalOffsetType')
            self.IntervalOffsetType.append(IntervalOffsetType_)
# end class ChartGridLinesType


class ChartTickMarksType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Enabled=None, Type=None, Style=None, Length=None, Interval=None, IntervalType=None, IntervalOffset=None, IntervalOffsetType=None):
        if Enabled is None:
            self.Enabled = []
        else:
            self.Enabled = Enabled
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Length is None:
            self.Length = []
        else:
            self.Length = Length
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalType is None:
            self.IntervalType = []
        else:
            self.IntervalType = IntervalType
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if IntervalOffsetType is None:
            self.IntervalOffsetType = []
        else:
            self.IntervalOffsetType = IntervalOffsetType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartTickMarksType.subclass:
            return ChartTickMarksType.subclass(*args_, **kwargs_)
        else:
            return ChartTickMarksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def add_Enabled(self, value): self.Enabled.append(value)
    def insert_Enabled(self, index, value): self.Enabled[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def add_Length(self, value): self.Length.append(value)
    def insert_Length(self, index, value): self.Length[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalType(self): return self.IntervalType
    def set_IntervalType(self, IntervalType): self.IntervalType = IntervalType
    def add_IntervalType(self, value): self.IntervalType.append(value)
    def insert_IntervalType(self, index, value): self.IntervalType[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_IntervalOffsetType(self): return self.IntervalOffsetType
    def set_IntervalOffsetType(self, IntervalOffsetType): self.IntervalOffsetType = IntervalOffsetType
    def add_IntervalOffsetType(self, value): self.IntervalOffsetType.append(value)
    def insert_IntervalOffsetType(self, index, value): self.IntervalOffsetType[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartTickMarksType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartTickMarksType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartTickMarksType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartTickMarksType', fromsubclass_=False):
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('<%sEnabled>%s</%sEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(Enabled_).encode(ExternalEncoding), input_name='Enabled'), namespace_))
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(Type_).encode(ExternalEncoding), input_name='Type'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('<%sLength>%s</%sLength>\n' % (namespace_, self.gds_format_string(quote_xml(Length_).encode(ExternalEncoding), input_name='Length'), namespace_))
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalType>%s</%sIntervalType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalType_).encode(ExternalEncoding), input_name='IntervalType'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffsetType>%s</%sIntervalOffsetType>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffsetType_).encode(ExternalEncoding), input_name='IntervalOffsetType'), namespace_))
    def hasContent_(self):
        if (
            self.Enabled or
            self.Type or
            self.Style or
            self.Length or
            self.Interval or
            self.IntervalType or
            self.IntervalOffset or
            self.IntervalOffsetType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartTickMarksType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Enabled=[\n')
        level += 1
        for Enabled_ in self.Enabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Enabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Length=[\n')
        level += 1
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Length_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalType=[\n')
        level += 1
        for IntervalType_ in self.IntervalType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffsetType=[\n')
        level += 1
        for IntervalOffsetType_ in self.IntervalOffsetType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffsetType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            Enabled_ = child_.text
            Enabled_ = self.gds_validate_string(Enabled_, node, 'Enabled')
            self.Enabled.append(Enabled_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Length':
            Length_ = child_.text
            Length_ = self.gds_validate_string(Length_, node, 'Length')
            self.Length.append(Length_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalType':
            IntervalType_ = child_.text
            IntervalType_ = self.gds_validate_string(IntervalType_, node, 'IntervalType')
            self.IntervalType.append(IntervalType_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'IntervalOffsetType':
            IntervalOffsetType_ = child_.text
            IntervalOffsetType_ = self.gds_validate_string(IntervalOffsetType_, node, 'IntervalOffsetType')
            self.IntervalOffsetType.append(IntervalOffsetType_)
# end class ChartTickMarksType


class ChartAnnotationsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ChartAnnotation=None):
        if ChartAnnotation is None:
            self.ChartAnnotation = []
        else:
            self.ChartAnnotation = ChartAnnotation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ChartAnnotationsType.subclass:
            return ChartAnnotationsType.subclass(*args_, **kwargs_)
        else:
            return ChartAnnotationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChartAnnotation(self): return self.ChartAnnotation
    def set_ChartAnnotation(self, ChartAnnotation): self.ChartAnnotation = ChartAnnotation
    def add_ChartAnnotation(self, value): self.ChartAnnotation.append(value)
    def insert_ChartAnnotation(self, index, value): self.ChartAnnotation[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ChartAnnotationsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAnnotationsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAnnotationsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAnnotationsType', fromsubclass_=False):
        for ChartAnnotation_ in self.ChartAnnotation:
            ChartAnnotation_.export(outfile, level, namespace_, name_='ChartAnnotation')
    def hasContent_(self):
        if (
            self.ChartAnnotation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAnnotationsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ChartAnnotation=[\n')
        level += 1
        for ChartAnnotation_ in self.ChartAnnotation:
            showIndent(outfile, level)
            outfile.write('model_.ChartAnnotationType(\n')
            ChartAnnotation_.exportLiteral(outfile, level, name_='ChartAnnotationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChartAnnotation':
            obj_ = ChartAnnotationType.factory()
            obj_.build(child_)
            self.ChartAnnotation.append(obj_)
# end class ChartAnnotationsType


class ChartAnnotationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ChartAnnotationType.subclass:
            return ChartAnnotationType.subclass(*args_, **kwargs_)
        else:
            return ChartAnnotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ChartAnnotationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChartAnnotationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChartAnnotationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChartAnnotationType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ChartAnnotationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChartAnnotationType


class StyleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Border=None, TopBorder=None, BottomBorder=None, LeftBorder=None, RightBorder=None, BackgroundColor=None, BackgroundGradientType=None, BackgroundGradientEndColor=None, BackgroundHatchType=None, BackgroundImage=None, FontStyle=None, FontFamily=None, FontSize=None, FontWeight=None, Format=None, TextDecoration=None, TextAlign=None, TextEffect=None, VerticalAlign=None, Color=None, ShadowColor=None, ShadowOffset=None, PaddingLeft=None, PaddingRight=None, PaddingTop=None, PaddingBottom=None, LineHeight=None, Direction=None, WritingMode=None, Language=None, UnicodeBiDi=None, Calendar=None, NumeralLanguage=None, NumeralVariant=None):
        if Border is None:
            self.Border = []
        else:
            self.Border = Border
        if TopBorder is None:
            self.TopBorder = []
        else:
            self.TopBorder = TopBorder
        if BottomBorder is None:
            self.BottomBorder = []
        else:
            self.BottomBorder = BottomBorder
        if LeftBorder is None:
            self.LeftBorder = []
        else:
            self.LeftBorder = LeftBorder
        if RightBorder is None:
            self.RightBorder = []
        else:
            self.RightBorder = RightBorder
        if BackgroundColor is None:
            self.BackgroundColor = []
        else:
            self.BackgroundColor = BackgroundColor
        if BackgroundGradientType is None:
            self.BackgroundGradientType = []
        else:
            self.BackgroundGradientType = BackgroundGradientType
        if BackgroundGradientEndColor is None:
            self.BackgroundGradientEndColor = []
        else:
            self.BackgroundGradientEndColor = BackgroundGradientEndColor
        if BackgroundHatchType is None:
            self.BackgroundHatchType = []
        else:
            self.BackgroundHatchType = BackgroundHatchType
        if BackgroundImage is None:
            self.BackgroundImage = []
        else:
            self.BackgroundImage = BackgroundImage
        if FontStyle is None:
            self.FontStyle = []
        else:
            self.FontStyle = FontStyle
        if FontFamily is None:
            self.FontFamily = []
        else:
            self.FontFamily = FontFamily
        if FontSize is None:
            self.FontSize = []
        else:
            self.FontSize = FontSize
        if FontWeight is None:
            self.FontWeight = []
        else:
            self.FontWeight = FontWeight
        if Format is None:
            self.Format = []
        else:
            self.Format = Format
        if TextDecoration is None:
            self.TextDecoration = []
        else:
            self.TextDecoration = TextDecoration
        if TextAlign is None:
            self.TextAlign = []
        else:
            self.TextAlign = TextAlign
        if TextEffect is None:
            self.TextEffect = []
        else:
            self.TextEffect = TextEffect
        if VerticalAlign is None:
            self.VerticalAlign = []
        else:
            self.VerticalAlign = VerticalAlign
        if Color is None:
            self.Color = []
        else:
            self.Color = Color
        if ShadowColor is None:
            self.ShadowColor = []
        else:
            self.ShadowColor = ShadowColor
        if ShadowOffset is None:
            self.ShadowOffset = []
        else:
            self.ShadowOffset = ShadowOffset
        if PaddingLeft is None:
            self.PaddingLeft = []
        else:
            self.PaddingLeft = PaddingLeft
        if PaddingRight is None:
            self.PaddingRight = []
        else:
            self.PaddingRight = PaddingRight
        if PaddingTop is None:
            self.PaddingTop = []
        else:
            self.PaddingTop = PaddingTop
        if PaddingBottom is None:
            self.PaddingBottom = []
        else:
            self.PaddingBottom = PaddingBottom
        if LineHeight is None:
            self.LineHeight = []
        else:
            self.LineHeight = LineHeight
        if Direction is None:
            self.Direction = []
        else:
            self.Direction = Direction
        if WritingMode is None:
            self.WritingMode = []
        else:
            self.WritingMode = WritingMode
        if Language is None:
            self.Language = []
        else:
            self.Language = Language
        if UnicodeBiDi is None:
            self.UnicodeBiDi = []
        else:
            self.UnicodeBiDi = UnicodeBiDi
        if Calendar is None:
            self.Calendar = []
        else:
            self.Calendar = Calendar
        if NumeralLanguage is None:
            self.NumeralLanguage = []
        else:
            self.NumeralLanguage = NumeralLanguage
        if NumeralVariant is None:
            self.NumeralVariant = []
        else:
            self.NumeralVariant = NumeralVariant
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if StyleType.subclass:
            return StyleType.subclass(*args_, **kwargs_)
        else:
            return StyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Border(self): return self.Border
    def set_Border(self, Border): self.Border = Border
    def add_Border(self, value): self.Border.append(value)
    def insert_Border(self, index, value): self.Border[index] = value
    def get_TopBorder(self): return self.TopBorder
    def set_TopBorder(self, TopBorder): self.TopBorder = TopBorder
    def add_TopBorder(self, value): self.TopBorder.append(value)
    def insert_TopBorder(self, index, value): self.TopBorder[index] = value
    def get_BottomBorder(self): return self.BottomBorder
    def set_BottomBorder(self, BottomBorder): self.BottomBorder = BottomBorder
    def add_BottomBorder(self, value): self.BottomBorder.append(value)
    def insert_BottomBorder(self, index, value): self.BottomBorder[index] = value
    def get_LeftBorder(self): return self.LeftBorder
    def set_LeftBorder(self, LeftBorder): self.LeftBorder = LeftBorder
    def add_LeftBorder(self, value): self.LeftBorder.append(value)
    def insert_LeftBorder(self, index, value): self.LeftBorder[index] = value
    def get_RightBorder(self): return self.RightBorder
    def set_RightBorder(self, RightBorder): self.RightBorder = RightBorder
    def add_RightBorder(self, value): self.RightBorder.append(value)
    def insert_RightBorder(self, index, value): self.RightBorder[index] = value
    def get_BackgroundColor(self): return self.BackgroundColor
    def set_BackgroundColor(self, BackgroundColor): self.BackgroundColor = BackgroundColor
    def add_BackgroundColor(self, value): self.BackgroundColor.append(value)
    def insert_BackgroundColor(self, index, value): self.BackgroundColor[index] = value
    def get_BackgroundGradientType(self): return self.BackgroundGradientType
    def set_BackgroundGradientType(self, BackgroundGradientType): self.BackgroundGradientType = BackgroundGradientType
    def add_BackgroundGradientType(self, value): self.BackgroundGradientType.append(value)
    def insert_BackgroundGradientType(self, index, value): self.BackgroundGradientType[index] = value
    def get_BackgroundGradientEndColor(self): return self.BackgroundGradientEndColor
    def set_BackgroundGradientEndColor(self, BackgroundGradientEndColor): self.BackgroundGradientEndColor = BackgroundGradientEndColor
    def add_BackgroundGradientEndColor(self, value): self.BackgroundGradientEndColor.append(value)
    def insert_BackgroundGradientEndColor(self, index, value): self.BackgroundGradientEndColor[index] = value
    def get_BackgroundHatchType(self): return self.BackgroundHatchType
    def set_BackgroundHatchType(self, BackgroundHatchType): self.BackgroundHatchType = BackgroundHatchType
    def add_BackgroundHatchType(self, value): self.BackgroundHatchType.append(value)
    def insert_BackgroundHatchType(self, index, value): self.BackgroundHatchType[index] = value
    def get_BackgroundImage(self): return self.BackgroundImage
    def set_BackgroundImage(self, BackgroundImage): self.BackgroundImage = BackgroundImage
    def add_BackgroundImage(self, value): self.BackgroundImage.append(value)
    def insert_BackgroundImage(self, index, value): self.BackgroundImage[index] = value
    def get_FontStyle(self): return self.FontStyle
    def set_FontStyle(self, FontStyle): self.FontStyle = FontStyle
    def add_FontStyle(self, value): self.FontStyle.append(value)
    def insert_FontStyle(self, index, value): self.FontStyle[index] = value
    def get_FontFamily(self): return self.FontFamily
    def set_FontFamily(self, FontFamily): self.FontFamily = FontFamily
    def add_FontFamily(self, value): self.FontFamily.append(value)
    def insert_FontFamily(self, index, value): self.FontFamily[index] = value
    def get_FontSize(self): return self.FontSize
    def set_FontSize(self, FontSize): self.FontSize = FontSize
    def add_FontSize(self, value): self.FontSize.append(value)
    def insert_FontSize(self, index, value): self.FontSize[index] = value
    def get_FontWeight(self): return self.FontWeight
    def set_FontWeight(self, FontWeight): self.FontWeight = FontWeight
    def add_FontWeight(self, value): self.FontWeight.append(value)
    def insert_FontWeight(self, index, value): self.FontWeight[index] = value
    def get_Format(self): return self.Format
    def set_Format(self, Format): self.Format = Format
    def add_Format(self, value): self.Format.append(value)
    def insert_Format(self, index, value): self.Format[index] = value
    def get_TextDecoration(self): return self.TextDecoration
    def set_TextDecoration(self, TextDecoration): self.TextDecoration = TextDecoration
    def add_TextDecoration(self, value): self.TextDecoration.append(value)
    def insert_TextDecoration(self, index, value): self.TextDecoration[index] = value
    def get_TextAlign(self): return self.TextAlign
    def set_TextAlign(self, TextAlign): self.TextAlign = TextAlign
    def add_TextAlign(self, value): self.TextAlign.append(value)
    def insert_TextAlign(self, index, value): self.TextAlign[index] = value
    def get_TextEffect(self): return self.TextEffect
    def set_TextEffect(self, TextEffect): self.TextEffect = TextEffect
    def add_TextEffect(self, value): self.TextEffect.append(value)
    def insert_TextEffect(self, index, value): self.TextEffect[index] = value
    def get_VerticalAlign(self): return self.VerticalAlign
    def set_VerticalAlign(self, VerticalAlign): self.VerticalAlign = VerticalAlign
    def add_VerticalAlign(self, value): self.VerticalAlign.append(value)
    def insert_VerticalAlign(self, index, value): self.VerticalAlign[index] = value
    def get_Color(self): return self.Color
    def set_Color(self, Color): self.Color = Color
    def add_Color(self, value): self.Color.append(value)
    def insert_Color(self, index, value): self.Color[index] = value
    def get_ShadowColor(self): return self.ShadowColor
    def set_ShadowColor(self, ShadowColor): self.ShadowColor = ShadowColor
    def add_ShadowColor(self, value): self.ShadowColor.append(value)
    def insert_ShadowColor(self, index, value): self.ShadowColor[index] = value
    def get_ShadowOffset(self): return self.ShadowOffset
    def set_ShadowOffset(self, ShadowOffset): self.ShadowOffset = ShadowOffset
    def add_ShadowOffset(self, value): self.ShadowOffset.append(value)
    def insert_ShadowOffset(self, index, value): self.ShadowOffset[index] = value
    def get_PaddingLeft(self): return self.PaddingLeft
    def set_PaddingLeft(self, PaddingLeft): self.PaddingLeft = PaddingLeft
    def add_PaddingLeft(self, value): self.PaddingLeft.append(value)
    def insert_PaddingLeft(self, index, value): self.PaddingLeft[index] = value
    def get_PaddingRight(self): return self.PaddingRight
    def set_PaddingRight(self, PaddingRight): self.PaddingRight = PaddingRight
    def add_PaddingRight(self, value): self.PaddingRight.append(value)
    def insert_PaddingRight(self, index, value): self.PaddingRight[index] = value
    def get_PaddingTop(self): return self.PaddingTop
    def set_PaddingTop(self, PaddingTop): self.PaddingTop = PaddingTop
    def add_PaddingTop(self, value): self.PaddingTop.append(value)
    def insert_PaddingTop(self, index, value): self.PaddingTop[index] = value
    def get_PaddingBottom(self): return self.PaddingBottom
    def set_PaddingBottom(self, PaddingBottom): self.PaddingBottom = PaddingBottom
    def add_PaddingBottom(self, value): self.PaddingBottom.append(value)
    def insert_PaddingBottom(self, index, value): self.PaddingBottom[index] = value
    def get_LineHeight(self): return self.LineHeight
    def set_LineHeight(self, LineHeight): self.LineHeight = LineHeight
    def add_LineHeight(self, value): self.LineHeight.append(value)
    def insert_LineHeight(self, index, value): self.LineHeight[index] = value
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    def add_Direction(self, value): self.Direction.append(value)
    def insert_Direction(self, index, value): self.Direction[index] = value
    def get_WritingMode(self): return self.WritingMode
    def set_WritingMode(self, WritingMode): self.WritingMode = WritingMode
    def add_WritingMode(self, value): self.WritingMode.append(value)
    def insert_WritingMode(self, index, value): self.WritingMode[index] = value
    def get_Language(self): return self.Language
    def set_Language(self, Language): self.Language = Language
    def add_Language(self, value): self.Language.append(value)
    def insert_Language(self, index, value): self.Language[index] = value
    def get_UnicodeBiDi(self): return self.UnicodeBiDi
    def set_UnicodeBiDi(self, UnicodeBiDi): self.UnicodeBiDi = UnicodeBiDi
    def add_UnicodeBiDi(self, value): self.UnicodeBiDi.append(value)
    def insert_UnicodeBiDi(self, index, value): self.UnicodeBiDi[index] = value
    def get_Calendar(self): return self.Calendar
    def set_Calendar(self, Calendar): self.Calendar = Calendar
    def add_Calendar(self, value): self.Calendar.append(value)
    def insert_Calendar(self, index, value): self.Calendar[index] = value
    def get_NumeralLanguage(self): return self.NumeralLanguage
    def set_NumeralLanguage(self, NumeralLanguage): self.NumeralLanguage = NumeralLanguage
    def add_NumeralLanguage(self, value): self.NumeralLanguage.append(value)
    def insert_NumeralLanguage(self, index, value): self.NumeralLanguage[index] = value
    def get_NumeralVariant(self): return self.NumeralVariant
    def set_NumeralVariant(self, NumeralVariant): self.NumeralVariant = NumeralVariant
    def add_NumeralVariant(self, value): self.NumeralVariant.append(value)
    def insert_NumeralVariant(self, index, value): self.NumeralVariant[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='StyleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StyleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StyleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StyleType', fromsubclass_=False):
        for Border_ in self.Border:
            Border_.export(outfile, level, namespace_, name_='Border')
        for TopBorder_ in self.TopBorder:
            TopBorder_.export(outfile, level, namespace_, name_='TopBorder')
        for BottomBorder_ in self.BottomBorder:
            BottomBorder_.export(outfile, level, namespace_, name_='BottomBorder')
        for LeftBorder_ in self.LeftBorder:
            LeftBorder_.export(outfile, level, namespace_, name_='LeftBorder')
        for RightBorder_ in self.RightBorder:
            RightBorder_.export(outfile, level, namespace_, name_='RightBorder')
        for BackgroundColor_ in self.BackgroundColor:
            showIndent(outfile, level)
            outfile.write('<%sBackgroundColor>%s</%sBackgroundColor>\n' % (namespace_, self.gds_format_string(quote_xml(BackgroundColor_).encode(ExternalEncoding), input_name='BackgroundColor'), namespace_))
        for BackgroundGradientType_ in self.BackgroundGradientType:
            showIndent(outfile, level)
            outfile.write('<%sBackgroundGradientType>%s</%sBackgroundGradientType>\n' % (namespace_, self.gds_format_string(quote_xml(BackgroundGradientType_).encode(ExternalEncoding), input_name='BackgroundGradientType'), namespace_))
        for BackgroundGradientEndColor_ in self.BackgroundGradientEndColor:
            showIndent(outfile, level)
            outfile.write('<%sBackgroundGradientEndColor>%s</%sBackgroundGradientEndColor>\n' % (namespace_, self.gds_format_string(quote_xml(BackgroundGradientEndColor_).encode(ExternalEncoding), input_name='BackgroundGradientEndColor'), namespace_))
        for BackgroundHatchType_ in self.BackgroundHatchType:
            showIndent(outfile, level)
            outfile.write('<%sBackgroundHatchType>%s</%sBackgroundHatchType>\n' % (namespace_, self.gds_format_string(quote_xml(BackgroundHatchType_).encode(ExternalEncoding), input_name='BackgroundHatchType'), namespace_))
        for BackgroundImage_ in self.BackgroundImage:
            BackgroundImage_.export(outfile, level, namespace_, name_='BackgroundImage')
        for FontStyle_ in self.FontStyle:
            showIndent(outfile, level)
            outfile.write('<%sFontStyle>%s</%sFontStyle>\n' % (namespace_, self.gds_format_string(quote_xml(FontStyle_).encode(ExternalEncoding), input_name='FontStyle'), namespace_))
        for FontFamily_ in self.FontFamily:
            showIndent(outfile, level)
            outfile.write('<%sFontFamily>%s</%sFontFamily>\n' % (namespace_, self.gds_format_string(quote_xml(FontFamily_).encode(ExternalEncoding), input_name='FontFamily'), namespace_))
        for FontSize_ in self.FontSize:
            showIndent(outfile, level)
            outfile.write('<%sFontSize>%s</%sFontSize>\n' % (namespace_, self.gds_format_string(quote_xml(FontSize_).encode(ExternalEncoding), input_name='FontSize'), namespace_))
        for FontWeight_ in self.FontWeight:
            showIndent(outfile, level)
            outfile.write('<%sFontWeight>%s</%sFontWeight>\n' % (namespace_, self.gds_format_string(quote_xml(FontWeight_).encode(ExternalEncoding), input_name='FontWeight'), namespace_))
        for Format_ in self.Format:
            showIndent(outfile, level)
            outfile.write('<%sFormat>%s</%sFormat>\n' % (namespace_, self.gds_format_string(quote_xml(Format_).encode(ExternalEncoding), input_name='Format'), namespace_))
        for TextDecoration_ in self.TextDecoration:
            showIndent(outfile, level)
            outfile.write('<%sTextDecoration>%s</%sTextDecoration>\n' % (namespace_, self.gds_format_string(quote_xml(TextDecoration_).encode(ExternalEncoding), input_name='TextDecoration'), namespace_))
        for TextAlign_ in self.TextAlign:
            showIndent(outfile, level)
            outfile.write('<%sTextAlign>%s</%sTextAlign>\n' % (namespace_, self.gds_format_string(quote_xml(TextAlign_).encode(ExternalEncoding), input_name='TextAlign'), namespace_))
        for TextEffect_ in self.TextEffect:
            showIndent(outfile, level)
            outfile.write('<%sTextEffect>%s</%sTextEffect>\n' % (namespace_, self.gds_format_string(quote_xml(TextEffect_).encode(ExternalEncoding), input_name='TextEffect'), namespace_))
        for VerticalAlign_ in self.VerticalAlign:
            showIndent(outfile, level)
            outfile.write('<%sVerticalAlign>%s</%sVerticalAlign>\n' % (namespace_, self.gds_format_string(quote_xml(VerticalAlign_).encode(ExternalEncoding), input_name='VerticalAlign'), namespace_))
        for Color_ in self.Color:
            showIndent(outfile, level)
            outfile.write('<%sColor>%s</%sColor>\n' % (namespace_, self.gds_format_string(quote_xml(Color_).encode(ExternalEncoding), input_name='Color'), namespace_))
        for ShadowColor_ in self.ShadowColor:
            showIndent(outfile, level)
            outfile.write('<%sShadowColor>%s</%sShadowColor>\n' % (namespace_, self.gds_format_string(quote_xml(ShadowColor_).encode(ExternalEncoding), input_name='ShadowColor'), namespace_))
        for ShadowOffset_ in self.ShadowOffset:
            showIndent(outfile, level)
            outfile.write('<%sShadowOffset>%s</%sShadowOffset>\n' % (namespace_, self.gds_format_string(quote_xml(ShadowOffset_).encode(ExternalEncoding), input_name='ShadowOffset'), namespace_))
        for PaddingLeft_ in self.PaddingLeft:
            showIndent(outfile, level)
            outfile.write('<%sPaddingLeft>%s</%sPaddingLeft>\n' % (namespace_, self.gds_format_string(quote_xml(PaddingLeft_).encode(ExternalEncoding), input_name='PaddingLeft'), namespace_))
        for PaddingRight_ in self.PaddingRight:
            showIndent(outfile, level)
            outfile.write('<%sPaddingRight>%s</%sPaddingRight>\n' % (namespace_, self.gds_format_string(quote_xml(PaddingRight_).encode(ExternalEncoding), input_name='PaddingRight'), namespace_))
        for PaddingTop_ in self.PaddingTop:
            showIndent(outfile, level)
            outfile.write('<%sPaddingTop>%s</%sPaddingTop>\n' % (namespace_, self.gds_format_string(quote_xml(PaddingTop_).encode(ExternalEncoding), input_name='PaddingTop'), namespace_))
        for PaddingBottom_ in self.PaddingBottom:
            showIndent(outfile, level)
            outfile.write('<%sPaddingBottom>%s</%sPaddingBottom>\n' % (namespace_, self.gds_format_string(quote_xml(PaddingBottom_).encode(ExternalEncoding), input_name='PaddingBottom'), namespace_))
        for LineHeight_ in self.LineHeight:
            showIndent(outfile, level)
            outfile.write('<%sLineHeight>%s</%sLineHeight>\n' % (namespace_, self.gds_format_string(quote_xml(LineHeight_).encode(ExternalEncoding), input_name='LineHeight'), namespace_))
        for Direction_ in self.Direction:
            showIndent(outfile, level)
            outfile.write('<%sDirection>%s</%sDirection>\n' % (namespace_, self.gds_format_string(quote_xml(Direction_).encode(ExternalEncoding), input_name='Direction'), namespace_))
        for WritingMode_ in self.WritingMode:
            showIndent(outfile, level)
            outfile.write('<%sWritingMode>%s</%sWritingMode>\n' % (namespace_, self.gds_format_string(quote_xml(WritingMode_).encode(ExternalEncoding), input_name='WritingMode'), namespace_))
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('<%sLanguage>%s</%sLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(Language_).encode(ExternalEncoding), input_name='Language'), namespace_))
        for UnicodeBiDi_ in self.UnicodeBiDi:
            showIndent(outfile, level)
            outfile.write('<%sUnicodeBiDi>%s</%sUnicodeBiDi>\n' % (namespace_, self.gds_format_string(quote_xml(UnicodeBiDi_).encode(ExternalEncoding), input_name='UnicodeBiDi'), namespace_))
        for Calendar_ in self.Calendar:
            showIndent(outfile, level)
            outfile.write('<%sCalendar>%s</%sCalendar>\n' % (namespace_, self.gds_format_string(quote_xml(Calendar_).encode(ExternalEncoding), input_name='Calendar'), namespace_))
        for NumeralLanguage_ in self.NumeralLanguage:
            showIndent(outfile, level)
            outfile.write('<%sNumeralLanguage>%s</%sNumeralLanguage>\n' % (namespace_, self.gds_format_string(quote_xml(NumeralLanguage_).encode(ExternalEncoding), input_name='NumeralLanguage'), namespace_))
        for NumeralVariant_ in self.NumeralVariant:
            showIndent(outfile, level)
            outfile.write('<%sNumeralVariant>%s</%sNumeralVariant>\n' % (namespace_, self.gds_format_string(quote_xml(NumeralVariant_).encode(ExternalEncoding), input_name='NumeralVariant'), namespace_))
    def hasContent_(self):
        if (
            self.Border or
            self.TopBorder or
            self.BottomBorder or
            self.LeftBorder or
            self.RightBorder or
            self.BackgroundColor or
            self.BackgroundGradientType or
            self.BackgroundGradientEndColor or
            self.BackgroundHatchType or
            self.BackgroundImage or
            self.FontStyle or
            self.FontFamily or
            self.FontSize or
            self.FontWeight or
            self.Format or
            self.TextDecoration or
            self.TextAlign or
            self.TextEffect or
            self.VerticalAlign or
            self.Color or
            self.ShadowColor or
            self.ShadowOffset or
            self.PaddingLeft or
            self.PaddingRight or
            self.PaddingTop or
            self.PaddingBottom or
            self.LineHeight or
            self.Direction or
            self.WritingMode or
            self.Language or
            self.UnicodeBiDi or
            self.Calendar or
            self.NumeralLanguage or
            self.NumeralVariant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StyleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Border=[\n')
        level += 1
        for Border_ in self.Border:
            showIndent(outfile, level)
            outfile.write('model_.BorderType(\n')
            Border_.exportLiteral(outfile, level, name_='BorderType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TopBorder=[\n')
        level += 1
        for TopBorder_ in self.TopBorder:
            showIndent(outfile, level)
            outfile.write('model_.BorderType(\n')
            TopBorder_.exportLiteral(outfile, level, name_='BorderType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BottomBorder=[\n')
        level += 1
        for BottomBorder_ in self.BottomBorder:
            showIndent(outfile, level)
            outfile.write('model_.BorderType(\n')
            BottomBorder_.exportLiteral(outfile, level, name_='BorderType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LeftBorder=[\n')
        level += 1
        for LeftBorder_ in self.LeftBorder:
            showIndent(outfile, level)
            outfile.write('model_.BorderType(\n')
            LeftBorder_.exportLiteral(outfile, level, name_='BorderType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RightBorder=[\n')
        level += 1
        for RightBorder_ in self.RightBorder:
            showIndent(outfile, level)
            outfile.write('model_.BorderType(\n')
            RightBorder_.exportLiteral(outfile, level, name_='BorderType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundColor=[\n')
        level += 1
        for BackgroundColor_ in self.BackgroundColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BackgroundColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundGradientType=[\n')
        level += 1
        for BackgroundGradientType_ in self.BackgroundGradientType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BackgroundGradientType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundGradientEndColor=[\n')
        level += 1
        for BackgroundGradientEndColor_ in self.BackgroundGradientEndColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BackgroundGradientEndColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundHatchType=[\n')
        level += 1
        for BackgroundHatchType_ in self.BackgroundHatchType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BackgroundHatchType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundImage=[\n')
        level += 1
        for BackgroundImage_ in self.BackgroundImage:
            showIndent(outfile, level)
            outfile.write('model_.BackgroundImageType(\n')
            BackgroundImage_.exportLiteral(outfile, level, name_='BackgroundImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontStyle=[\n')
        level += 1
        for FontStyle_ in self.FontStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontFamily=[\n')
        level += 1
        for FontFamily_ in self.FontFamily:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontFamily_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontSize=[\n')
        level += 1
        for FontSize_ in self.FontSize:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontSize_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontWeight=[\n')
        level += 1
        for FontWeight_ in self.FontWeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontWeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Format=[\n')
        level += 1
        for Format_ in self.Format:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Format_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextDecoration=[\n')
        level += 1
        for TextDecoration_ in self.TextDecoration:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextDecoration_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextAlign=[\n')
        level += 1
        for TextAlign_ in self.TextAlign:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextAlign_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextEffect=[\n')
        level += 1
        for TextEffect_ in self.TextEffect:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextEffect_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('VerticalAlign=[\n')
        level += 1
        for VerticalAlign_ in self.VerticalAlign:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(VerticalAlign_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Color=[\n')
        level += 1
        for Color_ in self.Color:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Color_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShadowColor=[\n')
        level += 1
        for ShadowColor_ in self.ShadowColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShadowColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShadowOffset=[\n')
        level += 1
        for ShadowOffset_ in self.ShadowOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShadowOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaddingLeft=[\n')
        level += 1
        for PaddingLeft_ in self.PaddingLeft:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PaddingLeft_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaddingRight=[\n')
        level += 1
        for PaddingRight_ in self.PaddingRight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PaddingRight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaddingTop=[\n')
        level += 1
        for PaddingTop_ in self.PaddingTop:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PaddingTop_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PaddingBottom=[\n')
        level += 1
        for PaddingBottom_ in self.PaddingBottom:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PaddingBottom_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LineHeight=[\n')
        level += 1
        for LineHeight_ in self.LineHeight:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LineHeight_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Direction=[\n')
        level += 1
        for Direction_ in self.Direction:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Direction_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('WritingMode=[\n')
        level += 1
        for WritingMode_ in self.WritingMode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(WritingMode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Language=[\n')
        level += 1
        for Language_ in self.Language:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UnicodeBiDi=[\n')
        level += 1
        for UnicodeBiDi_ in self.UnicodeBiDi:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UnicodeBiDi_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Calendar=[\n')
        level += 1
        for Calendar_ in self.Calendar:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Calendar_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NumeralLanguage=[\n')
        level += 1
        for NumeralLanguage_ in self.NumeralLanguage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NumeralLanguage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NumeralVariant=[\n')
        level += 1
        for NumeralVariant_ in self.NumeralVariant:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NumeralVariant_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Border':
            obj_ = BorderType.factory()
            obj_.build(child_)
            self.Border.append(obj_)
        elif nodeName_ == 'TopBorder':
            obj_ = BorderType.factory()
            obj_.build(child_)
            self.TopBorder.append(obj_)
        elif nodeName_ == 'BottomBorder':
            obj_ = BorderType.factory()
            obj_.build(child_)
            self.BottomBorder.append(obj_)
        elif nodeName_ == 'LeftBorder':
            obj_ = BorderType.factory()
            obj_.build(child_)
            self.LeftBorder.append(obj_)
        elif nodeName_ == 'RightBorder':
            obj_ = BorderType.factory()
            obj_.build(child_)
            self.RightBorder.append(obj_)
        elif nodeName_ == 'BackgroundColor':
            BackgroundColor_ = child_.text
            BackgroundColor_ = self.gds_validate_string(BackgroundColor_, node, 'BackgroundColor')
            self.BackgroundColor.append(BackgroundColor_)
        elif nodeName_ == 'BackgroundGradientType':
            BackgroundGradientType_ = child_.text
            BackgroundGradientType_ = self.gds_validate_string(BackgroundGradientType_, node, 'BackgroundGradientType')
            self.BackgroundGradientType.append(BackgroundGradientType_)
        elif nodeName_ == 'BackgroundGradientEndColor':
            BackgroundGradientEndColor_ = child_.text
            BackgroundGradientEndColor_ = self.gds_validate_string(BackgroundGradientEndColor_, node, 'BackgroundGradientEndColor')
            self.BackgroundGradientEndColor.append(BackgroundGradientEndColor_)
        elif nodeName_ == 'BackgroundHatchType':
            BackgroundHatchType_ = child_.text
            BackgroundHatchType_ = self.gds_validate_string(BackgroundHatchType_, node, 'BackgroundHatchType')
            self.BackgroundHatchType.append(BackgroundHatchType_)
        elif nodeName_ == 'BackgroundImage':
            obj_ = BackgroundImageType.factory()
            obj_.build(child_)
            self.BackgroundImage.append(obj_)
        elif nodeName_ == 'FontStyle':
            FontStyle_ = child_.text
            FontStyle_ = self.gds_validate_string(FontStyle_, node, 'FontStyle')
            self.FontStyle.append(FontStyle_)
        elif nodeName_ == 'FontFamily':
            FontFamily_ = child_.text
            FontFamily_ = self.gds_validate_string(FontFamily_, node, 'FontFamily')
            self.FontFamily.append(FontFamily_)
        elif nodeName_ == 'FontSize':
            FontSize_ = child_.text
            FontSize_ = self.gds_validate_string(FontSize_, node, 'FontSize')
            self.FontSize.append(FontSize_)
        elif nodeName_ == 'FontWeight':
            FontWeight_ = child_.text
            FontWeight_ = self.gds_validate_string(FontWeight_, node, 'FontWeight')
            self.FontWeight.append(FontWeight_)
        elif nodeName_ == 'Format':
            Format_ = child_.text
            Format_ = self.gds_validate_string(Format_, node, 'Format')
            self.Format.append(Format_)
        elif nodeName_ == 'TextDecoration':
            TextDecoration_ = child_.text
            TextDecoration_ = self.gds_validate_string(TextDecoration_, node, 'TextDecoration')
            self.TextDecoration.append(TextDecoration_)
        elif nodeName_ == 'TextAlign':
            TextAlign_ = child_.text
            TextAlign_ = self.gds_validate_string(TextAlign_, node, 'TextAlign')
            self.TextAlign.append(TextAlign_)
        elif nodeName_ == 'TextEffect':
            TextEffect_ = child_.text
            TextEffect_ = self.gds_validate_string(TextEffect_, node, 'TextEffect')
            self.TextEffect.append(TextEffect_)
        elif nodeName_ == 'VerticalAlign':
            VerticalAlign_ = child_.text
            VerticalAlign_ = self.gds_validate_string(VerticalAlign_, node, 'VerticalAlign')
            self.VerticalAlign.append(VerticalAlign_)
        elif nodeName_ == 'Color':
            Color_ = child_.text
            Color_ = self.gds_validate_string(Color_, node, 'Color')
            self.Color.append(Color_)
        elif nodeName_ == 'ShadowColor':
            ShadowColor_ = child_.text
            ShadowColor_ = self.gds_validate_string(ShadowColor_, node, 'ShadowColor')
            self.ShadowColor.append(ShadowColor_)
        elif nodeName_ == 'ShadowOffset':
            ShadowOffset_ = child_.text
            ShadowOffset_ = self.gds_validate_string(ShadowOffset_, node, 'ShadowOffset')
            self.ShadowOffset.append(ShadowOffset_)
        elif nodeName_ == 'PaddingLeft':
            PaddingLeft_ = child_.text
            PaddingLeft_ = self.gds_validate_string(PaddingLeft_, node, 'PaddingLeft')
            self.PaddingLeft.append(PaddingLeft_)
        elif nodeName_ == 'PaddingRight':
            PaddingRight_ = child_.text
            PaddingRight_ = self.gds_validate_string(PaddingRight_, node, 'PaddingRight')
            self.PaddingRight.append(PaddingRight_)
        elif nodeName_ == 'PaddingTop':
            PaddingTop_ = child_.text
            PaddingTop_ = self.gds_validate_string(PaddingTop_, node, 'PaddingTop')
            self.PaddingTop.append(PaddingTop_)
        elif nodeName_ == 'PaddingBottom':
            PaddingBottom_ = child_.text
            PaddingBottom_ = self.gds_validate_string(PaddingBottom_, node, 'PaddingBottom')
            self.PaddingBottom.append(PaddingBottom_)
        elif nodeName_ == 'LineHeight':
            LineHeight_ = child_.text
            LineHeight_ = self.gds_validate_string(LineHeight_, node, 'LineHeight')
            self.LineHeight.append(LineHeight_)
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction.append(Direction_)
        elif nodeName_ == 'WritingMode':
            WritingMode_ = child_.text
            WritingMode_ = self.gds_validate_string(WritingMode_, node, 'WritingMode')
            self.WritingMode.append(WritingMode_)
        elif nodeName_ == 'Language':
            Language_ = child_.text
            Language_ = self.gds_validate_string(Language_, node, 'Language')
            self.Language.append(Language_)
        elif nodeName_ == 'UnicodeBiDi':
            UnicodeBiDi_ = child_.text
            UnicodeBiDi_ = self.gds_validate_string(UnicodeBiDi_, node, 'UnicodeBiDi')
            self.UnicodeBiDi.append(UnicodeBiDi_)
        elif nodeName_ == 'Calendar':
            Calendar_ = child_.text
            Calendar_ = self.gds_validate_string(Calendar_, node, 'Calendar')
            self.Calendar.append(Calendar_)
        elif nodeName_ == 'NumeralLanguage':
            NumeralLanguage_ = child_.text
            NumeralLanguage_ = self.gds_validate_string(NumeralLanguage_, node, 'NumeralLanguage')
            self.NumeralLanguage.append(NumeralLanguage_)
        elif nodeName_ == 'NumeralVariant':
            NumeralVariant_ = child_.text
            NumeralVariant_ = self.gds_validate_string(NumeralVariant_, node, 'NumeralVariant')
            self.NumeralVariant.append(NumeralVariant_)
# end class StyleType


class BorderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Color=None, Style=None, Width=None):
        if Color is None:
            self.Color = []
        else:
            self.Color = Color
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BorderType.subclass:
            return BorderType.subclass(*args_, **kwargs_)
        else:
            return BorderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Color(self): return self.Color
    def set_Color(self, Color): self.Color = Color
    def add_Color(self, value): self.Color.append(value)
    def insert_Color(self, index, value): self.Color[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BorderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BorderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BorderType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BorderType', fromsubclass_=False):
        for Color_ in self.Color:
            showIndent(outfile, level)
            outfile.write('<%sColor>%s</%sColor>\n' % (namespace_, self.gds_format_string(quote_xml(Color_).encode(ExternalEncoding), input_name='Color'), namespace_))
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('<%sStyle>%s</%sStyle>\n' % (namespace_, self.gds_format_string(quote_xml(Style_).encode(ExternalEncoding), input_name='Style'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
    def hasContent_(self):
        if (
            self.Color or
            self.Style or
            self.Width
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BorderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Color=[\n')
        level += 1
        for Color_ in self.Color:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Color_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Style_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Color':
            Color_ = child_.text
            Color_ = self.gds_validate_string(Color_, node, 'Color')
            self.Color.append(Color_)
        elif nodeName_ == 'Style':
            Style_ = child_.text
            Style_ = self.gds_validate_string(Style_, node, 'Style')
            self.Style.append(Style_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
# end class BorderType


class BackgroundImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Value=None, MIMEType=None, TransparentColor=None, BackgroundRepeat=None, Position=None):
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if BackgroundRepeat is None:
            self.BackgroundRepeat = []
        else:
            self.BackgroundRepeat = BackgroundRepeat
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BackgroundImageType.subclass:
            return BackgroundImageType.subclass(*args_, **kwargs_)
        else:
            return BackgroundImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_BackgroundRepeat(self): return self.BackgroundRepeat
    def set_BackgroundRepeat(self, BackgroundRepeat): self.BackgroundRepeat = BackgroundRepeat
    def add_BackgroundRepeat(self, value): self.BackgroundRepeat.append(value)
    def insert_BackgroundRepeat(self, index, value): self.BackgroundRepeat[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BackgroundImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BackgroundImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BackgroundImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BackgroundImageType', fromsubclass_=False):
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for BackgroundRepeat_ in self.BackgroundRepeat:
            showIndent(outfile, level)
            outfile.write('<%sBackgroundRepeat>%s</%sBackgroundRepeat>\n' % (namespace_, self.gds_format_string(quote_xml(BackgroundRepeat_).encode(ExternalEncoding), input_name='BackgroundRepeat'), namespace_))
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
    def hasContent_(self):
        if (
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.BackgroundRepeat or
            self.Position
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BackgroundImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundRepeat=[\n')
        level += 1
        for BackgroundRepeat_ in self.BackgroundRepeat:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BackgroundRepeat_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'BackgroundRepeat':
            BackgroundRepeat_ = child_.text
            BackgroundRepeat_ = self.gds_validate_string(BackgroundRepeat_, node, 'BackgroundRepeat')
            self.BackgroundRepeat.append(BackgroundRepeat_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
# end class BackgroundImageType


class FiltersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Filter=None):
        if Filter is None:
            self.Filter = []
        else:
            self.Filter = Filter
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FiltersType.subclass:
            return FiltersType.subclass(*args_, **kwargs_)
        else:
            return FiltersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Filter(self): return self.Filter
    def set_Filter(self, Filter): self.Filter = Filter
    def add_Filter(self, value): self.Filter.append(value)
    def insert_Filter(self, index, value): self.Filter[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FiltersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FiltersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FiltersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FiltersType', fromsubclass_=False):
        for Filter_ in self.Filter:
            Filter_.export(outfile, level, namespace_, name_='Filter')
    def hasContent_(self):
        if (
            self.Filter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FiltersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Filter=[\n')
        level += 1
        for Filter_ in self.Filter:
            showIndent(outfile, level)
            outfile.write('model_.FilterType(\n')
            Filter_.exportLiteral(outfile, level, name_='FilterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Filter':
            obj_ = FilterType.factory()
            obj_.build(child_)
            self.Filter.append(obj_)
# end class FiltersType


class FilterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FilterExpression=None, Operator=None, FilterValues=None):
        if FilterExpression is None:
            self.FilterExpression = []
        else:
            self.FilterExpression = FilterExpression
        if Operator is None:
            self.Operator = []
        else:
            self.Operator = Operator
        if FilterValues is None:
            self.FilterValues = []
        else:
            self.FilterValues = FilterValues
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FilterType.subclass:
            return FilterType.subclass(*args_, **kwargs_)
        else:
            return FilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FilterExpression(self): return self.FilterExpression
    def set_FilterExpression(self, FilterExpression): self.FilterExpression = FilterExpression
    def add_FilterExpression(self, value): self.FilterExpression.append(value)
    def insert_FilterExpression(self, index, value): self.FilterExpression[index] = value
    def get_Operator(self): return self.Operator
    def set_Operator(self, Operator): self.Operator = Operator
    def add_Operator(self, value): self.Operator.append(value)
    def insert_Operator(self, index, value): self.Operator[index] = value
    def get_FilterValues(self): return self.FilterValues
    def set_FilterValues(self, FilterValues): self.FilterValues = FilterValues
    def add_FilterValues(self, value): self.FilterValues.append(value)
    def insert_FilterValues(self, index, value): self.FilterValues[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FilterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilterType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FilterType', fromsubclass_=False):
        for FilterExpression_ in self.FilterExpression:
            showIndent(outfile, level)
            outfile.write('<%sFilterExpression>%s</%sFilterExpression>\n' % (namespace_, self.gds_format_string(quote_xml(FilterExpression_).encode(ExternalEncoding), input_name='FilterExpression'), namespace_))
        for Operator_ in self.Operator:
            showIndent(outfile, level)
            outfile.write('<%sOperator>%s</%sOperator>\n' % (namespace_, self.gds_format_string(quote_xml(Operator_).encode(ExternalEncoding), input_name='Operator'), namespace_))
        for FilterValues_ in self.FilterValues:
            FilterValues_.export(outfile, level, namespace_, name_='FilterValues')
    def hasContent_(self):
        if (
            self.FilterExpression or
            self.Operator or
            self.FilterValues
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FilterExpression=[\n')
        level += 1
        for FilterExpression_ in self.FilterExpression:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FilterExpression_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Operator=[\n')
        level += 1
        for Operator_ in self.Operator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Operator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FilterValues=[\n')
        level += 1
        for FilterValues_ in self.FilterValues:
            showIndent(outfile, level)
            outfile.write('model_.FilterValuesType(\n')
            FilterValues_.exportLiteral(outfile, level, name_='FilterValuesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FilterExpression':
            FilterExpression_ = child_.text
            FilterExpression_ = self.gds_validate_string(FilterExpression_, node, 'FilterExpression')
            self.FilterExpression.append(FilterExpression_)
        elif nodeName_ == 'Operator':
            Operator_ = child_.text
            Operator_ = self.gds_validate_string(Operator_, node, 'Operator')
            self.Operator.append(Operator_)
        elif nodeName_ == 'FilterValues':
            obj_ = FilterValuesType.factory()
            obj_.build(child_)
            self.FilterValues.append(obj_)
# end class FilterType


class Operator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Operator.subclass:
            return Operator.subclass(*args_, **kwargs_)
        else:
            return Operator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Operator', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Operator')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Operator'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Operator', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Operator'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Operator


class FilterValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FilterValue=None):
        if FilterValue is None:
            self.FilterValue = []
        else:
            self.FilterValue = FilterValue
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FilterValuesType.subclass:
            return FilterValuesType.subclass(*args_, **kwargs_)
        else:
            return FilterValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FilterValue(self): return self.FilterValue
    def set_FilterValue(self, FilterValue): self.FilterValue = FilterValue
    def add_FilterValue(self, value): self.FilterValue.append(value)
    def insert_FilterValue(self, index, value): self.FilterValue[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FilterValuesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilterValuesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilterValuesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FilterValuesType', fromsubclass_=False):
        for FilterValue_ in self.FilterValue:
            FilterValue_.export(outfile, level, namespace_, name_='FilterValue')
    def hasContent_(self):
        if (
            self.FilterValue
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilterValuesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FilterValue=[\n')
        level += 1
        for FilterValue_ in self.FilterValue:
            showIndent(outfile, level)
            outfile.write('model_.StringWithDataTypeAttribute(\n')
            FilterValue_.exportLiteral(outfile, level, name_='StringWithDataTypeAttribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FilterValue':
            class_obj_ = self.get_class_obj_(child_, StringWithDataTypeAttribute)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FilterValue.append(obj_)
# end class FilterValuesType


class UserSortType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SortExpression=None, SortExpressionScope=None, SortTarget=None):
        if SortExpression is None:
            self.SortExpression = []
        else:
            self.SortExpression = SortExpression
        if SortExpressionScope is None:
            self.SortExpressionScope = []
        else:
            self.SortExpressionScope = SortExpressionScope
        if SortTarget is None:
            self.SortTarget = []
        else:
            self.SortTarget = SortTarget
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if UserSortType.subclass:
            return UserSortType.subclass(*args_, **kwargs_)
        else:
            return UserSortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SortExpression(self): return self.SortExpression
    def set_SortExpression(self, SortExpression): self.SortExpression = SortExpression
    def add_SortExpression(self, value): self.SortExpression.append(value)
    def insert_SortExpression(self, index, value): self.SortExpression[index] = value
    def get_SortExpressionScope(self): return self.SortExpressionScope
    def set_SortExpressionScope(self, SortExpressionScope): self.SortExpressionScope = SortExpressionScope
    def add_SortExpressionScope(self, value): self.SortExpressionScope.append(value)
    def insert_SortExpressionScope(self, index, value): self.SortExpressionScope[index] = value
    def get_SortTarget(self): return self.SortTarget
    def set_SortTarget(self, SortTarget): self.SortTarget = SortTarget
    def add_SortTarget(self, value): self.SortTarget.append(value)
    def insert_SortTarget(self, index, value): self.SortTarget[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='UserSortType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UserSortType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UserSortType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UserSortType', fromsubclass_=False):
        for SortExpression_ in self.SortExpression:
            showIndent(outfile, level)
            outfile.write('<%sSortExpression>%s</%sSortExpression>\n' % (namespace_, self.gds_format_string(quote_xml(SortExpression_).encode(ExternalEncoding), input_name='SortExpression'), namespace_))
        for SortExpressionScope_ in self.SortExpressionScope:
            showIndent(outfile, level)
            outfile.write('<%sSortExpressionScope>%s</%sSortExpressionScope>\n' % (namespace_, self.gds_format_string(quote_xml(SortExpressionScope_).encode(ExternalEncoding), input_name='SortExpressionScope'), namespace_))
        for SortTarget_ in self.SortTarget:
            showIndent(outfile, level)
            outfile.write('<%sSortTarget>%s</%sSortTarget>\n' % (namespace_, self.gds_format_string(quote_xml(SortTarget_).encode(ExternalEncoding), input_name='SortTarget'), namespace_))
    def hasContent_(self):
        if (
            self.SortExpression or
            self.SortExpressionScope or
            self.SortTarget
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='UserSortType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SortExpression=[\n')
        level += 1
        for SortExpression_ in self.SortExpression:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SortExpression_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressionScope=[\n')
        level += 1
        for SortExpressionScope_ in self.SortExpressionScope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SortExpressionScope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortTarget=[\n')
        level += 1
        for SortTarget_ in self.SortTarget:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SortTarget_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SortExpression':
            SortExpression_ = child_.text
            SortExpression_ = self.gds_validate_string(SortExpression_, node, 'SortExpression')
            self.SortExpression.append(SortExpression_)
        elif nodeName_ == 'SortExpressionScope':
            SortExpressionScope_ = child_.text
            SortExpressionScope_ = self.gds_validate_string(SortExpressionScope_, node, 'SortExpressionScope')
            self.SortExpressionScope.append(SortExpressionScope_)
        elif nodeName_ == 'SortTarget':
            SortTarget_ = child_.text
            SortTarget_ = self.gds_validate_string(SortTarget_, node, 'SortTarget')
            self.SortTarget.append(SortTarget_)
# end class UserSortType


class StringLocIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if StringLocIDType.subclass:
            return StringLocIDType.subclass(*args_, **kwargs_)
        else:
            return StringLocIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='StringLocIDType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StringLocIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StringLocIDType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StringLocIDType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StringLocIDType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringLocIDType


class LocIDStringWithDataTypeAttribute(StringWithDataTypeAttribute):
    subclass = None
    superclass = StringWithDataTypeAttribute
    def __init__(self, DataType=None, EvaluationMode='Auto', valueOf_=None):
        super(LocIDStringWithDataTypeAttribute, self).__init__(DataType, valueOf_, )
        self.EvaluationMode = _cast(None, EvaluationMode)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LocIDStringWithDataTypeAttribute.subclass:
            return LocIDStringWithDataTypeAttribute.subclass(*args_, **kwargs_)
        else:
            return LocIDStringWithDataTypeAttribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EvaluationMode(self): return self.EvaluationMode
    def set_EvaluationMode(self, EvaluationMode): self.EvaluationMode = EvaluationMode
    def validate_EvaluationModeType(self, value):
        # Validate type EvaluationModeType, a restriction on xsd:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LocIDStringWithDataTypeAttribute', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocIDStringWithDataTypeAttribute')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocIDStringWithDataTypeAttribute'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(LocIDStringWithDataTypeAttribute, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LocIDStringWithDataTypeAttribute')
        if self.EvaluationMode is not None and 'EvaluationMode' not in already_processed:
            already_processed.append('EvaluationMode')
            outfile.write(' EvaluationMode=%s' % (quote_attrib(self.EvaluationMode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LocIDStringWithDataTypeAttribute', fromsubclass_=False):
        super(LocIDStringWithDataTypeAttribute, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LocIDStringWithDataTypeAttribute, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocIDStringWithDataTypeAttribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EvaluationMode is not None and 'EvaluationMode' not in already_processed:
            already_processed.append('EvaluationMode')
            showIndent(outfile, level)
            outfile.write('EvaluationMode = "%s",\n' % (self.EvaluationMode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(LocIDStringWithDataTypeAttribute, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LocIDStringWithDataTypeAttribute, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EvaluationMode', node)
        if value is not None and 'EvaluationMode' not in already_processed:
            already_processed.append('EvaluationMode')
            self.EvaluationMode = value
            self.validate_EvaluationModeType(self.EvaluationMode)    # validate type EvaluationModeType
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(LocIDStringWithDataTypeAttribute, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocIDStringWithDataTypeAttribute


class CustomPropertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomProperty=None):
        if CustomProperty is None:
            self.CustomProperty = []
        else:
            self.CustomProperty = CustomProperty
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CustomPropertiesType.subclass:
            return CustomPropertiesType.subclass(*args_, **kwargs_)
        else:
            return CustomPropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomProperty(self): return self.CustomProperty
    def set_CustomProperty(self, CustomProperty): self.CustomProperty = CustomProperty
    def add_CustomProperty(self, value): self.CustomProperty.append(value)
    def insert_CustomProperty(self, index, value): self.CustomProperty[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CustomPropertiesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomPropertiesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomPropertiesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomPropertiesType', fromsubclass_=False):
        for CustomProperty_ in self.CustomProperty:
            CustomProperty_.export(outfile, level, namespace_, name_='CustomProperty')
    def hasContent_(self):
        if (
            self.CustomProperty
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomPropertiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CustomProperty=[\n')
        level += 1
        for CustomProperty_ in self.CustomProperty:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertyType(\n')
            CustomProperty_.exportLiteral(outfile, level, name_='CustomPropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomProperty':
            obj_ = CustomPropertyType.factory()
            obj_.build(child_)
            self.CustomProperty.append(obj_)
# end class CustomPropertiesType


class CustomPropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Value=None):
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CustomPropertyType.subclass:
            return CustomPropertyType.subclass(*args_, **kwargs_)
        else:
            return CustomPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name(self, index, value): self.Name[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CustomPropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomPropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomPropertyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomPropertyType', fromsubclass_=False):
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('<%sName>%s</%sName>\n' % (namespace_, self.gds_format_string(quote_xml(Name_).encode(ExternalEncoding), input_name='Name'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Name or
            self.Value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomPropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name.append(Name_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class CustomPropertyType


class TablixType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, TablixCorner=None, TablixBody=None, TablixColumnHierarchy=None, TablixRowHierarchy=None, LayoutDirection=None, GroupsBeforeRowHeaders=None, RepeatColumnHeaders=None, RepeatRowHeaders=None, FixedColumnHeaders=None, FixedRowHeaders=None, Style=None, SortExpressions=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, PageBreak=None, KeepTogether=None, NoRowsMessage=None, DataSetName=None, Filters=None, DataElementName=None, OmitBorderOnPageBreak=None, DataElementOutput=None):
        self.Name = _cast(None, Name)
        if TablixCorner is None:
            self.TablixCorner = []
        else:
            self.TablixCorner = TablixCorner
        if TablixBody is None:
            self.TablixBody = []
        else:
            self.TablixBody = TablixBody
        if TablixColumnHierarchy is None:
            self.TablixColumnHierarchy = []
        else:
            self.TablixColumnHierarchy = TablixColumnHierarchy
        if TablixRowHierarchy is None:
            self.TablixRowHierarchy = []
        else:
            self.TablixRowHierarchy = TablixRowHierarchy
        if LayoutDirection is None:
            self.LayoutDirection = []
        else:
            self.LayoutDirection = LayoutDirection
        if GroupsBeforeRowHeaders is None:
            self.GroupsBeforeRowHeaders = []
        else:
            self.GroupsBeforeRowHeaders = GroupsBeforeRowHeaders
        if RepeatColumnHeaders is None:
            self.RepeatColumnHeaders = []
        else:
            self.RepeatColumnHeaders = RepeatColumnHeaders
        if RepeatRowHeaders is None:
            self.RepeatRowHeaders = []
        else:
            self.RepeatRowHeaders = RepeatRowHeaders
        if FixedColumnHeaders is None:
            self.FixedColumnHeaders = []
        else:
            self.FixedColumnHeaders = FixedColumnHeaders
        if FixedRowHeaders is None:
            self.FixedRowHeaders = []
        else:
            self.FixedRowHeaders = FixedRowHeaders
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if SortExpressions is None:
            self.SortExpressions = []
        else:
            self.SortExpressions = SortExpressions
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if PageBreak is None:
            self.PageBreak = []
        else:
            self.PageBreak = PageBreak
        if KeepTogether is None:
            self.KeepTogether = []
        else:
            self.KeepTogether = KeepTogether
        if NoRowsMessage is None:
            self.NoRowsMessage = []
        else:
            self.NoRowsMessage = NoRowsMessage
        if DataSetName is None:
            self.DataSetName = []
        else:
            self.DataSetName = DataSetName
        if Filters is None:
            self.Filters = []
        else:
            self.Filters = Filters
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if OmitBorderOnPageBreak is None:
            self.OmitBorderOnPageBreak = []
        else:
            self.OmitBorderOnPageBreak = OmitBorderOnPageBreak
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixType.subclass:
            return TablixType.subclass(*args_, **kwargs_)
        else:
            return TablixType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixCorner(self): return self.TablixCorner
    def set_TablixCorner(self, TablixCorner): self.TablixCorner = TablixCorner
    def add_TablixCorner(self, value): self.TablixCorner.append(value)
    def insert_TablixCorner(self, index, value): self.TablixCorner[index] = value
    def get_TablixBody(self): return self.TablixBody
    def set_TablixBody(self, TablixBody): self.TablixBody = TablixBody
    def add_TablixBody(self, value): self.TablixBody.append(value)
    def insert_TablixBody(self, index, value): self.TablixBody[index] = value
    def get_TablixColumnHierarchy(self): return self.TablixColumnHierarchy
    def set_TablixColumnHierarchy(self, TablixColumnHierarchy): self.TablixColumnHierarchy = TablixColumnHierarchy
    def add_TablixColumnHierarchy(self, value): self.TablixColumnHierarchy.append(value)
    def insert_TablixColumnHierarchy(self, index, value): self.TablixColumnHierarchy[index] = value
    def get_TablixRowHierarchy(self): return self.TablixRowHierarchy
    def set_TablixRowHierarchy(self, TablixRowHierarchy): self.TablixRowHierarchy = TablixRowHierarchy
    def add_TablixRowHierarchy(self, value): self.TablixRowHierarchy.append(value)
    def insert_TablixRowHierarchy(self, index, value): self.TablixRowHierarchy[index] = value
    def get_LayoutDirection(self): return self.LayoutDirection
    def set_LayoutDirection(self, LayoutDirection): self.LayoutDirection = LayoutDirection
    def add_LayoutDirection(self, value): self.LayoutDirection.append(value)
    def insert_LayoutDirection(self, index, value): self.LayoutDirection[index] = value
    def get_GroupsBeforeRowHeaders(self): return self.GroupsBeforeRowHeaders
    def set_GroupsBeforeRowHeaders(self, GroupsBeforeRowHeaders): self.GroupsBeforeRowHeaders = GroupsBeforeRowHeaders
    def add_GroupsBeforeRowHeaders(self, value): self.GroupsBeforeRowHeaders.append(value)
    def insert_GroupsBeforeRowHeaders(self, index, value): self.GroupsBeforeRowHeaders[index] = value
    def get_RepeatColumnHeaders(self): return self.RepeatColumnHeaders
    def set_RepeatColumnHeaders(self, RepeatColumnHeaders): self.RepeatColumnHeaders = RepeatColumnHeaders
    def add_RepeatColumnHeaders(self, value): self.RepeatColumnHeaders.append(value)
    def insert_RepeatColumnHeaders(self, index, value): self.RepeatColumnHeaders[index] = value
    def get_RepeatRowHeaders(self): return self.RepeatRowHeaders
    def set_RepeatRowHeaders(self, RepeatRowHeaders): self.RepeatRowHeaders = RepeatRowHeaders
    def add_RepeatRowHeaders(self, value): self.RepeatRowHeaders.append(value)
    def insert_RepeatRowHeaders(self, index, value): self.RepeatRowHeaders[index] = value
    def get_FixedColumnHeaders(self): return self.FixedColumnHeaders
    def set_FixedColumnHeaders(self, FixedColumnHeaders): self.FixedColumnHeaders = FixedColumnHeaders
    def add_FixedColumnHeaders(self, value): self.FixedColumnHeaders.append(value)
    def insert_FixedColumnHeaders(self, index, value): self.FixedColumnHeaders[index] = value
    def get_FixedRowHeaders(self): return self.FixedRowHeaders
    def set_FixedRowHeaders(self, FixedRowHeaders): self.FixedRowHeaders = FixedRowHeaders
    def add_FixedRowHeaders(self, value): self.FixedRowHeaders.append(value)
    def insert_FixedRowHeaders(self, index, value): self.FixedRowHeaders[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def add_SortExpressions(self, value): self.SortExpressions.append(value)
    def insert_SortExpressions(self, index, value): self.SortExpressions[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_PageBreak(self): return self.PageBreak
    def set_PageBreak(self, PageBreak): self.PageBreak = PageBreak
    def add_PageBreak(self, value): self.PageBreak.append(value)
    def insert_PageBreak(self, index, value): self.PageBreak[index] = value
    def get_KeepTogether(self): return self.KeepTogether
    def set_KeepTogether(self, KeepTogether): self.KeepTogether = KeepTogether
    def add_KeepTogether(self, value): self.KeepTogether.append(value)
    def insert_KeepTogether(self, index, value): self.KeepTogether[index] = value
    def get_NoRowsMessage(self): return self.NoRowsMessage
    def set_NoRowsMessage(self, NoRowsMessage): self.NoRowsMessage = NoRowsMessage
    def add_NoRowsMessage(self, value): self.NoRowsMessage.append(value)
    def insert_NoRowsMessage(self, index, value): self.NoRowsMessage[index] = value
    def get_DataSetName(self): return self.DataSetName
    def set_DataSetName(self, DataSetName): self.DataSetName = DataSetName
    def add_DataSetName(self, value): self.DataSetName.append(value)
    def insert_DataSetName(self, index, value): self.DataSetName[index] = value
    def get_Filters(self): return self.Filters
    def set_Filters(self, Filters): self.Filters = Filters
    def add_Filters(self, value): self.Filters.append(value)
    def insert_Filters(self, index, value): self.Filters[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_OmitBorderOnPageBreak(self): return self.OmitBorderOnPageBreak
    def set_OmitBorderOnPageBreak(self, OmitBorderOnPageBreak): self.OmitBorderOnPageBreak = OmitBorderOnPageBreak
    def add_OmitBorderOnPageBreak(self, value): self.OmitBorderOnPageBreak.append(value)
    def insert_OmitBorderOnPageBreak(self, index, value): self.OmitBorderOnPageBreak[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TablixType', fromsubclass_=False):
        for TablixCorner_ in self.TablixCorner:
            TablixCorner_.export(outfile, level, namespace_, name_='TablixCorner')
        for TablixBody_ in self.TablixBody:
            TablixBody_.export(outfile, level, namespace_, name_='TablixBody')
        for TablixColumnHierarchy_ in self.TablixColumnHierarchy:
            TablixColumnHierarchy_.export(outfile, level, namespace_, name_='TablixColumnHierarchy')
        for TablixRowHierarchy_ in self.TablixRowHierarchy:
            TablixRowHierarchy_.export(outfile, level, namespace_, name_='TablixRowHierarchy')
        for LayoutDirection_ in self.LayoutDirection:
            showIndent(outfile, level)
            outfile.write('<%sLayoutDirection>%s</%sLayoutDirection>\n' % (namespace_, self.gds_format_string(quote_xml(LayoutDirection_).encode(ExternalEncoding), input_name='LayoutDirection'), namespace_))
        for GroupsBeforeRowHeaders_ in self.GroupsBeforeRowHeaders:
            showIndent(outfile, level)
            outfile.write('<%sGroupsBeforeRowHeaders>%s</%sGroupsBeforeRowHeaders>\n' % (namespace_, self.gds_format_integer(GroupsBeforeRowHeaders_, input_name='GroupsBeforeRowHeaders'), namespace_))
        for RepeatColumnHeaders_ in self.RepeatColumnHeaders:
            showIndent(outfile, level)
            outfile.write('<%sRepeatColumnHeaders>%s</%sRepeatColumnHeaders>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(RepeatColumnHeaders_)), input_name='RepeatColumnHeaders'), namespace_))
        for RepeatRowHeaders_ in self.RepeatRowHeaders:
            showIndent(outfile, level)
            outfile.write('<%sRepeatRowHeaders>%s</%sRepeatRowHeaders>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(RepeatRowHeaders_)), input_name='RepeatRowHeaders'), namespace_))
        for FixedColumnHeaders_ in self.FixedColumnHeaders:
            showIndent(outfile, level)
            outfile.write('<%sFixedColumnHeaders>%s</%sFixedColumnHeaders>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(FixedColumnHeaders_)), input_name='FixedColumnHeaders'), namespace_))
        for FixedRowHeaders_ in self.FixedRowHeaders:
            showIndent(outfile, level)
            outfile.write('<%sFixedRowHeaders>%s</%sFixedRowHeaders>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(FixedRowHeaders_)), input_name='FixedRowHeaders'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for SortExpressions_ in self.SortExpressions:
            SortExpressions_.export(outfile, level, namespace_, name_='SortExpressions')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for PageBreak_ in self.PageBreak:
            PageBreak_.export(outfile, level, namespace_, name_='PageBreak')
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('<%sKeepTogether>%s</%sKeepTogether>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(KeepTogether_)), input_name='KeepTogether'), namespace_))
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('<%sNoRowsMessage>%s</%sNoRowsMessage>\n' % (namespace_, self.gds_format_string(quote_xml(NoRowsMessage_).encode(ExternalEncoding), input_name='NoRowsMessage'), namespace_))
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('<%sDataSetName>%s</%sDataSetName>\n' % (namespace_, self.gds_format_string(quote_xml(DataSetName_).encode(ExternalEncoding), input_name='DataSetName'), namespace_))
        for Filters_ in self.Filters:
            Filters_.export(outfile, level, namespace_, name_='Filters')
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for OmitBorderOnPageBreak_ in self.OmitBorderOnPageBreak:
            showIndent(outfile, level)
            outfile.write('<%sOmitBorderOnPageBreak>%s</%sOmitBorderOnPageBreak>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(OmitBorderOnPageBreak_)), input_name='OmitBorderOnPageBreak'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.TablixCorner or
            self.TablixBody or
            self.TablixColumnHierarchy or
            self.TablixRowHierarchy or
            self.LayoutDirection or
            self.GroupsBeforeRowHeaders or
            self.RepeatColumnHeaders or
            self.RepeatRowHeaders or
            self.FixedColumnHeaders or
            self.FixedRowHeaders or
            self.Style or
            self.SortExpressions or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.PageBreak or
            self.KeepTogether or
            self.NoRowsMessage or
            self.DataSetName or
            self.Filters or
            self.DataElementName or
            self.OmitBorderOnPageBreak or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixCorner=[\n')
        level += 1
        for TablixCorner_ in self.TablixCorner:
            showIndent(outfile, level)
            outfile.write('model_.TablixCornerType(\n')
            TablixCorner_.exportLiteral(outfile, level, name_='TablixCornerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TablixBody=[\n')
        level += 1
        for TablixBody_ in self.TablixBody:
            showIndent(outfile, level)
            outfile.write('model_.TablixBodyType(\n')
            TablixBody_.exportLiteral(outfile, level, name_='TablixBodyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TablixColumnHierarchy=[\n')
        level += 1
        for TablixColumnHierarchy_ in self.TablixColumnHierarchy:
            showIndent(outfile, level)
            outfile.write('model_.TablixHierarchyType(\n')
            TablixColumnHierarchy_.exportLiteral(outfile, level, name_='TablixHierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TablixRowHierarchy=[\n')
        level += 1
        for TablixRowHierarchy_ in self.TablixRowHierarchy:
            showIndent(outfile, level)
            outfile.write('model_.TablixHierarchyType(\n')
            TablixRowHierarchy_.exportLiteral(outfile, level, name_='TablixHierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LayoutDirection=[\n')
        level += 1
        for LayoutDirection_ in self.LayoutDirection:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LayoutDirection_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GroupsBeforeRowHeaders=[\n')
        level += 1
        for GroupsBeforeRowHeaders_ in self.GroupsBeforeRowHeaders:
            showIndent(outfile, level)
            outfile.write('%d,\n' % GroupsBeforeRowHeaders)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatColumnHeaders=[\n')
        level += 1
        for RepeatColumnHeaders_ in self.RepeatColumnHeaders:
            showIndent(outfile, level)
            outfile.write('%s,\n' % RepeatColumnHeaders)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatRowHeaders=[\n')
        level += 1
        for RepeatRowHeaders_ in self.RepeatRowHeaders:
            showIndent(outfile, level)
            outfile.write('%s,\n' % RepeatRowHeaders)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FixedColumnHeaders=[\n')
        level += 1
        for FixedColumnHeaders_ in self.FixedColumnHeaders:
            showIndent(outfile, level)
            outfile.write('%s,\n' % FixedColumnHeaders)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FixedRowHeaders=[\n')
        level += 1
        for FixedRowHeaders_ in self.FixedRowHeaders:
            showIndent(outfile, level)
            outfile.write('%s,\n' % FixedRowHeaders)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressions=[\n')
        level += 1
        for SortExpressions_ in self.SortExpressions:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionsType(\n')
            SortExpressions_.exportLiteral(outfile, level, name_='SortExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageBreak=[\n')
        level += 1
        for PageBreak_ in self.PageBreak:
            showIndent(outfile, level)
            outfile.write('model_.PageBreakType(\n')
            PageBreak_.exportLiteral(outfile, level, name_='PageBreakType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeepTogether=[\n')
        level += 1
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('%s,\n' % KeepTogether)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NoRowsMessage=[\n')
        level += 1
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NoRowsMessage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSetName=[\n')
        level += 1
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSetName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Filters=[\n')
        level += 1
        for Filters_ in self.Filters:
            showIndent(outfile, level)
            outfile.write('model_.FiltersType(\n')
            Filters_.exportLiteral(outfile, level, name_='FiltersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OmitBorderOnPageBreak=[\n')
        level += 1
        for OmitBorderOnPageBreak_ in self.OmitBorderOnPageBreak:
            showIndent(outfile, level)
            outfile.write('%s,\n' % OmitBorderOnPageBreak)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixCorner':
            obj_ = TablixCornerType.factory()
            obj_.build(child_)
            self.TablixCorner.append(obj_)
        elif nodeName_ == 'TablixBody':
            obj_ = TablixBodyType.factory()
            obj_.build(child_)
            self.TablixBody.append(obj_)
        elif nodeName_ == 'TablixColumnHierarchy':
            obj_ = TablixHierarchyType.factory()
            obj_.build(child_)
            self.TablixColumnHierarchy.append(obj_)
        elif nodeName_ == 'TablixRowHierarchy':
            obj_ = TablixHierarchyType.factory()
            obj_.build(child_)
            self.TablixRowHierarchy.append(obj_)
        elif nodeName_ == 'LayoutDirection':
            LayoutDirection_ = child_.text
            LayoutDirection_ = self.gds_validate_string(LayoutDirection_, node, 'LayoutDirection')
            self.LayoutDirection.append(LayoutDirection_)
        elif nodeName_ == 'GroupsBeforeRowHeaders':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'GroupsBeforeRowHeaders')
            self.GroupsBeforeRowHeaders.append(ival_)
        elif nodeName_ == 'RepeatColumnHeaders':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RepeatColumnHeaders')
            self.RepeatColumnHeaders.append(ival_)
        elif nodeName_ == 'RepeatRowHeaders':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RepeatRowHeaders')
            self.RepeatRowHeaders.append(ival_)
        elif nodeName_ == 'FixedColumnHeaders':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'FixedColumnHeaders')
            self.FixedColumnHeaders.append(ival_)
        elif nodeName_ == 'FixedRowHeaders':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'FixedRowHeaders')
            self.FixedRowHeaders.append(ival_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.SortExpressions.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'PageBreak':
            obj_ = PageBreakType.factory()
            obj_.build(child_)
            self.PageBreak.append(obj_)
        elif nodeName_ == 'KeepTogether':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KeepTogether')
            self.KeepTogether.append(ival_)
        elif nodeName_ == 'NoRowsMessage':
            NoRowsMessage_ = child_.text
            NoRowsMessage_ = self.gds_validate_string(NoRowsMessage_, node, 'NoRowsMessage')
            self.NoRowsMessage.append(NoRowsMessage_)
        elif nodeName_ == 'DataSetName':
            DataSetName_ = child_.text
            DataSetName_ = self.gds_validate_string(DataSetName_, node, 'DataSetName')
            self.DataSetName.append(DataSetName_)
        elif nodeName_ == 'Filters':
            obj_ = FiltersType.factory()
            obj_.build(child_)
            self.Filters.append(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'OmitBorderOnPageBreak':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'OmitBorderOnPageBreak')
            self.OmitBorderOnPageBreak.append(ival_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class TablixType


class LayoutDirection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if LayoutDirection.subclass:
            return LayoutDirection.subclass(*args_, **kwargs_)
        else:
            return LayoutDirection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='LayoutDirection', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LayoutDirection')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LayoutDirection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LayoutDirection', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LayoutDirection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LayoutDirection


class TablixBodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixColumns=None, TablixRows=None):
        self.TablixColumns = TablixColumns
        self.TablixRows = TablixRows
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixBodyType.subclass:
            return TablixBodyType.subclass(*args_, **kwargs_)
        else:
            return TablixBodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixColumns(self): return self.TablixColumns
    def set_TablixColumns(self, TablixColumns): self.TablixColumns = TablixColumns
    def get_TablixRows(self): return self.TablixRows
    def set_TablixRows(self, TablixRows): self.TablixRows = TablixRows
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixBodyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixBodyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixBodyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixBodyType', fromsubclass_=False):
        if self.TablixColumns:
            self.TablixColumns.export(outfile, level, namespace_, name_='TablixColumns', )
        if self.TablixRows:
            self.TablixRows.export(outfile, level, namespace_, name_='TablixRows', )
    def hasContent_(self):
        if (
            self.TablixColumns is not None or
            self.TablixRows is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixBodyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TablixColumns is not None:
            showIndent(outfile, level)
            outfile.write('TablixColumns=model_.TablixColumnsType(\n')
            self.TablixColumns.exportLiteral(outfile, level, name_='TablixColumns')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TablixRows is not None:
            showIndent(outfile, level)
            outfile.write('TablixRows=model_.TablixRowsType(\n')
            self.TablixRows.exportLiteral(outfile, level, name_='TablixRows')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixColumns':
            obj_ = TablixColumnsType.factory()
            obj_.build(child_)
            self.set_TablixColumns(obj_)
        elif nodeName_ == 'TablixRows':
            obj_ = TablixRowsType.factory()
            obj_.build(child_)
            self.set_TablixRows(obj_)
# end class TablixBodyType


class TablixCornerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixCornerRows=None):
        self.TablixCornerRows = TablixCornerRows
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixCornerType.subclass:
            return TablixCornerType.subclass(*args_, **kwargs_)
        else:
            return TablixCornerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixCornerRows(self): return self.TablixCornerRows
    def set_TablixCornerRows(self, TablixCornerRows): self.TablixCornerRows = TablixCornerRows
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixCornerType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixCornerType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixCornerType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixCornerType', fromsubclass_=False):
        if self.TablixCornerRows:
            self.TablixCornerRows.export(outfile, level, namespace_, name_='TablixCornerRows', )
    def hasContent_(self):
        if (
            self.TablixCornerRows is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixCornerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TablixCornerRows is not None:
            showIndent(outfile, level)
            outfile.write('TablixCornerRows=model_.TablixCornerRowsType(\n')
            self.TablixCornerRows.exportLiteral(outfile, level, name_='TablixCornerRows')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixCornerRows':
            obj_ = TablixCornerRowsType.factory()
            obj_.build(child_)
            self.set_TablixCornerRows(obj_)
# end class TablixCornerType


class TablixCornerRowsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixCornerRow=None):
        if TablixCornerRow is None:
            self.TablixCornerRow = []
        else:
            self.TablixCornerRow = TablixCornerRow
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixCornerRowsType.subclass:
            return TablixCornerRowsType.subclass(*args_, **kwargs_)
        else:
            return TablixCornerRowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixCornerRow(self): return self.TablixCornerRow
    def set_TablixCornerRow(self, TablixCornerRow): self.TablixCornerRow = TablixCornerRow
    def add_TablixCornerRow(self, value): self.TablixCornerRow.append(value)
    def insert_TablixCornerRow(self, index, value): self.TablixCornerRow[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixCornerRowsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixCornerRowsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixCornerRowsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixCornerRowsType', fromsubclass_=False):
        for TablixCornerRow_ in self.TablixCornerRow:
            TablixCornerRow_.export(outfile, level, namespace_, name_='TablixCornerRow')
    def hasContent_(self):
        if (
            self.TablixCornerRow
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixCornerRowsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixCornerRow=[\n')
        level += 1
        for TablixCornerRow_ in self.TablixCornerRow:
            showIndent(outfile, level)
            outfile.write('model_.TablixCornerRowType(\n')
            TablixCornerRow_.exportLiteral(outfile, level, name_='TablixCornerRowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixCornerRow':
            obj_ = TablixCornerRowType.factory()
            obj_.build(child_)
            self.TablixCornerRow.append(obj_)
# end class TablixCornerRowsType


class TablixCornerRowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixCornerCell=None):
        if TablixCornerCell is None:
            self.TablixCornerCell = []
        else:
            self.TablixCornerCell = TablixCornerCell
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixCornerRowType.subclass:
            return TablixCornerRowType.subclass(*args_, **kwargs_)
        else:
            return TablixCornerRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixCornerCell(self): return self.TablixCornerCell
    def set_TablixCornerCell(self, TablixCornerCell): self.TablixCornerCell = TablixCornerCell
    def add_TablixCornerCell(self, value): self.TablixCornerCell.append(value)
    def insert_TablixCornerCell(self, index, value): self.TablixCornerCell[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixCornerRowType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixCornerRowType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixCornerRowType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixCornerRowType', fromsubclass_=False):
        for TablixCornerCell_ in self.TablixCornerCell:
            TablixCornerCell_.export(outfile, level, namespace_, name_='TablixCornerCell')
    def hasContent_(self):
        if (
            self.TablixCornerCell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixCornerRowType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixCornerCell=[\n')
        level += 1
        for TablixCornerCell_ in self.TablixCornerCell:
            showIndent(outfile, level)
            outfile.write('model_.TablixCornerCellType(\n')
            TablixCornerCell_.exportLiteral(outfile, level, name_='TablixCornerCellType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixCornerCell':
            obj_ = TablixCornerCellType.factory()
            obj_.build(child_)
            self.TablixCornerCell.append(obj_)
# end class TablixCornerRowType


class TablixCornerCellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CellContents=None):
        self.CellContents = CellContents
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixCornerCellType.subclass:
            return TablixCornerCellType.subclass(*args_, **kwargs_)
        else:
            return TablixCornerCellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellContents(self): return self.CellContents
    def set_CellContents(self, CellContents): self.CellContents = CellContents
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixCornerCellType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixCornerCellType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixCornerCellType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixCornerCellType', fromsubclass_=False):
        if self.CellContents:
            self.CellContents.export(outfile, level, namespace_, name_='CellContents')
    def hasContent_(self):
        if (
            self.CellContents is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixCornerCellType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CellContents is not None:
            showIndent(outfile, level)
            outfile.write('CellContents=model_.CellContentsType(\n')
            self.CellContents.exportLiteral(outfile, level, name_='CellContents')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellContents':
            obj_ = CellContentsType.factory()
            obj_.build(child_)
            self.set_CellContents(obj_)
# end class TablixCornerCellType


class TablixHierarchyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixMembers=None):
        self.TablixMembers = TablixMembers
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixHierarchyType.subclass:
            return TablixHierarchyType.subclass(*args_, **kwargs_)
        else:
            return TablixHierarchyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixMembers(self): return self.TablixMembers
    def set_TablixMembers(self, TablixMembers): self.TablixMembers = TablixMembers
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixHierarchyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixHierarchyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixHierarchyType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixHierarchyType', fromsubclass_=False):
        if self.TablixMembers:
            self.TablixMembers.export(outfile, level, namespace_, name_='TablixMembers', )
    def hasContent_(self):
        if (
            self.TablixMembers is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixHierarchyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TablixMembers is not None:
            showIndent(outfile, level)
            outfile.write('TablixMembers=model_.TablixMembersType(\n')
            self.TablixMembers.exportLiteral(outfile, level, name_='TablixMembers')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixMembers':
            obj_ = TablixMembersType.factory()
            obj_.build(child_)
            self.set_TablixMembers(obj_)
# end class TablixHierarchyType


class TablixMembersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixMember=None):
        if TablixMember is None:
            self.TablixMember = []
        else:
            self.TablixMember = TablixMember
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixMembersType.subclass:
            return TablixMembersType.subclass(*args_, **kwargs_)
        else:
            return TablixMembersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixMember(self): return self.TablixMember
    def set_TablixMember(self, TablixMember): self.TablixMember = TablixMember
    def add_TablixMember(self, value): self.TablixMember.append(value)
    def insert_TablixMember(self, index, value): self.TablixMember[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixMembersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixMembersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixMembersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixMembersType', fromsubclass_=False):
        for TablixMember_ in self.TablixMember:
            TablixMember_.export(outfile, level, namespace_, name_='TablixMember')
    def hasContent_(self):
        if (
            self.TablixMember
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixMembersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixMember=[\n')
        level += 1
        for TablixMember_ in self.TablixMember:
            showIndent(outfile, level)
            outfile.write('model_.TablixMemberType(\n')
            TablixMember_.exportLiteral(outfile, level, name_='TablixMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixMember':
            obj_ = TablixMemberType.factory()
            obj_.build(child_)
            self.TablixMember.append(obj_)
# end class TablixMembersType


class TablixMemberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None, SortExpressions=None, TablixHeader=None, TablixMembers=None, CustomProperties=None, FixedData=None, Visibility=None, HideIfNoRows=None, RepeatOnNewPage=None, KeepWithGroup=None, DataElementName=None, DataElementOutput=None, KeepTogether=None):
        self.Group = Group
        self.SortExpressions = SortExpressions
        self.TablixHeader = TablixHeader
        self.TablixMembers = TablixMembers
        self.CustomProperties = CustomProperties
        self.FixedData = FixedData
        self.Visibility = Visibility
        if HideIfNoRows is None:
            self.HideIfNoRows = []
        else:
            self.HideIfNoRows = HideIfNoRows
        if RepeatOnNewPage is None:
            self.RepeatOnNewPage = []
        else:
            self.RepeatOnNewPage = RepeatOnNewPage
        self.KeepWithGroup = KeepWithGroup
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        if KeepTogether is None:
            self.KeepTogether = []
        else:
            self.KeepTogether = KeepTogether
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixMemberType.subclass:
            return TablixMemberType.subclass(*args_, **kwargs_)
        else:
            return TablixMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def get_TablixHeader(self): return self.TablixHeader
    def set_TablixHeader(self, TablixHeader): self.TablixHeader = TablixHeader
    def get_TablixMembers(self): return self.TablixMembers
    def set_TablixMembers(self, TablixMembers): self.TablixMembers = TablixMembers
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def get_FixedData(self): return self.FixedData
    def set_FixedData(self, FixedData): self.FixedData = FixedData
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def get_HideIfNoRows(self): return self.HideIfNoRows
    def set_HideIfNoRows(self, HideIfNoRows): self.HideIfNoRows = HideIfNoRows
    def add_HideIfNoRows(self, value): self.HideIfNoRows.append(value)
    def insert_HideIfNoRows(self, index, value): self.HideIfNoRows[index] = value
    def get_RepeatOnNewPage(self): return self.RepeatOnNewPage
    def set_RepeatOnNewPage(self, RepeatOnNewPage): self.RepeatOnNewPage = RepeatOnNewPage
    def add_RepeatOnNewPage(self, value): self.RepeatOnNewPage.append(value)
    def insert_RepeatOnNewPage(self, index, value): self.RepeatOnNewPage[index] = value
    def get_KeepWithGroup(self): return self.KeepWithGroup
    def set_KeepWithGroup(self, KeepWithGroup): self.KeepWithGroup = KeepWithGroup
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_KeepTogether(self): return self.KeepTogether
    def set_KeepTogether(self, KeepTogether): self.KeepTogether = KeepTogether
    def add_KeepTogether(self, value): self.KeepTogether.append(value)
    def insert_KeepTogether(self, index, value): self.KeepTogether[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixMemberType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixMemberType', fromsubclass_=False):
        if self.Group:
            self.Group.export(outfile, level, namespace_, name_='Group')
        if self.SortExpressions:
            self.SortExpressions.export(outfile, level, namespace_, name_='SortExpressions')
        if self.TablixHeader:
            self.TablixHeader.export(outfile, level, namespace_, name_='TablixHeader')
        if self.TablixMembers:
            self.TablixMembers.export(outfile, level, namespace_, name_='TablixMembers')
        if self.CustomProperties:
            self.CustomProperties.export(outfile, level, namespace_, name_='CustomProperties')
        if self.FixedData is not None:
            showIndent(outfile, level)
            outfile.write('<%sFixedData>%s</%sFixedData>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.FixedData)), input_name='FixedData'), namespace_))
        if self.Visibility:
            self.Visibility.export(outfile, level, namespace_, name_='Visibility')
        for HideIfNoRows_ in self.HideIfNoRows:
            showIndent(outfile, level)
            outfile.write('<%sHideIfNoRows>%s</%sHideIfNoRows>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(HideIfNoRows_)), input_name='HideIfNoRows'), namespace_))
        for RepeatOnNewPage_ in self.RepeatOnNewPage:
            showIndent(outfile, level)
            outfile.write('<%sRepeatOnNewPage>%s</%sRepeatOnNewPage>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(RepeatOnNewPage_)), input_name='RepeatOnNewPage'), namespace_))
        if self.KeepWithGroup is not None:
            showIndent(outfile, level)
            outfile.write('<%sKeepWithGroup>%s</%sKeepWithGroup>\n' % (namespace_, self.gds_format_string(quote_xml(self.KeepWithGroup).encode(ExternalEncoding), input_name='KeepWithGroup'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('<%sKeepTogether>%s</%sKeepTogether>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(KeepTogether_)), input_name='KeepTogether'), namespace_))
    def hasContent_(self):
        if (
            self.Group is not None or
            self.SortExpressions is not None or
            self.TablixHeader is not None or
            self.TablixMembers is not None or
            self.CustomProperties is not None or
            self.FixedData is not None or
            self.Visibility is not None or
            self.HideIfNoRows or
            self.RepeatOnNewPage or
            self.KeepWithGroup is not None or
            self.DataElementName or
            self.DataElementOutput or
            self.KeepTogether
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Group is not None:
            showIndent(outfile, level)
            outfile.write('Group=model_.GroupType(\n')
            self.Group.exportLiteral(outfile, level, name_='Group')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SortExpressions is not None:
            showIndent(outfile, level)
            outfile.write('SortExpressions=model_.SortExpressionsType(\n')
            self.SortExpressions.exportLiteral(outfile, level, name_='SortExpressions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TablixHeader is not None:
            showIndent(outfile, level)
            outfile.write('TablixHeader=model_.TablixHeaderType(\n')
            self.TablixHeader.exportLiteral(outfile, level, name_='TablixHeader')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TablixMembers is not None:
            showIndent(outfile, level)
            outfile.write('TablixMembers=model_.TablixMembersType(\n')
            self.TablixMembers.exportLiteral(outfile, level, name_='TablixMembers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CustomProperties is not None:
            showIndent(outfile, level)
            outfile.write('CustomProperties=model_.CustomPropertiesType(\n')
            self.CustomProperties.exportLiteral(outfile, level, name_='CustomProperties')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FixedData is not None:
            showIndent(outfile, level)
            outfile.write('FixedData=%s,\n' % self.FixedData)
        if self.Visibility is not None:
            showIndent(outfile, level)
            outfile.write('Visibility=model_.VisibilityType(\n')
            self.Visibility.exportLiteral(outfile, level, name_='Visibility')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('HideIfNoRows=[\n')
        level += 1
        for HideIfNoRows_ in self.HideIfNoRows:
            showIndent(outfile, level)
            outfile.write('%s,\n' % HideIfNoRows)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatOnNewPage=[\n')
        level += 1
        for RepeatOnNewPage_ in self.RepeatOnNewPage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % RepeatOnNewPage)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.KeepWithGroup is not None:
            showIndent(outfile, level)
            outfile.write('KeepWithGroup=%s,\n' % quote_python(self.KeepWithGroup).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeepTogether=[\n')
        level += 1
        for KeepTogether_ in self.KeepTogether:
            showIndent(outfile, level)
            outfile.write('%s,\n' % KeepTogether)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = GroupType.factory()
            obj_.build(child_)
            self.set_Group(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.set_SortExpressions(obj_)
        elif nodeName_ == 'TablixHeader':
            obj_ = TablixHeaderType.factory()
            obj_.build(child_)
            self.set_TablixHeader(obj_)
        elif nodeName_ == 'TablixMembers':
            obj_ = TablixMembersType.factory()
            obj_.build(child_)
            self.set_TablixMembers(obj_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.set_CustomProperties(obj_)
        elif nodeName_ == 'FixedData':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'FixedData')
            self.FixedData = ival_
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.set_Visibility(obj_)
        elif nodeName_ == 'HideIfNoRows':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HideIfNoRows')
            self.HideIfNoRows.append(ival_)
        elif nodeName_ == 'RepeatOnNewPage':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RepeatOnNewPage')
            self.RepeatOnNewPage.append(ival_)
        elif nodeName_ == 'KeepWithGroup':
            KeepWithGroup_ = child_.text
            KeepWithGroup_ = self.gds_validate_string(KeepWithGroup_, node, 'KeepWithGroup')
            self.KeepWithGroup = KeepWithGroup_
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
        elif nodeName_ == 'KeepTogether':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'KeepTogether')
            self.KeepTogether.append(ival_)
# end class TablixMemberType


class KeepWithGroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if KeepWithGroup.subclass:
            return KeepWithGroup.subclass(*args_, **kwargs_)
        else:
            return KeepWithGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='KeepWithGroup', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeepWithGroup')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeepWithGroup'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeepWithGroup', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeepWithGroup'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KeepWithGroup


class TablixHeaderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Size=None, CellContents=None):
        self.Size = Size
        self.CellContents = CellContents
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixHeaderType.subclass:
            return TablixHeaderType.subclass(*args_, **kwargs_)
        else:
            return TablixHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_CellContents(self): return self.CellContents
    def set_CellContents(self, CellContents): self.CellContents = CellContents
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixHeaderType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixHeaderType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixHeaderType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixHeaderType', fromsubclass_=False):
        if self.Size is not None:
            showIndent(outfile, level)
            outfile.write('<%sSize>%s</%sSize>\n' % (namespace_, self.gds_format_string(quote_xml(self.Size).encode(ExternalEncoding), input_name='Size'), namespace_))
        if self.CellContents:
            self.CellContents.export(outfile, level, namespace_, name_='CellContents', )
    def hasContent_(self):
        if (
            self.Size is not None or
            self.CellContents is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixHeaderType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Size is not None:
            showIndent(outfile, level)
            outfile.write('Size=%s,\n' % quote_python(self.Size).encode(ExternalEncoding))
        if self.CellContents is not None:
            showIndent(outfile, level)
            outfile.write('CellContents=model_.CellContentsType(\n')
            self.CellContents.exportLiteral(outfile, level, name_='CellContents')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Size':
            Size_ = child_.text
            Size_ = self.gds_validate_string(Size_, node, 'Size')
            self.Size = Size_
            self.validate_SizeType(self.Size)    # validate type SizeType
        elif nodeName_ == 'CellContents':
            obj_ = CellContentsType.factory()
            obj_.build(child_)
            self.set_CellContents(obj_)
# end class TablixHeaderType


class CellContentsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ColSpan=None, RowSpan=None, Line=None, Rectangle=None, Textbox=None, Image=None, Subreport=None, Chart=None, GaugePanel=None, CustomReportItem=None, Tablix=None):
        self.ColSpan = ColSpan
        self.RowSpan = RowSpan
        self.Line = Line
        self.Rectangle = Rectangle
        self.Textbox = Textbox
        self.Image = Image
        self.Subreport = Subreport
        self.Chart = Chart
        self.GaugePanel = GaugePanel
        self.CustomReportItem = CustomReportItem
        self.Tablix = Tablix
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CellContentsType.subclass:
            return CellContentsType.subclass(*args_, **kwargs_)
        else:
            return CellContentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ColSpan(self): return self.ColSpan
    def set_ColSpan(self, ColSpan): self.ColSpan = ColSpan
    def get_RowSpan(self): return self.RowSpan
    def set_RowSpan(self, RowSpan): self.RowSpan = RowSpan
    def get_Line(self): return self.Line
    def set_Line(self, Line): self.Line = Line
    def get_Rectangle(self): return self.Rectangle
    def set_Rectangle(self, Rectangle): self.Rectangle = Rectangle
    def get_Textbox(self): return self.Textbox
    def set_Textbox(self, Textbox): self.Textbox = Textbox
    def get_Image(self): return self.Image
    def set_Image(self, Image): self.Image = Image
    def get_Subreport(self): return self.Subreport
    def set_Subreport(self, Subreport): self.Subreport = Subreport
    def get_Chart(self): return self.Chart
    def set_Chart(self, Chart): self.Chart = Chart
    def get_GaugePanel(self): return self.GaugePanel
    def set_GaugePanel(self, GaugePanel): self.GaugePanel = GaugePanel
    def get_CustomReportItem(self): return self.CustomReportItem
    def set_CustomReportItem(self, CustomReportItem): self.CustomReportItem = CustomReportItem
    def get_Tablix(self): return self.Tablix
    def set_Tablix(self, Tablix): self.Tablix = Tablix
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CellContentsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CellContentsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CellContentsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CellContentsType', fromsubclass_=False):
        if self.ColSpan is not None:
            showIndent(outfile, level)
            outfile.write('<%sColSpan>%s</%sColSpan>\n' % (namespace_, self.gds_format_integer(self.ColSpan, input_name='ColSpan'), namespace_))
        if self.RowSpan is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowSpan>%s</%sRowSpan>\n' % (namespace_, self.gds_format_integer(self.RowSpan, input_name='RowSpan'), namespace_))
        if self.Line:
            self.Line.export(outfile, level, namespace_, name_='Line')
        if self.Rectangle:
            self.Rectangle.export(outfile, level, namespace_, name_='Rectangle')
        if self.Textbox:
            self.Textbox.export(outfile, level, namespace_, name_='Textbox')
        if self.Image:
            self.Image.export(outfile, level, namespace_, name_='Image')
        if self.Subreport:
            self.Subreport.export(outfile, level, namespace_, name_='Subreport')
        if self.Chart:
            self.Chart.export(outfile, level, namespace_, name_='Chart')
        if self.GaugePanel:
            self.GaugePanel.export(outfile, level, namespace_, name_='GaugePanel')
        if self.CustomReportItem:
            self.CustomReportItem.export(outfile, level, namespace_, name_='CustomReportItem')
        if self.Tablix:
            self.Tablix.export(outfile, level, namespace_, name_='Tablix')
    def hasContent_(self):
        if (
            self.ColSpan is not None or
            self.RowSpan is not None or
            self.Line is not None or
            self.Rectangle is not None or
            self.Textbox is not None or
            self.Image is not None or
            self.Subreport is not None or
            self.Chart is not None or
            self.GaugePanel is not None or
            self.CustomReportItem is not None or
            self.Tablix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CellContentsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ColSpan is not None:
            showIndent(outfile, level)
            outfile.write('ColSpan=%d,\n' % self.ColSpan)
        if self.RowSpan is not None:
            showIndent(outfile, level)
            outfile.write('RowSpan=%d,\n' % self.RowSpan)
        if self.Line is not None:
            showIndent(outfile, level)
            outfile.write('Line=model_.LineType(\n')
            self.Line.exportLiteral(outfile, level, name_='Line')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Rectangle is not None:
            showIndent(outfile, level)
            outfile.write('Rectangle=model_.RectangleType(\n')
            self.Rectangle.exportLiteral(outfile, level, name_='Rectangle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Textbox is not None:
            showIndent(outfile, level)
            outfile.write('Textbox=model_.TextboxType(\n')
            self.Textbox.exportLiteral(outfile, level, name_='Textbox')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Image is not None:
            showIndent(outfile, level)
            outfile.write('Image=model_.ImageType(\n')
            self.Image.exportLiteral(outfile, level, name_='Image')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Subreport is not None:
            showIndent(outfile, level)
            outfile.write('Subreport=model_.SubreportType(\n')
            self.Subreport.exportLiteral(outfile, level, name_='Subreport')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Chart is not None:
            showIndent(outfile, level)
            outfile.write('Chart=model_.ChartType(\n')
            self.Chart.exportLiteral(outfile, level, name_='Chart')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GaugePanel is not None:
            showIndent(outfile, level)
            outfile.write('GaugePanel=model_.GaugePanelType(\n')
            self.GaugePanel.exportLiteral(outfile, level, name_='GaugePanel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CustomReportItem is not None:
            showIndent(outfile, level)
            outfile.write('CustomReportItem=model_.CustomReportItemType(\n')
            self.CustomReportItem.exportLiteral(outfile, level, name_='CustomReportItem')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tablix is not None:
            showIndent(outfile, level)
            outfile.write('Tablix=model_.TablixType(\n')
            self.Tablix.exportLiteral(outfile, level, name_='Tablix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ColSpan':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColSpan')
            self.ColSpan = ival_
        elif nodeName_ == 'RowSpan':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowSpan')
            self.RowSpan = ival_
        elif nodeName_ == 'Line':
            obj_ = LineType.factory()
            obj_.build(child_)
            self.set_Line(obj_)
        elif nodeName_ == 'Rectangle':
            obj_ = RectangleType.factory()
            obj_.build(child_)
            self.set_Rectangle(obj_)
        elif nodeName_ == 'Textbox':
            obj_ = TextboxType.factory()
            obj_.build(child_)
            self.set_Textbox(obj_)
        elif nodeName_ == 'Image':
            obj_ = ImageType.factory()
            obj_.build(child_)
            self.set_Image(obj_)
        elif nodeName_ == 'Subreport':
            obj_ = SubreportType.factory()
            obj_.build(child_)
            self.set_Subreport(obj_)
        elif nodeName_ == 'Chart':
            obj_ = ChartType.factory()
            obj_.build(child_)
            self.set_Chart(obj_)
        elif nodeName_ == 'GaugePanel':
            obj_ = GaugePanelType.factory()
            obj_.build(child_)
            self.set_GaugePanel(obj_)
        elif nodeName_ == 'CustomReportItem':
            obj_ = CustomReportItemType.factory()
            obj_.build(child_)
            self.set_CustomReportItem(obj_)
        elif nodeName_ == 'Tablix':
            obj_ = TablixType.factory()
            obj_.build(child_)
            self.set_Tablix(obj_)
# end class CellContentsType


class TablixColumnsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixColumn=None):
        if TablixColumn is None:
            self.TablixColumn = []
        else:
            self.TablixColumn = TablixColumn
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixColumnsType.subclass:
            return TablixColumnsType.subclass(*args_, **kwargs_)
        else:
            return TablixColumnsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixColumn(self): return self.TablixColumn
    def set_TablixColumn(self, TablixColumn): self.TablixColumn = TablixColumn
    def add_TablixColumn(self, value): self.TablixColumn.append(value)
    def insert_TablixColumn(self, index, value): self.TablixColumn[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixColumnsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixColumnsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixColumnsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixColumnsType', fromsubclass_=False):
        for TablixColumn_ in self.TablixColumn:
            TablixColumn_.export(outfile, level, namespace_, name_='TablixColumn')
    def hasContent_(self):
        if (
            self.TablixColumn
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixColumnsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixColumn=[\n')
        level += 1
        for TablixColumn_ in self.TablixColumn:
            showIndent(outfile, level)
            outfile.write('model_.TablixColumnType(\n')
            TablixColumn_.exportLiteral(outfile, level, name_='TablixColumnType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixColumn':
            obj_ = TablixColumnType.factory()
            obj_.build(child_)
            self.TablixColumn.append(obj_)
# end class TablixColumnsType


class TablixColumnType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Width=None):
        self.Width = Width
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixColumnType.subclass:
            return TablixColumnType.subclass(*args_, **kwargs_)
        else:
            return TablixColumnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixColumnType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixColumnType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixColumnType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixColumnType', fromsubclass_=False):
        if self.Width is not None:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(self.Width).encode(ExternalEncoding), input_name='Width'), namespace_))
    def hasContent_(self):
        if (
            self.Width is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixColumnType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Width is not None:
            showIndent(outfile, level)
            outfile.write('Width=%s,\n' % quote_python(self.Width).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width = Width_
            self.validate_SizeType(self.Width)    # validate type SizeType
# end class TablixColumnType


class TablixRowsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixRow=None):
        if TablixRow is None:
            self.TablixRow = []
        else:
            self.TablixRow = TablixRow
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixRowsType.subclass:
            return TablixRowsType.subclass(*args_, **kwargs_)
        else:
            return TablixRowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixRow(self): return self.TablixRow
    def set_TablixRow(self, TablixRow): self.TablixRow = TablixRow
    def add_TablixRow(self, value): self.TablixRow.append(value)
    def insert_TablixRow(self, index, value): self.TablixRow[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixRowsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixRowsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixRowsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixRowsType', fromsubclass_=False):
        for TablixRow_ in self.TablixRow:
            TablixRow_.export(outfile, level, namespace_, name_='TablixRow')
    def hasContent_(self):
        if (
            self.TablixRow
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixRowsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixRow=[\n')
        level += 1
        for TablixRow_ in self.TablixRow:
            showIndent(outfile, level)
            outfile.write('model_.TablixRowType(\n')
            TablixRow_.exportLiteral(outfile, level, name_='TablixRowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixRow':
            obj_ = TablixRowType.factory()
            obj_.build(child_)
            self.TablixRow.append(obj_)
# end class TablixRowsType


class TablixRowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Height=None, TablixCells=None):
        self.Height = Height
        self.TablixCells = TablixCells
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixRowType.subclass:
            return TablixRowType.subclass(*args_, **kwargs_)
        else:
            return TablixRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_TablixCells(self): return self.TablixCells
    def set_TablixCells(self, TablixCells): self.TablixCells = TablixCells
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixRowType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixRowType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixRowType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixRowType', fromsubclass_=False):
        if self.Height is not None:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(self.Height).encode(ExternalEncoding), input_name='Height'), namespace_))
        if self.TablixCells:
            self.TablixCells.export(outfile, level, namespace_, name_='TablixCells', )
    def hasContent_(self):
        if (
            self.Height is not None or
            self.TablixCells is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixRowType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Height is not None:
            showIndent(outfile, level)
            outfile.write('Height=%s,\n' % quote_python(self.Height).encode(ExternalEncoding))
        if self.TablixCells is not None:
            showIndent(outfile, level)
            outfile.write('TablixCells=model_.TablixCellsType(\n')
            self.TablixCells.exportLiteral(outfile, level, name_='TablixCells')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height = Height_
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'TablixCells':
            obj_ = TablixCellsType.factory()
            obj_.build(child_)
            self.set_TablixCells(obj_)
# end class TablixRowType


class TablixCellsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TablixCell=None):
        if TablixCell is None:
            self.TablixCell = []
        else:
            self.TablixCell = TablixCell
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixCellsType.subclass:
            return TablixCellsType.subclass(*args_, **kwargs_)
        else:
            return TablixCellsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TablixCell(self): return self.TablixCell
    def set_TablixCell(self, TablixCell): self.TablixCell = TablixCell
    def add_TablixCell(self, value): self.TablixCell.append(value)
    def insert_TablixCell(self, index, value): self.TablixCell[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixCellsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixCellsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixCellsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixCellsType', fromsubclass_=False):
        for TablixCell_ in self.TablixCell:
            TablixCell_.export(outfile, level, namespace_, name_='TablixCell')
    def hasContent_(self):
        if (
            self.TablixCell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixCellsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TablixCell=[\n')
        level += 1
        for TablixCell_ in self.TablixCell:
            showIndent(outfile, level)
            outfile.write('model_.TablixCellType(\n')
            TablixCell_.exportLiteral(outfile, level, name_='TablixCellType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TablixCell':
            obj_ = TablixCellType.factory()
            obj_.build(child_)
            self.TablixCell.append(obj_)
# end class TablixCellsType


class TablixCellType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CellContents=None, DataElementName=None, DataElementOutput=None):
        self.CellContents = CellContents
        self.DataElementName = DataElementName
        self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TablixCellType.subclass:
            return TablixCellType.subclass(*args_, **kwargs_)
        else:
            return TablixCellType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellContents(self): return self.CellContents
    def set_CellContents(self, CellContents): self.CellContents = CellContents
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TablixCellType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TablixCellType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TablixCellType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TablixCellType', fromsubclass_=False):
        if self.CellContents:
            self.CellContents.export(outfile, level, namespace_, name_='CellContents')
        if self.DataElementName is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataElementName).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        if self.DataElementOutput is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataElementOutput).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.CellContents is not None or
            self.DataElementName is not None or
            self.DataElementOutput is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TablixCellType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CellContents is not None:
            showIndent(outfile, level)
            outfile.write('CellContents=model_.CellContentsType(\n')
            self.CellContents.exportLiteral(outfile, level, name_='CellContents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataElementName is not None:
            showIndent(outfile, level)
            outfile.write('DataElementName=%s,\n' % quote_python(self.DataElementName).encode(ExternalEncoding))
        if self.DataElementOutput is not None:
            showIndent(outfile, level)
            outfile.write('DataElementOutput=%s,\n' % quote_python(self.DataElementOutput).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellContents':
            obj_ = CellContentsType.factory()
            obj_.build(child_)
            self.set_CellContents(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName = DataElementName_
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput = DataElementOutput_
# end class TablixCellType


class PageBreakType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BreakLocation=None):
        if BreakLocation is None:
            self.BreakLocation = []
        else:
            self.BreakLocation = BreakLocation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PageBreakType.subclass:
            return PageBreakType.subclass(*args_, **kwargs_)
        else:
            return PageBreakType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BreakLocation(self): return self.BreakLocation
    def set_BreakLocation(self, BreakLocation): self.BreakLocation = BreakLocation
    def add_BreakLocation(self, value): self.BreakLocation.append(value)
    def insert_BreakLocation(self, index, value): self.BreakLocation[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PageBreakType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageBreakType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageBreakType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PageBreakType', fromsubclass_=False):
        for BreakLocation_ in self.BreakLocation:
            showIndent(outfile, level)
            outfile.write('<%sBreakLocation>%s</%sBreakLocation>\n' % (namespace_, self.gds_format_string(quote_xml(BreakLocation_).encode(ExternalEncoding), input_name='BreakLocation'), namespace_))
    def hasContent_(self):
        if (
            self.BreakLocation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PageBreakType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BreakLocation=[\n')
        level += 1
        for BreakLocation_ in self.BreakLocation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BreakLocation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BreakLocation':
            BreakLocation_ = child_.text
            BreakLocation_ = self.gds_validate_string(BreakLocation_, node, 'BreakLocation')
            self.BreakLocation.append(BreakLocation_)
# end class PageBreakType


class BreakLocation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if BreakLocation.subclass:
            return BreakLocation.subclass(*args_, **kwargs_)
        else:
            return BreakLocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='BreakLocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BreakLocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BreakLocation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BreakLocation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BreakLocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BreakLocation


class GaugePanelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, SortExpressions=None, ActionInfo=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Visibility=None, ToolTip=None, DocumentMapLabel=None, Bookmark=None, RepeatWith=None, CustomProperties=None, NoRowsMessage=None, DataSetName=None, PageBreak=None, Filters=None, DataElementName=None, DataElementOutput=None, AntiAliasing=None, TextAntiAliasingQuality=None, AutoLayout=None, ShadowIntensity=None, RadialGauges=None, LinearGauges=None, NumericIndicators=None, StateIndicators=None, GaugeImages=None, GaugeLabels=None, BackFrame=None, TopImage=None, GaugeMember=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if SortExpressions is None:
            self.SortExpressions = []
        else:
            self.SortExpressions = SortExpressions
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Visibility is None:
            self.Visibility = []
        else:
            self.Visibility = Visibility
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if DocumentMapLabel is None:
            self.DocumentMapLabel = []
        else:
            self.DocumentMapLabel = DocumentMapLabel
        if Bookmark is None:
            self.Bookmark = []
        else:
            self.Bookmark = Bookmark
        if RepeatWith is None:
            self.RepeatWith = []
        else:
            self.RepeatWith = RepeatWith
        if CustomProperties is None:
            self.CustomProperties = []
        else:
            self.CustomProperties = CustomProperties
        if NoRowsMessage is None:
            self.NoRowsMessage = []
        else:
            self.NoRowsMessage = NoRowsMessage
        if DataSetName is None:
            self.DataSetName = []
        else:
            self.DataSetName = DataSetName
        if PageBreak is None:
            self.PageBreak = []
        else:
            self.PageBreak = PageBreak
        if Filters is None:
            self.Filters = []
        else:
            self.Filters = Filters
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        if AntiAliasing is None:
            self.AntiAliasing = []
        else:
            self.AntiAliasing = AntiAliasing
        if TextAntiAliasingQuality is None:
            self.TextAntiAliasingQuality = []
        else:
            self.TextAntiAliasingQuality = TextAntiAliasingQuality
        if AutoLayout is None:
            self.AutoLayout = []
        else:
            self.AutoLayout = AutoLayout
        if ShadowIntensity is None:
            self.ShadowIntensity = []
        else:
            self.ShadowIntensity = ShadowIntensity
        if RadialGauges is None:
            self.RadialGauges = []
        else:
            self.RadialGauges = RadialGauges
        if LinearGauges is None:
            self.LinearGauges = []
        else:
            self.LinearGauges = LinearGauges
        if NumericIndicators is None:
            self.NumericIndicators = []
        else:
            self.NumericIndicators = NumericIndicators
        if StateIndicators is None:
            self.StateIndicators = []
        else:
            self.StateIndicators = StateIndicators
        if GaugeImages is None:
            self.GaugeImages = []
        else:
            self.GaugeImages = GaugeImages
        if GaugeLabels is None:
            self.GaugeLabels = []
        else:
            self.GaugeLabels = GaugeLabels
        if BackFrame is None:
            self.BackFrame = []
        else:
            self.BackFrame = BackFrame
        if TopImage is None:
            self.TopImage = []
        else:
            self.TopImage = TopImage
        if GaugeMember is None:
            self.GaugeMember = []
        else:
            self.GaugeMember = GaugeMember
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugePanelType.subclass:
            return GaugePanelType.subclass(*args_, **kwargs_)
        else:
            return GaugePanelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def add_SortExpressions(self, value): self.SortExpressions.append(value)
    def insert_SortExpressions(self, index, value): self.SortExpressions[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Visibility(self): return self.Visibility
    def set_Visibility(self, Visibility): self.Visibility = Visibility
    def add_Visibility(self, value): self.Visibility.append(value)
    def insert_Visibility(self, index, value): self.Visibility[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_DocumentMapLabel(self): return self.DocumentMapLabel
    def set_DocumentMapLabel(self, DocumentMapLabel): self.DocumentMapLabel = DocumentMapLabel
    def add_DocumentMapLabel(self, value): self.DocumentMapLabel.append(value)
    def insert_DocumentMapLabel(self, index, value): self.DocumentMapLabel[index] = value
    def get_Bookmark(self): return self.Bookmark
    def set_Bookmark(self, Bookmark): self.Bookmark = Bookmark
    def add_Bookmark(self, value): self.Bookmark.append(value)
    def insert_Bookmark(self, index, value): self.Bookmark[index] = value
    def get_RepeatWith(self): return self.RepeatWith
    def set_RepeatWith(self, RepeatWith): self.RepeatWith = RepeatWith
    def add_RepeatWith(self, value): self.RepeatWith.append(value)
    def insert_RepeatWith(self, index, value): self.RepeatWith[index] = value
    def get_CustomProperties(self): return self.CustomProperties
    def set_CustomProperties(self, CustomProperties): self.CustomProperties = CustomProperties
    def add_CustomProperties(self, value): self.CustomProperties.append(value)
    def insert_CustomProperties(self, index, value): self.CustomProperties[index] = value
    def get_NoRowsMessage(self): return self.NoRowsMessage
    def set_NoRowsMessage(self, NoRowsMessage): self.NoRowsMessage = NoRowsMessage
    def add_NoRowsMessage(self, value): self.NoRowsMessage.append(value)
    def insert_NoRowsMessage(self, index, value): self.NoRowsMessage[index] = value
    def get_DataSetName(self): return self.DataSetName
    def set_DataSetName(self, DataSetName): self.DataSetName = DataSetName
    def add_DataSetName(self, value): self.DataSetName.append(value)
    def insert_DataSetName(self, index, value): self.DataSetName[index] = value
    def get_PageBreak(self): return self.PageBreak
    def set_PageBreak(self, PageBreak): self.PageBreak = PageBreak
    def add_PageBreak(self, value): self.PageBreak.append(value)
    def insert_PageBreak(self, index, value): self.PageBreak[index] = value
    def get_Filters(self): return self.Filters
    def set_Filters(self, Filters): self.Filters = Filters
    def add_Filters(self, value): self.Filters.append(value)
    def insert_Filters(self, index, value): self.Filters[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_AntiAliasing(self): return self.AntiAliasing
    def set_AntiAliasing(self, AntiAliasing): self.AntiAliasing = AntiAliasing
    def add_AntiAliasing(self, value): self.AntiAliasing.append(value)
    def insert_AntiAliasing(self, index, value): self.AntiAliasing[index] = value
    def get_TextAntiAliasingQuality(self): return self.TextAntiAliasingQuality
    def set_TextAntiAliasingQuality(self, TextAntiAliasingQuality): self.TextAntiAliasingQuality = TextAntiAliasingQuality
    def add_TextAntiAliasingQuality(self, value): self.TextAntiAliasingQuality.append(value)
    def insert_TextAntiAliasingQuality(self, index, value): self.TextAntiAliasingQuality[index] = value
    def get_AutoLayout(self): return self.AutoLayout
    def set_AutoLayout(self, AutoLayout): self.AutoLayout = AutoLayout
    def add_AutoLayout(self, value): self.AutoLayout.append(value)
    def insert_AutoLayout(self, index, value): self.AutoLayout[index] = value
    def get_ShadowIntensity(self): return self.ShadowIntensity
    def set_ShadowIntensity(self, ShadowIntensity): self.ShadowIntensity = ShadowIntensity
    def add_ShadowIntensity(self, value): self.ShadowIntensity.append(value)
    def insert_ShadowIntensity(self, index, value): self.ShadowIntensity[index] = value
    def get_RadialGauges(self): return self.RadialGauges
    def set_RadialGauges(self, RadialGauges): self.RadialGauges = RadialGauges
    def add_RadialGauges(self, value): self.RadialGauges.append(value)
    def insert_RadialGauges(self, index, value): self.RadialGauges[index] = value
    def get_LinearGauges(self): return self.LinearGauges
    def set_LinearGauges(self, LinearGauges): self.LinearGauges = LinearGauges
    def add_LinearGauges(self, value): self.LinearGauges.append(value)
    def insert_LinearGauges(self, index, value): self.LinearGauges[index] = value
    def get_NumericIndicators(self): return self.NumericIndicators
    def set_NumericIndicators(self, NumericIndicators): self.NumericIndicators = NumericIndicators
    def add_NumericIndicators(self, value): self.NumericIndicators.append(value)
    def insert_NumericIndicators(self, index, value): self.NumericIndicators[index] = value
    def get_StateIndicators(self): return self.StateIndicators
    def set_StateIndicators(self, StateIndicators): self.StateIndicators = StateIndicators
    def add_StateIndicators(self, value): self.StateIndicators.append(value)
    def insert_StateIndicators(self, index, value): self.StateIndicators[index] = value
    def get_GaugeImages(self): return self.GaugeImages
    def set_GaugeImages(self, GaugeImages): self.GaugeImages = GaugeImages
    def add_GaugeImages(self, value): self.GaugeImages.append(value)
    def insert_GaugeImages(self, index, value): self.GaugeImages[index] = value
    def get_GaugeLabels(self): return self.GaugeLabels
    def set_GaugeLabels(self, GaugeLabels): self.GaugeLabels = GaugeLabels
    def add_GaugeLabels(self, value): self.GaugeLabels.append(value)
    def insert_GaugeLabels(self, index, value): self.GaugeLabels[index] = value
    def get_BackFrame(self): return self.BackFrame
    def set_BackFrame(self, BackFrame): self.BackFrame = BackFrame
    def add_BackFrame(self, value): self.BackFrame.append(value)
    def insert_BackFrame(self, index, value): self.BackFrame[index] = value
    def get_TopImage(self): return self.TopImage
    def set_TopImage(self, TopImage): self.TopImage = TopImage
    def add_TopImage(self, value): self.TopImage.append(value)
    def insert_TopImage(self, index, value): self.TopImage[index] = value
    def get_GaugeMember(self): return self.GaugeMember
    def set_GaugeMember(self, GaugeMember): self.GaugeMember = GaugeMember
    def add_GaugeMember(self, value): self.GaugeMember.append(value)
    def insert_GaugeMember(self, index, value): self.GaugeMember[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugePanelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugePanelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugePanelType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GaugePanelType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for SortExpressions_ in self.SortExpressions:
            SortExpressions_.export(outfile, level, namespace_, name_='SortExpressions')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_integer(ZIndex_, input_name='ZIndex'), namespace_))
        for Visibility_ in self.Visibility:
            Visibility_.export(outfile, level, namespace_, name_='Visibility')
        for ToolTip_ in self.ToolTip:
            ToolTip_.export(outfile, level, namespace_, name_='ToolTip')
        for DocumentMapLabel_ in self.DocumentMapLabel:
            DocumentMapLabel_.export(outfile, level, namespace_, name_='DocumentMapLabel')
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('<%sBookmark>%s</%sBookmark>\n' % (namespace_, self.gds_format_string(quote_xml(Bookmark_).encode(ExternalEncoding), input_name='Bookmark'), namespace_))
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('<%sRepeatWith>%s</%sRepeatWith>\n' % (namespace_, self.gds_format_string(quote_xml(RepeatWith_).encode(ExternalEncoding), input_name='RepeatWith'), namespace_))
        for CustomProperties_ in self.CustomProperties:
            CustomProperties_.export(outfile, level, namespace_, name_='CustomProperties')
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('<%sNoRowsMessage>%s</%sNoRowsMessage>\n' % (namespace_, self.gds_format_string(quote_xml(NoRowsMessage_).encode(ExternalEncoding), input_name='NoRowsMessage'), namespace_))
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('<%sDataSetName>%s</%sDataSetName>\n' % (namespace_, self.gds_format_string(quote_xml(DataSetName_).encode(ExternalEncoding), input_name='DataSetName'), namespace_))
        for PageBreak_ in self.PageBreak:
            PageBreak_.export(outfile, level, namespace_, name_='PageBreak')
        for Filters_ in self.Filters:
            Filters_.export(outfile, level, namespace_, name_='Filters')
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
        for AntiAliasing_ in self.AntiAliasing:
            showIndent(outfile, level)
            outfile.write('<%sAntiAliasing>%s</%sAntiAliasing>\n' % (namespace_, self.gds_format_string(quote_xml(AntiAliasing_).encode(ExternalEncoding), input_name='AntiAliasing'), namespace_))
        for TextAntiAliasingQuality_ in self.TextAntiAliasingQuality:
            showIndent(outfile, level)
            outfile.write('<%sTextAntiAliasingQuality>%s</%sTextAntiAliasingQuality>\n' % (namespace_, self.gds_format_string(quote_xml(TextAntiAliasingQuality_).encode(ExternalEncoding), input_name='TextAntiAliasingQuality'), namespace_))
        for AutoLayout_ in self.AutoLayout:
            showIndent(outfile, level)
            outfile.write('<%sAutoLayout>%s</%sAutoLayout>\n' % (namespace_, self.gds_format_string(quote_xml(AutoLayout_).encode(ExternalEncoding), input_name='AutoLayout'), namespace_))
        for ShadowIntensity_ in self.ShadowIntensity:
            showIndent(outfile, level)
            outfile.write('<%sShadowIntensity>%s</%sShadowIntensity>\n' % (namespace_, self.gds_format_string(quote_xml(ShadowIntensity_).encode(ExternalEncoding), input_name='ShadowIntensity'), namespace_))
        for RadialGauges_ in self.RadialGauges:
            RadialGauges_.export(outfile, level, namespace_, name_='RadialGauges')
        for LinearGauges_ in self.LinearGauges:
            LinearGauges_.export(outfile, level, namespace_, name_='LinearGauges')
        for NumericIndicators_ in self.NumericIndicators:
            NumericIndicators_.export(outfile, level, namespace_, name_='NumericIndicators')
        for StateIndicators_ in self.StateIndicators:
            StateIndicators_.export(outfile, level, namespace_, name_='StateIndicators')
        for GaugeImages_ in self.GaugeImages:
            GaugeImages_.export(outfile, level, namespace_, name_='GaugeImages')
        for GaugeLabels_ in self.GaugeLabels:
            GaugeLabels_.export(outfile, level, namespace_, name_='GaugeLabels')
        for BackFrame_ in self.BackFrame:
            BackFrame_.export(outfile, level, namespace_, name_='BackFrame')
        for TopImage_ in self.TopImage:
            TopImage_.export(outfile, level, namespace_, name_='TopImage')
        for GaugeMember_ in self.GaugeMember:
            GaugeMember_.export(outfile, level, namespace_, name_='GaugeMember')
    def hasContent_(self):
        if (
            self.Style or
            self.SortExpressions or
            self.ActionInfo or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Visibility or
            self.ToolTip or
            self.DocumentMapLabel or
            self.Bookmark or
            self.RepeatWith or
            self.CustomProperties or
            self.NoRowsMessage or
            self.DataSetName or
            self.PageBreak or
            self.Filters or
            self.DataElementName or
            self.DataElementOutput or
            self.AntiAliasing or
            self.TextAntiAliasingQuality or
            self.AutoLayout or
            self.ShadowIntensity or
            self.RadialGauges or
            self.LinearGauges or
            self.NumericIndicators or
            self.StateIndicators or
            self.GaugeImages or
            self.GaugeLabels or
            self.BackFrame or
            self.TopImage or
            self.GaugeMember
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugePanelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressions=[\n')
        level += 1
        for SortExpressions_ in self.SortExpressions:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionsType(\n')
            SortExpressions_.exportLiteral(outfile, level, name_='SortExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%d,\n' % ZIndex)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Visibility=[\n')
        level += 1
        for Visibility_ in self.Visibility:
            showIndent(outfile, level)
            outfile.write('model_.VisibilityType(\n')
            Visibility_.exportLiteral(outfile, level, name_='VisibilityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            ToolTip_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DocumentMapLabel=[\n')
        level += 1
        for DocumentMapLabel_ in self.DocumentMapLabel:
            showIndent(outfile, level)
            outfile.write('model_.StringLocIDType(\n')
            DocumentMapLabel_.exportLiteral(outfile, level, name_='StringLocIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Bookmark=[\n')
        level += 1
        for Bookmark_ in self.Bookmark:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Bookmark_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RepeatWith=[\n')
        level += 1
        for RepeatWith_ in self.RepeatWith:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RepeatWith_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomProperties=[\n')
        level += 1
        for CustomProperties_ in self.CustomProperties:
            showIndent(outfile, level)
            outfile.write('model_.CustomPropertiesType(\n')
            CustomProperties_.exportLiteral(outfile, level, name_='CustomPropertiesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NoRowsMessage=[\n')
        level += 1
        for NoRowsMessage_ in self.NoRowsMessage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NoRowsMessage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSetName=[\n')
        level += 1
        for DataSetName_ in self.DataSetName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSetName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PageBreak=[\n')
        level += 1
        for PageBreak_ in self.PageBreak:
            showIndent(outfile, level)
            outfile.write('model_.PageBreakType(\n')
            PageBreak_.exportLiteral(outfile, level, name_='PageBreakType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Filters=[\n')
        level += 1
        for Filters_ in self.Filters:
            showIndent(outfile, level)
            outfile.write('model_.FiltersType(\n')
            Filters_.exportLiteral(outfile, level, name_='FiltersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AntiAliasing=[\n')
        level += 1
        for AntiAliasing_ in self.AntiAliasing:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AntiAliasing_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextAntiAliasingQuality=[\n')
        level += 1
        for TextAntiAliasingQuality_ in self.TextAntiAliasingQuality:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextAntiAliasingQuality_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AutoLayout=[\n')
        level += 1
        for AutoLayout_ in self.AutoLayout:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AutoLayout_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShadowIntensity=[\n')
        level += 1
        for ShadowIntensity_ in self.ShadowIntensity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShadowIntensity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RadialGauges=[\n')
        level += 1
        for RadialGauges_ in self.RadialGauges:
            showIndent(outfile, level)
            outfile.write('model_.RadialGaugesType(\n')
            RadialGauges_.exportLiteral(outfile, level, name_='RadialGaugesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LinearGauges=[\n')
        level += 1
        for LinearGauges_ in self.LinearGauges:
            showIndent(outfile, level)
            outfile.write('model_.LinearGaugesType(\n')
            LinearGauges_.exportLiteral(outfile, level, name_='LinearGaugesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NumericIndicators=[\n')
        level += 1
        for NumericIndicators_ in self.NumericIndicators:
            showIndent(outfile, level)
            outfile.write('model_.NumericIndicatorsType(\n')
            NumericIndicators_.exportLiteral(outfile, level, name_='NumericIndicatorsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StateIndicators=[\n')
        level += 1
        for StateIndicators_ in self.StateIndicators:
            showIndent(outfile, level)
            outfile.write('model_.StateIndicatorsType(\n')
            StateIndicators_.exportLiteral(outfile, level, name_='StateIndicatorsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeImages=[\n')
        level += 1
        for GaugeImages_ in self.GaugeImages:
            showIndent(outfile, level)
            outfile.write('model_.GaugeImagesType(\n')
            GaugeImages_.exportLiteral(outfile, level, name_='GaugeImagesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeLabels=[\n')
        level += 1
        for GaugeLabels_ in self.GaugeLabels:
            showIndent(outfile, level)
            outfile.write('model_.GaugeLabelsType(\n')
            GaugeLabels_.exportLiteral(outfile, level, name_='GaugeLabelsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackFrame=[\n')
        level += 1
        for BackFrame_ in self.BackFrame:
            showIndent(outfile, level)
            outfile.write('model_.BackFrameType(\n')
            BackFrame_.exportLiteral(outfile, level, name_='BackFrameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TopImage=[\n')
        level += 1
        for TopImage_ in self.TopImage:
            showIndent(outfile, level)
            outfile.write('model_.TopImageType(\n')
            TopImage_.exportLiteral(outfile, level, name_='TopImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeMember=[\n')
        level += 1
        for GaugeMember_ in self.GaugeMember:
            showIndent(outfile, level)
            outfile.write('model_.GaugeMemberType(\n')
            GaugeMember_.exportLiteral(outfile, level, name_='GaugeMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.SortExpressions.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
            self.validate_SizeType(self.Top)    # validate type SizeType
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
            self.validate_SizeType(self.Left)    # validate type SizeType
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
            self.validate_SizeType(self.Height)    # validate type SizeType
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
            self.validate_SizeType(self.Width)    # validate type SizeType
        elif nodeName_ == 'ZIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ZIndex')
            self.ZIndex.append(ival_)
        elif nodeName_ == 'Visibility':
            obj_ = VisibilityType.factory()
            obj_.build(child_)
            self.Visibility.append(obj_)
        elif nodeName_ == 'ToolTip':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.ToolTip.append(obj_)
        elif nodeName_ == 'DocumentMapLabel':
            obj_ = StringLocIDType.factory()
            obj_.build(child_)
            self.DocumentMapLabel.append(obj_)
        elif nodeName_ == 'Bookmark':
            Bookmark_ = child_.text
            Bookmark_ = self.gds_validate_string(Bookmark_, node, 'Bookmark')
            self.Bookmark.append(Bookmark_)
        elif nodeName_ == 'RepeatWith':
            RepeatWith_ = child_.text
            RepeatWith_ = self.gds_validate_string(RepeatWith_, node, 'RepeatWith')
            self.RepeatWith.append(RepeatWith_)
        elif nodeName_ == 'CustomProperties':
            obj_ = CustomPropertiesType.factory()
            obj_.build(child_)
            self.CustomProperties.append(obj_)
        elif nodeName_ == 'NoRowsMessage':
            NoRowsMessage_ = child_.text
            NoRowsMessage_ = self.gds_validate_string(NoRowsMessage_, node, 'NoRowsMessage')
            self.NoRowsMessage.append(NoRowsMessage_)
        elif nodeName_ == 'DataSetName':
            DataSetName_ = child_.text
            DataSetName_ = self.gds_validate_string(DataSetName_, node, 'DataSetName')
            self.DataSetName.append(DataSetName_)
        elif nodeName_ == 'PageBreak':
            obj_ = PageBreakType.factory()
            obj_.build(child_)
            self.PageBreak.append(obj_)
        elif nodeName_ == 'Filters':
            obj_ = FiltersType.factory()
            obj_.build(child_)
            self.Filters.append(obj_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
        elif nodeName_ == 'AntiAliasing':
            AntiAliasing_ = child_.text
            AntiAliasing_ = self.gds_validate_string(AntiAliasing_, node, 'AntiAliasing')
            self.AntiAliasing.append(AntiAliasing_)
        elif nodeName_ == 'TextAntiAliasingQuality':
            TextAntiAliasingQuality_ = child_.text
            TextAntiAliasingQuality_ = self.gds_validate_string(TextAntiAliasingQuality_, node, 'TextAntiAliasingQuality')
            self.TextAntiAliasingQuality.append(TextAntiAliasingQuality_)
        elif nodeName_ == 'AutoLayout':
            AutoLayout_ = child_.text
            AutoLayout_ = self.gds_validate_string(AutoLayout_, node, 'AutoLayout')
            self.AutoLayout.append(AutoLayout_)
        elif nodeName_ == 'ShadowIntensity':
            ShadowIntensity_ = child_.text
            ShadowIntensity_ = self.gds_validate_string(ShadowIntensity_, node, 'ShadowIntensity')
            self.ShadowIntensity.append(ShadowIntensity_)
        elif nodeName_ == 'RadialGauges':
            obj_ = RadialGaugesType.factory()
            obj_.build(child_)
            self.RadialGauges.append(obj_)
        elif nodeName_ == 'LinearGauges':
            obj_ = LinearGaugesType.factory()
            obj_.build(child_)
            self.LinearGauges.append(obj_)
        elif nodeName_ == 'NumericIndicators':
            obj_ = NumericIndicatorsType.factory()
            obj_.build(child_)
            self.NumericIndicators.append(obj_)
        elif nodeName_ == 'StateIndicators':
            obj_ = StateIndicatorsType.factory()
            obj_.build(child_)
            self.StateIndicators.append(obj_)
        elif nodeName_ == 'GaugeImages':
            obj_ = GaugeImagesType.factory()
            obj_.build(child_)
            self.GaugeImages.append(obj_)
        elif nodeName_ == 'GaugeLabels':
            obj_ = GaugeLabelsType.factory()
            obj_.build(child_)
            self.GaugeLabels.append(obj_)
        elif nodeName_ == 'BackFrame':
            obj_ = BackFrameType.factory()
            obj_.build(child_)
            self.BackFrame.append(obj_)
        elif nodeName_ == 'TopImage':
            obj_ = TopImageType.factory()
            obj_.build(child_)
            self.TopImage.append(obj_)
        elif nodeName_ == 'GaugeMember':
            obj_ = GaugeMemberType.factory()
            obj_.build(child_)
            self.GaugeMember.append(obj_)
# end class GaugePanelType


class GaugeMemberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Group=None, SortExpressions=None, GaugeMember=None):
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        if SortExpressions is None:
            self.SortExpressions = []
        else:
            self.SortExpressions = SortExpressions
        if GaugeMember is None:
            self.GaugeMember = []
        else:
            self.GaugeMember = GaugeMember
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeMemberType.subclass:
            return GaugeMemberType.subclass(*args_, **kwargs_)
        else:
            return GaugeMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group(self, index, value): self.Group[index] = value
    def get_SortExpressions(self): return self.SortExpressions
    def set_SortExpressions(self, SortExpressions): self.SortExpressions = SortExpressions
    def add_SortExpressions(self, value): self.SortExpressions.append(value)
    def insert_SortExpressions(self, index, value): self.SortExpressions[index] = value
    def get_GaugeMember(self): return self.GaugeMember
    def set_GaugeMember(self, GaugeMember): self.GaugeMember = GaugeMember
    def add_GaugeMember(self, value): self.GaugeMember.append(value)
    def insert_GaugeMember(self, index, value): self.GaugeMember[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeMemberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeMemberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeMemberType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeMemberType', fromsubclass_=False):
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group')
        for SortExpressions_ in self.SortExpressions:
            SortExpressions_.export(outfile, level, namespace_, name_='SortExpressions')
        for GaugeMember_ in self.GaugeMember:
            GaugeMember_.export(outfile, level, namespace_, name_='GaugeMember')
    def hasContent_(self):
        if (
            self.Group or
            self.SortExpressions or
            self.GaugeMember
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeMemberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.GroupType(\n')
            Group_.exportLiteral(outfile, level, name_='GroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SortExpressions=[\n')
        level += 1
        for SortExpressions_ in self.SortExpressions:
            showIndent(outfile, level)
            outfile.write('model_.SortExpressionsType(\n')
            SortExpressions_.exportLiteral(outfile, level, name_='SortExpressionsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeMember=[\n')
        level += 1
        for GaugeMember_ in self.GaugeMember:
            showIndent(outfile, level)
            outfile.write('model_.GaugeMemberType(\n')
            GaugeMember_.exportLiteral(outfile, level, name_='GaugeMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Group':
            obj_ = GroupType.factory()
            obj_.build(child_)
            self.Group.append(obj_)
        elif nodeName_ == 'SortExpressions':
            obj_ = SortExpressionsType.factory()
            obj_.build(child_)
            self.SortExpressions.append(obj_)
        elif nodeName_ == 'GaugeMember':
            obj_ = GaugeMemberType.factory()
            obj_.build(child_)
            self.GaugeMember.append(obj_)
# end class GaugeMemberType


class GaugeInputValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None, Formula=None, MinPercent=None, MaxPercent=None, Multiplier=None, AddConstant=None, DataElementName=None, DataElementOutput=None):
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Formula is None:
            self.Formula = []
        else:
            self.Formula = Formula
        if MinPercent is None:
            self.MinPercent = []
        else:
            self.MinPercent = MinPercent
        if MaxPercent is None:
            self.MaxPercent = []
        else:
            self.MaxPercent = MaxPercent
        if Multiplier is None:
            self.Multiplier = []
        else:
            self.Multiplier = Multiplier
        if AddConstant is None:
            self.AddConstant = []
        else:
            self.AddConstant = AddConstant
        if DataElementName is None:
            self.DataElementName = []
        else:
            self.DataElementName = DataElementName
        if DataElementOutput is None:
            self.DataElementOutput = []
        else:
            self.DataElementOutput = DataElementOutput
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeInputValueType.subclass:
            return GaugeInputValueType.subclass(*args_, **kwargs_)
        else:
            return GaugeInputValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Formula(self): return self.Formula
    def set_Formula(self, Formula): self.Formula = Formula
    def add_Formula(self, value): self.Formula.append(value)
    def insert_Formula(self, index, value): self.Formula[index] = value
    def get_MinPercent(self): return self.MinPercent
    def set_MinPercent(self, MinPercent): self.MinPercent = MinPercent
    def add_MinPercent(self, value): self.MinPercent.append(value)
    def insert_MinPercent(self, index, value): self.MinPercent[index] = value
    def get_MaxPercent(self): return self.MaxPercent
    def set_MaxPercent(self, MaxPercent): self.MaxPercent = MaxPercent
    def add_MaxPercent(self, value): self.MaxPercent.append(value)
    def insert_MaxPercent(self, index, value): self.MaxPercent[index] = value
    def get_Multiplier(self): return self.Multiplier
    def set_Multiplier(self, Multiplier): self.Multiplier = Multiplier
    def add_Multiplier(self, value): self.Multiplier.append(value)
    def insert_Multiplier(self, index, value): self.Multiplier[index] = value
    def get_AddConstant(self): return self.AddConstant
    def set_AddConstant(self, AddConstant): self.AddConstant = AddConstant
    def add_AddConstant(self, value): self.AddConstant.append(value)
    def insert_AddConstant(self, index, value): self.AddConstant[index] = value
    def get_DataElementName(self): return self.DataElementName
    def set_DataElementName(self, DataElementName): self.DataElementName = DataElementName
    def add_DataElementName(self, value): self.DataElementName.append(value)
    def insert_DataElementName(self, index, value): self.DataElementName[index] = value
    def get_DataElementOutput(self): return self.DataElementOutput
    def set_DataElementOutput(self, DataElementOutput): self.DataElementOutput = DataElementOutput
    def add_DataElementOutput(self, value): self.DataElementOutput.append(value)
    def insert_DataElementOutput(self, index, value): self.DataElementOutput[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeInputValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeInputValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeInputValueType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeInputValueType', fromsubclass_=False):
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Formula_ in self.Formula:
            showIndent(outfile, level)
            outfile.write('<%sFormula>%s</%sFormula>\n' % (namespace_, self.gds_format_string(quote_xml(Formula_).encode(ExternalEncoding), input_name='Formula'), namespace_))
        for MinPercent_ in self.MinPercent:
            showIndent(outfile, level)
            outfile.write('<%sMinPercent>%s</%sMinPercent>\n' % (namespace_, self.gds_format_string(quote_xml(MinPercent_).encode(ExternalEncoding), input_name='MinPercent'), namespace_))
        for MaxPercent_ in self.MaxPercent:
            showIndent(outfile, level)
            outfile.write('<%sMaxPercent>%s</%sMaxPercent>\n' % (namespace_, self.gds_format_string(quote_xml(MaxPercent_).encode(ExternalEncoding), input_name='MaxPercent'), namespace_))
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('<%sMultiplier>%s</%sMultiplier>\n' % (namespace_, self.gds_format_string(quote_xml(Multiplier_).encode(ExternalEncoding), input_name='Multiplier'), namespace_))
        for AddConstant_ in self.AddConstant:
            showIndent(outfile, level)
            outfile.write('<%sAddConstant>%s</%sAddConstant>\n' % (namespace_, self.gds_format_string(quote_xml(AddConstant_).encode(ExternalEncoding), input_name='AddConstant'), namespace_))
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('<%sDataElementName>%s</%sDataElementName>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementName_).encode(ExternalEncoding), input_name='DataElementName'), namespace_))
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('<%sDataElementOutput>%s</%sDataElementOutput>\n' % (namespace_, self.gds_format_string(quote_xml(DataElementOutput_).encode(ExternalEncoding), input_name='DataElementOutput'), namespace_))
    def hasContent_(self):
        if (
            self.Value or
            self.Formula or
            self.MinPercent or
            self.MaxPercent or
            self.Multiplier or
            self.AddConstant or
            self.DataElementName or
            self.DataElementOutput
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeInputValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Formula=[\n')
        level += 1
        for Formula_ in self.Formula:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Formula_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinPercent=[\n')
        level += 1
        for MinPercent_ in self.MinPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MinPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaxPercent=[\n')
        level += 1
        for MaxPercent_ in self.MaxPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MaxPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Multiplier=[\n')
        level += 1
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Multiplier_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AddConstant=[\n')
        level += 1
        for AddConstant_ in self.AddConstant:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AddConstant_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementName=[\n')
        level += 1
        for DataElementName_ in self.DataElementName:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementName_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataElementOutput=[\n')
        level += 1
        for DataElementOutput_ in self.DataElementOutput:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataElementOutput_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Formula':
            Formula_ = child_.text
            Formula_ = self.gds_validate_string(Formula_, node, 'Formula')
            self.Formula.append(Formula_)
        elif nodeName_ == 'MinPercent':
            MinPercent_ = child_.text
            MinPercent_ = self.gds_validate_string(MinPercent_, node, 'MinPercent')
            self.MinPercent.append(MinPercent_)
        elif nodeName_ == 'MaxPercent':
            MaxPercent_ = child_.text
            MaxPercent_ = self.gds_validate_string(MaxPercent_, node, 'MaxPercent')
            self.MaxPercent.append(MaxPercent_)
        elif nodeName_ == 'Multiplier':
            Multiplier_ = child_.text
            Multiplier_ = self.gds_validate_string(Multiplier_, node, 'Multiplier')
            self.Multiplier.append(Multiplier_)
        elif nodeName_ == 'AddConstant':
            AddConstant_ = child_.text
            AddConstant_ = self.gds_validate_string(AddConstant_, node, 'AddConstant')
            self.AddConstant.append(AddConstant_)
        elif nodeName_ == 'DataElementName':
            DataElementName_ = child_.text
            DataElementName_ = self.gds_validate_string(DataElementName_, node, 'DataElementName')
            self.DataElementName.append(DataElementName_)
        elif nodeName_ == 'DataElementOutput':
            DataElementOutput_ = child_.text
            DataElementOutput_ = self.gds_validate_string(DataElementOutput_, node, 'DataElementOutput')
            self.DataElementOutput.append(DataElementOutput_)
# end class GaugeInputValueType


class RadialGaugeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ActionInfo=None, ToolTip=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Hidden=None, ParentItem=None, BackFrame=None, TopImage=None, ClipContent=None, AspectRatio=None, GaugeScales=None, PivotX=None, PivotY=None):
        self.Name = _cast(None, Name)
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ParentItem is None:
            self.ParentItem = []
        else:
            self.ParentItem = ParentItem
        if BackFrame is None:
            self.BackFrame = []
        else:
            self.BackFrame = BackFrame
        if TopImage is None:
            self.TopImage = []
        else:
            self.TopImage = TopImage
        if ClipContent is None:
            self.ClipContent = []
        else:
            self.ClipContent = ClipContent
        if AspectRatio is None:
            self.AspectRatio = []
        else:
            self.AspectRatio = AspectRatio
        if GaugeScales is None:
            self.GaugeScales = []
        else:
            self.GaugeScales = GaugeScales
        if PivotX is None:
            self.PivotX = []
        else:
            self.PivotX = PivotX
        if PivotY is None:
            self.PivotY = []
        else:
            self.PivotY = PivotY
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RadialGaugeType.subclass:
            return RadialGaugeType.subclass(*args_, **kwargs_)
        else:
            return RadialGaugeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ParentItem(self): return self.ParentItem
    def set_ParentItem(self, ParentItem): self.ParentItem = ParentItem
    def add_ParentItem(self, value): self.ParentItem.append(value)
    def insert_ParentItem(self, index, value): self.ParentItem[index] = value
    def get_BackFrame(self): return self.BackFrame
    def set_BackFrame(self, BackFrame): self.BackFrame = BackFrame
    def add_BackFrame(self, value): self.BackFrame.append(value)
    def insert_BackFrame(self, index, value): self.BackFrame[index] = value
    def get_TopImage(self): return self.TopImage
    def set_TopImage(self, TopImage): self.TopImage = TopImage
    def add_TopImage(self, value): self.TopImage.append(value)
    def insert_TopImage(self, index, value): self.TopImage[index] = value
    def get_ClipContent(self): return self.ClipContent
    def set_ClipContent(self, ClipContent): self.ClipContent = ClipContent
    def add_ClipContent(self, value): self.ClipContent.append(value)
    def insert_ClipContent(self, index, value): self.ClipContent[index] = value
    def get_AspectRatio(self): return self.AspectRatio
    def set_AspectRatio(self, AspectRatio): self.AspectRatio = AspectRatio
    def add_AspectRatio(self, value): self.AspectRatio.append(value)
    def insert_AspectRatio(self, index, value): self.AspectRatio[index] = value
    def get_GaugeScales(self): return self.GaugeScales
    def set_GaugeScales(self, GaugeScales): self.GaugeScales = GaugeScales
    def add_GaugeScales(self, value): self.GaugeScales.append(value)
    def insert_GaugeScales(self, index, value): self.GaugeScales[index] = value
    def get_PivotX(self): return self.PivotX
    def set_PivotX(self, PivotX): self.PivotX = PivotX
    def add_PivotX(self, value): self.PivotX.append(value)
    def insert_PivotX(self, index, value): self.PivotX[index] = value
    def get_PivotY(self): return self.PivotY
    def set_PivotY(self, PivotY): self.PivotY = PivotY
    def add_PivotY(self, value): self.PivotY.append(value)
    def insert_PivotY(self, index, value): self.PivotY[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RadialGaugeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialGaugeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialGaugeType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RadialGaugeType', fromsubclass_=False):
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_string(quote_xml(ZIndex_).encode(ExternalEncoding), input_name='ZIndex'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('<%sParentItem>%s</%sParentItem>\n' % (namespace_, self.gds_format_string(quote_xml(ParentItem_).encode(ExternalEncoding), input_name='ParentItem'), namespace_))
        for BackFrame_ in self.BackFrame:
            BackFrame_.export(outfile, level, namespace_, name_='BackFrame')
        for TopImage_ in self.TopImage:
            TopImage_.export(outfile, level, namespace_, name_='TopImage')
        for ClipContent_ in self.ClipContent:
            showIndent(outfile, level)
            outfile.write('<%sClipContent>%s</%sClipContent>\n' % (namespace_, self.gds_format_string(quote_xml(ClipContent_).encode(ExternalEncoding), input_name='ClipContent'), namespace_))
        for AspectRatio_ in self.AspectRatio:
            showIndent(outfile, level)
            outfile.write('<%sAspectRatio>%s</%sAspectRatio>\n' % (namespace_, self.gds_format_string(quote_xml(AspectRatio_).encode(ExternalEncoding), input_name='AspectRatio'), namespace_))
        for GaugeScales_ in self.GaugeScales:
            GaugeScales_.export(outfile, level, namespace_, name_='GaugeScales')
        for PivotX_ in self.PivotX:
            showIndent(outfile, level)
            outfile.write('<%sPivotX>%s</%sPivotX>\n' % (namespace_, self.gds_format_string(quote_xml(PivotX_).encode(ExternalEncoding), input_name='PivotX'), namespace_))
        for PivotY_ in self.PivotY:
            showIndent(outfile, level)
            outfile.write('<%sPivotY>%s</%sPivotY>\n' % (namespace_, self.gds_format_string(quote_xml(PivotY_).encode(ExternalEncoding), input_name='PivotY'), namespace_))
    def hasContent_(self):
        if (
            self.ActionInfo or
            self.ToolTip or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Hidden or
            self.ParentItem or
            self.BackFrame or
            self.TopImage or
            self.ClipContent or
            self.AspectRatio or
            self.GaugeScales or
            self.PivotX or
            self.PivotY
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RadialGaugeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ZIndex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentItem=[\n')
        level += 1
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ParentItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackFrame=[\n')
        level += 1
        for BackFrame_ in self.BackFrame:
            showIndent(outfile, level)
            outfile.write('model_.BackFrameType(\n')
            BackFrame_.exportLiteral(outfile, level, name_='BackFrameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TopImage=[\n')
        level += 1
        for TopImage_ in self.TopImage:
            showIndent(outfile, level)
            outfile.write('model_.TopImageType(\n')
            TopImage_.exportLiteral(outfile, level, name_='TopImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ClipContent=[\n')
        level += 1
        for ClipContent_ in self.ClipContent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ClipContent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AspectRatio=[\n')
        level += 1
        for AspectRatio_ in self.AspectRatio:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AspectRatio_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeScales=[\n')
        level += 1
        for GaugeScales_ in self.GaugeScales:
            showIndent(outfile, level)
            outfile.write('model_.RadialScalesType(\n')
            GaugeScales_.exportLiteral(outfile, level, name_='RadialScalesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PivotX=[\n')
        level += 1
        for PivotX_ in self.PivotX:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PivotX_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PivotY=[\n')
        level += 1
        for PivotY_ in self.PivotY:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PivotY_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'ZIndex':
            ZIndex_ = child_.text
            ZIndex_ = self.gds_validate_string(ZIndex_, node, 'ZIndex')
            self.ZIndex.append(ZIndex_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ParentItem':
            ParentItem_ = child_.text
            ParentItem_ = self.gds_validate_string(ParentItem_, node, 'ParentItem')
            self.ParentItem.append(ParentItem_)
        elif nodeName_ == 'BackFrame':
            obj_ = BackFrameType.factory()
            obj_.build(child_)
            self.BackFrame.append(obj_)
        elif nodeName_ == 'TopImage':
            obj_ = TopImageType.factory()
            obj_.build(child_)
            self.TopImage.append(obj_)
        elif nodeName_ == 'ClipContent':
            ClipContent_ = child_.text
            ClipContent_ = self.gds_validate_string(ClipContent_, node, 'ClipContent')
            self.ClipContent.append(ClipContent_)
        elif nodeName_ == 'AspectRatio':
            AspectRatio_ = child_.text
            AspectRatio_ = self.gds_validate_string(AspectRatio_, node, 'AspectRatio')
            self.AspectRatio.append(AspectRatio_)
        elif nodeName_ == 'GaugeScales':
            obj_ = RadialScalesType.factory()
            obj_.build(child_)
            self.GaugeScales.append(obj_)
        elif nodeName_ == 'PivotX':
            PivotX_ = child_.text
            PivotX_ = self.gds_validate_string(PivotX_, node, 'PivotX')
            self.PivotX.append(PivotX_)
        elif nodeName_ == 'PivotY':
            PivotY_ = child_.text
            PivotY_ = self.gds_validate_string(PivotY_, node, 'PivotY')
            self.PivotY.append(PivotY_)
# end class RadialGaugeType


class LinearGaugeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ActionInfo=None, ToolTip=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Hidden=None, ParentItem=None, BackFrame=None, TopImage=None, ClipContent=None, AspectRatio=None, GaugeScales=None, Orientation=None):
        self.Name = _cast(None, Name)
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ParentItem is None:
            self.ParentItem = []
        else:
            self.ParentItem = ParentItem
        if BackFrame is None:
            self.BackFrame = []
        else:
            self.BackFrame = BackFrame
        if TopImage is None:
            self.TopImage = []
        else:
            self.TopImage = TopImage
        if ClipContent is None:
            self.ClipContent = []
        else:
            self.ClipContent = ClipContent
        if AspectRatio is None:
            self.AspectRatio = []
        else:
            self.AspectRatio = AspectRatio
        if GaugeScales is None:
            self.GaugeScales = []
        else:
            self.GaugeScales = GaugeScales
        if Orientation is None:
            self.Orientation = []
        else:
            self.Orientation = Orientation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LinearGaugeType.subclass:
            return LinearGaugeType.subclass(*args_, **kwargs_)
        else:
            return LinearGaugeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ParentItem(self): return self.ParentItem
    def set_ParentItem(self, ParentItem): self.ParentItem = ParentItem
    def add_ParentItem(self, value): self.ParentItem.append(value)
    def insert_ParentItem(self, index, value): self.ParentItem[index] = value
    def get_BackFrame(self): return self.BackFrame
    def set_BackFrame(self, BackFrame): self.BackFrame = BackFrame
    def add_BackFrame(self, value): self.BackFrame.append(value)
    def insert_BackFrame(self, index, value): self.BackFrame[index] = value
    def get_TopImage(self): return self.TopImage
    def set_TopImage(self, TopImage): self.TopImage = TopImage
    def add_TopImage(self, value): self.TopImage.append(value)
    def insert_TopImage(self, index, value): self.TopImage[index] = value
    def get_ClipContent(self): return self.ClipContent
    def set_ClipContent(self, ClipContent): self.ClipContent = ClipContent
    def add_ClipContent(self, value): self.ClipContent.append(value)
    def insert_ClipContent(self, index, value): self.ClipContent[index] = value
    def get_AspectRatio(self): return self.AspectRatio
    def set_AspectRatio(self, AspectRatio): self.AspectRatio = AspectRatio
    def add_AspectRatio(self, value): self.AspectRatio.append(value)
    def insert_AspectRatio(self, index, value): self.AspectRatio[index] = value
    def get_GaugeScales(self): return self.GaugeScales
    def set_GaugeScales(self, GaugeScales): self.GaugeScales = GaugeScales
    def add_GaugeScales(self, value): self.GaugeScales.append(value)
    def insert_GaugeScales(self, index, value): self.GaugeScales[index] = value
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def add_Orientation(self, value): self.Orientation.append(value)
    def insert_Orientation(self, index, value): self.Orientation[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LinearGaugeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearGaugeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearGaugeType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinearGaugeType', fromsubclass_=False):
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_string(quote_xml(ZIndex_).encode(ExternalEncoding), input_name='ZIndex'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('<%sParentItem>%s</%sParentItem>\n' % (namespace_, self.gds_format_string(quote_xml(ParentItem_).encode(ExternalEncoding), input_name='ParentItem'), namespace_))
        for BackFrame_ in self.BackFrame:
            BackFrame_.export(outfile, level, namespace_, name_='BackFrame')
        for TopImage_ in self.TopImage:
            TopImage_.export(outfile, level, namespace_, name_='TopImage')
        for ClipContent_ in self.ClipContent:
            showIndent(outfile, level)
            outfile.write('<%sClipContent>%s</%sClipContent>\n' % (namespace_, self.gds_format_string(quote_xml(ClipContent_).encode(ExternalEncoding), input_name='ClipContent'), namespace_))
        for AspectRatio_ in self.AspectRatio:
            showIndent(outfile, level)
            outfile.write('<%sAspectRatio>%s</%sAspectRatio>\n' % (namespace_, self.gds_format_string(quote_xml(AspectRatio_).encode(ExternalEncoding), input_name='AspectRatio'), namespace_))
        for GaugeScales_ in self.GaugeScales:
            GaugeScales_.export(outfile, level, namespace_, name_='GaugeScales')
        for Orientation_ in self.Orientation:
            showIndent(outfile, level)
            outfile.write('<%sOrientation>%s</%sOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(Orientation_).encode(ExternalEncoding), input_name='Orientation'), namespace_))
    def hasContent_(self):
        if (
            self.ActionInfo or
            self.ToolTip or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Hidden or
            self.ParentItem or
            self.BackFrame or
            self.TopImage or
            self.ClipContent or
            self.AspectRatio or
            self.GaugeScales or
            self.Orientation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearGaugeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ZIndex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentItem=[\n')
        level += 1
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ParentItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackFrame=[\n')
        level += 1
        for BackFrame_ in self.BackFrame:
            showIndent(outfile, level)
            outfile.write('model_.BackFrameType(\n')
            BackFrame_.exportLiteral(outfile, level, name_='BackFrameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TopImage=[\n')
        level += 1
        for TopImage_ in self.TopImage:
            showIndent(outfile, level)
            outfile.write('model_.TopImageType(\n')
            TopImage_.exportLiteral(outfile, level, name_='TopImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ClipContent=[\n')
        level += 1
        for ClipContent_ in self.ClipContent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ClipContent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AspectRatio=[\n')
        level += 1
        for AspectRatio_ in self.AspectRatio:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AspectRatio_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeScales=[\n')
        level += 1
        for GaugeScales_ in self.GaugeScales:
            showIndent(outfile, level)
            outfile.write('model_.LinearScalesType(\n')
            GaugeScales_.exportLiteral(outfile, level, name_='LinearScalesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Orientation=[\n')
        level += 1
        for Orientation_ in self.Orientation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Orientation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'ZIndex':
            ZIndex_ = child_.text
            ZIndex_ = self.gds_validate_string(ZIndex_, node, 'ZIndex')
            self.ZIndex.append(ZIndex_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ParentItem':
            ParentItem_ = child_.text
            ParentItem_ = self.gds_validate_string(ParentItem_, node, 'ParentItem')
            self.ParentItem.append(ParentItem_)
        elif nodeName_ == 'BackFrame':
            obj_ = BackFrameType.factory()
            obj_.build(child_)
            self.BackFrame.append(obj_)
        elif nodeName_ == 'TopImage':
            obj_ = TopImageType.factory()
            obj_.build(child_)
            self.TopImage.append(obj_)
        elif nodeName_ == 'ClipContent':
            ClipContent_ = child_.text
            ClipContent_ = self.gds_validate_string(ClipContent_, node, 'ClipContent')
            self.ClipContent.append(ClipContent_)
        elif nodeName_ == 'AspectRatio':
            AspectRatio_ = child_.text
            AspectRatio_ = self.gds_validate_string(AspectRatio_, node, 'AspectRatio')
            self.AspectRatio.append(AspectRatio_)
        elif nodeName_ == 'GaugeScales':
            obj_ = LinearScalesType.factory()
            obj_.build(child_)
            self.GaugeScales.append(obj_)
        elif nodeName_ == 'Orientation':
            Orientation_ = child_.text
            Orientation_ = self.gds_validate_string(Orientation_, node, 'Orientation')
            self.Orientation.append(Orientation_)
# end class LinearGaugeType


class NumericIndicatorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ActionInfo=None, ToolTip=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Hidden=None, ParentItem=None, Style=None, GaugeInputValue=None, MaximumValue=None, MinimumValue=None, NumericIndicatorRanges=None, ResizeMode=None, DecimalDigitColor=None, DecimalDigits=None, DigitColor=None, Digits=None, IndicatorStyle=None, LedDimColor=None, Multiplier=None, OffString=None, OutOfRangeString=None, SeparatorColor=None, SeparatorWidth=None, ShowDecimalPoint=None, ShowLeadingZeros=None, ShowSign=None, SnappingEnabled=None, SnappingInterval=None, UseFontPercent=None):
        self.Name = _cast(None, Name)
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ParentItem is None:
            self.ParentItem = []
        else:
            self.ParentItem = ParentItem
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if GaugeInputValue is None:
            self.GaugeInputValue = []
        else:
            self.GaugeInputValue = GaugeInputValue
        if MaximumValue is None:
            self.MaximumValue = []
        else:
            self.MaximumValue = MaximumValue
        if MinimumValue is None:
            self.MinimumValue = []
        else:
            self.MinimumValue = MinimumValue
        if NumericIndicatorRanges is None:
            self.NumericIndicatorRanges = []
        else:
            self.NumericIndicatorRanges = NumericIndicatorRanges
        if ResizeMode is None:
            self.ResizeMode = []
        else:
            self.ResizeMode = ResizeMode
        if DecimalDigitColor is None:
            self.DecimalDigitColor = []
        else:
            self.DecimalDigitColor = DecimalDigitColor
        if DecimalDigits is None:
            self.DecimalDigits = []
        else:
            self.DecimalDigits = DecimalDigits
        if DigitColor is None:
            self.DigitColor = []
        else:
            self.DigitColor = DigitColor
        if Digits is None:
            self.Digits = []
        else:
            self.Digits = Digits
        if IndicatorStyle is None:
            self.IndicatorStyle = []
        else:
            self.IndicatorStyle = IndicatorStyle
        if LedDimColor is None:
            self.LedDimColor = []
        else:
            self.LedDimColor = LedDimColor
        if Multiplier is None:
            self.Multiplier = []
        else:
            self.Multiplier = Multiplier
        if OffString is None:
            self.OffString = []
        else:
            self.OffString = OffString
        if OutOfRangeString is None:
            self.OutOfRangeString = []
        else:
            self.OutOfRangeString = OutOfRangeString
        if SeparatorColor is None:
            self.SeparatorColor = []
        else:
            self.SeparatorColor = SeparatorColor
        if SeparatorWidth is None:
            self.SeparatorWidth = []
        else:
            self.SeparatorWidth = SeparatorWidth
        if ShowDecimalPoint is None:
            self.ShowDecimalPoint = []
        else:
            self.ShowDecimalPoint = ShowDecimalPoint
        if ShowLeadingZeros is None:
            self.ShowLeadingZeros = []
        else:
            self.ShowLeadingZeros = ShowLeadingZeros
        if ShowSign is None:
            self.ShowSign = []
        else:
            self.ShowSign = ShowSign
        if SnappingEnabled is None:
            self.SnappingEnabled = []
        else:
            self.SnappingEnabled = SnappingEnabled
        if SnappingInterval is None:
            self.SnappingInterval = []
        else:
            self.SnappingInterval = SnappingInterval
        if UseFontPercent is None:
            self.UseFontPercent = []
        else:
            self.UseFontPercent = UseFontPercent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NumericIndicatorType.subclass:
            return NumericIndicatorType.subclass(*args_, **kwargs_)
        else:
            return NumericIndicatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ParentItem(self): return self.ParentItem
    def set_ParentItem(self, ParentItem): self.ParentItem = ParentItem
    def add_ParentItem(self, value): self.ParentItem.append(value)
    def insert_ParentItem(self, index, value): self.ParentItem[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_GaugeInputValue(self): return self.GaugeInputValue
    def set_GaugeInputValue(self, GaugeInputValue): self.GaugeInputValue = GaugeInputValue
    def add_GaugeInputValue(self, value): self.GaugeInputValue.append(value)
    def insert_GaugeInputValue(self, index, value): self.GaugeInputValue[index] = value
    def get_MaximumValue(self): return self.MaximumValue
    def set_MaximumValue(self, MaximumValue): self.MaximumValue = MaximumValue
    def add_MaximumValue(self, value): self.MaximumValue.append(value)
    def insert_MaximumValue(self, index, value): self.MaximumValue[index] = value
    def get_MinimumValue(self): return self.MinimumValue
    def set_MinimumValue(self, MinimumValue): self.MinimumValue = MinimumValue
    def add_MinimumValue(self, value): self.MinimumValue.append(value)
    def insert_MinimumValue(self, index, value): self.MinimumValue[index] = value
    def get_NumericIndicatorRanges(self): return self.NumericIndicatorRanges
    def set_NumericIndicatorRanges(self, NumericIndicatorRanges): self.NumericIndicatorRanges = NumericIndicatorRanges
    def add_NumericIndicatorRanges(self, value): self.NumericIndicatorRanges.append(value)
    def insert_NumericIndicatorRanges(self, index, value): self.NumericIndicatorRanges[index] = value
    def get_ResizeMode(self): return self.ResizeMode
    def set_ResizeMode(self, ResizeMode): self.ResizeMode = ResizeMode
    def add_ResizeMode(self, value): self.ResizeMode.append(value)
    def insert_ResizeMode(self, index, value): self.ResizeMode[index] = value
    def get_DecimalDigitColor(self): return self.DecimalDigitColor
    def set_DecimalDigitColor(self, DecimalDigitColor): self.DecimalDigitColor = DecimalDigitColor
    def add_DecimalDigitColor(self, value): self.DecimalDigitColor.append(value)
    def insert_DecimalDigitColor(self, index, value): self.DecimalDigitColor[index] = value
    def get_DecimalDigits(self): return self.DecimalDigits
    def set_DecimalDigits(self, DecimalDigits): self.DecimalDigits = DecimalDigits
    def add_DecimalDigits(self, value): self.DecimalDigits.append(value)
    def insert_DecimalDigits(self, index, value): self.DecimalDigits[index] = value
    def get_DigitColor(self): return self.DigitColor
    def set_DigitColor(self, DigitColor): self.DigitColor = DigitColor
    def add_DigitColor(self, value): self.DigitColor.append(value)
    def insert_DigitColor(self, index, value): self.DigitColor[index] = value
    def get_Digits(self): return self.Digits
    def set_Digits(self, Digits): self.Digits = Digits
    def add_Digits(self, value): self.Digits.append(value)
    def insert_Digits(self, index, value): self.Digits[index] = value
    def get_IndicatorStyle(self): return self.IndicatorStyle
    def set_IndicatorStyle(self, IndicatorStyle): self.IndicatorStyle = IndicatorStyle
    def add_IndicatorStyle(self, value): self.IndicatorStyle.append(value)
    def insert_IndicatorStyle(self, index, value): self.IndicatorStyle[index] = value
    def get_LedDimColor(self): return self.LedDimColor
    def set_LedDimColor(self, LedDimColor): self.LedDimColor = LedDimColor
    def add_LedDimColor(self, value): self.LedDimColor.append(value)
    def insert_LedDimColor(self, index, value): self.LedDimColor[index] = value
    def get_Multiplier(self): return self.Multiplier
    def set_Multiplier(self, Multiplier): self.Multiplier = Multiplier
    def add_Multiplier(self, value): self.Multiplier.append(value)
    def insert_Multiplier(self, index, value): self.Multiplier[index] = value
    def get_OffString(self): return self.OffString
    def set_OffString(self, OffString): self.OffString = OffString
    def add_OffString(self, value): self.OffString.append(value)
    def insert_OffString(self, index, value): self.OffString[index] = value
    def get_OutOfRangeString(self): return self.OutOfRangeString
    def set_OutOfRangeString(self, OutOfRangeString): self.OutOfRangeString = OutOfRangeString
    def add_OutOfRangeString(self, value): self.OutOfRangeString.append(value)
    def insert_OutOfRangeString(self, index, value): self.OutOfRangeString[index] = value
    def get_SeparatorColor(self): return self.SeparatorColor
    def set_SeparatorColor(self, SeparatorColor): self.SeparatorColor = SeparatorColor
    def add_SeparatorColor(self, value): self.SeparatorColor.append(value)
    def insert_SeparatorColor(self, index, value): self.SeparatorColor[index] = value
    def get_SeparatorWidth(self): return self.SeparatorWidth
    def set_SeparatorWidth(self, SeparatorWidth): self.SeparatorWidth = SeparatorWidth
    def add_SeparatorWidth(self, value): self.SeparatorWidth.append(value)
    def insert_SeparatorWidth(self, index, value): self.SeparatorWidth[index] = value
    def get_ShowDecimalPoint(self): return self.ShowDecimalPoint
    def set_ShowDecimalPoint(self, ShowDecimalPoint): self.ShowDecimalPoint = ShowDecimalPoint
    def add_ShowDecimalPoint(self, value): self.ShowDecimalPoint.append(value)
    def insert_ShowDecimalPoint(self, index, value): self.ShowDecimalPoint[index] = value
    def get_ShowLeadingZeros(self): return self.ShowLeadingZeros
    def set_ShowLeadingZeros(self, ShowLeadingZeros): self.ShowLeadingZeros = ShowLeadingZeros
    def add_ShowLeadingZeros(self, value): self.ShowLeadingZeros.append(value)
    def insert_ShowLeadingZeros(self, index, value): self.ShowLeadingZeros[index] = value
    def get_ShowSign(self): return self.ShowSign
    def set_ShowSign(self, ShowSign): self.ShowSign = ShowSign
    def add_ShowSign(self, value): self.ShowSign.append(value)
    def insert_ShowSign(self, index, value): self.ShowSign[index] = value
    def get_SnappingEnabled(self): return self.SnappingEnabled
    def set_SnappingEnabled(self, SnappingEnabled): self.SnappingEnabled = SnappingEnabled
    def add_SnappingEnabled(self, value): self.SnappingEnabled.append(value)
    def insert_SnappingEnabled(self, index, value): self.SnappingEnabled[index] = value
    def get_SnappingInterval(self): return self.SnappingInterval
    def set_SnappingInterval(self, SnappingInterval): self.SnappingInterval = SnappingInterval
    def add_SnappingInterval(self, value): self.SnappingInterval.append(value)
    def insert_SnappingInterval(self, index, value): self.SnappingInterval[index] = value
    def get_UseFontPercent(self): return self.UseFontPercent
    def set_UseFontPercent(self, UseFontPercent): self.UseFontPercent = UseFontPercent
    def add_UseFontPercent(self, value): self.UseFontPercent.append(value)
    def insert_UseFontPercent(self, index, value): self.UseFontPercent[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NumericIndicatorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumericIndicatorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumericIndicatorType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumericIndicatorType', fromsubclass_=False):
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_string(quote_xml(ZIndex_).encode(ExternalEncoding), input_name='ZIndex'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('<%sParentItem>%s</%sParentItem>\n' % (namespace_, self.gds_format_string(quote_xml(ParentItem_).encode(ExternalEncoding), input_name='ParentItem'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for GaugeInputValue_ in self.GaugeInputValue:
            GaugeInputValue_.export(outfile, level, namespace_, name_='GaugeInputValue')
        for MaximumValue_ in self.MaximumValue:
            MaximumValue_.export(outfile, level, namespace_, name_='MaximumValue')
        for MinimumValue_ in self.MinimumValue:
            MinimumValue_.export(outfile, level, namespace_, name_='MinimumValue')
        for NumericIndicatorRanges_ in self.NumericIndicatorRanges:
            NumericIndicatorRanges_.export(outfile, level, namespace_, name_='NumericIndicatorRanges')
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('<%sResizeMode>%s</%sResizeMode>\n' % (namespace_, self.gds_format_string(quote_xml(ResizeMode_).encode(ExternalEncoding), input_name='ResizeMode'), namespace_))
        for DecimalDigitColor_ in self.DecimalDigitColor:
            showIndent(outfile, level)
            outfile.write('<%sDecimalDigitColor>%s</%sDecimalDigitColor>\n' % (namespace_, self.gds_format_string(quote_xml(DecimalDigitColor_).encode(ExternalEncoding), input_name='DecimalDigitColor'), namespace_))
        for DecimalDigits_ in self.DecimalDigits:
            showIndent(outfile, level)
            outfile.write('<%sDecimalDigits>%s</%sDecimalDigits>\n' % (namespace_, self.gds_format_string(quote_xml(DecimalDigits_).encode(ExternalEncoding), input_name='DecimalDigits'), namespace_))
        for DigitColor_ in self.DigitColor:
            showIndent(outfile, level)
            outfile.write('<%sDigitColor>%s</%sDigitColor>\n' % (namespace_, self.gds_format_string(quote_xml(DigitColor_).encode(ExternalEncoding), input_name='DigitColor'), namespace_))
        for Digits_ in self.Digits:
            showIndent(outfile, level)
            outfile.write('<%sDigits>%s</%sDigits>\n' % (namespace_, self.gds_format_string(quote_xml(Digits_).encode(ExternalEncoding), input_name='Digits'), namespace_))
        for IndicatorStyle_ in self.IndicatorStyle:
            showIndent(outfile, level)
            outfile.write('<%sIndicatorStyle>%s</%sIndicatorStyle>\n' % (namespace_, self.gds_format_string(quote_xml(IndicatorStyle_).encode(ExternalEncoding), input_name='IndicatorStyle'), namespace_))
        for LedDimColor_ in self.LedDimColor:
            showIndent(outfile, level)
            outfile.write('<%sLedDimColor>%s</%sLedDimColor>\n' % (namespace_, self.gds_format_string(quote_xml(LedDimColor_).encode(ExternalEncoding), input_name='LedDimColor'), namespace_))
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('<%sMultiplier>%s</%sMultiplier>\n' % (namespace_, self.gds_format_string(quote_xml(Multiplier_).encode(ExternalEncoding), input_name='Multiplier'), namespace_))
        for OffString_ in self.OffString:
            showIndent(outfile, level)
            outfile.write('<%sOffString>%s</%sOffString>\n' % (namespace_, self.gds_format_string(quote_xml(OffString_).encode(ExternalEncoding), input_name='OffString'), namespace_))
        for OutOfRangeString_ in self.OutOfRangeString:
            showIndent(outfile, level)
            outfile.write('<%sOutOfRangeString>%s</%sOutOfRangeString>\n' % (namespace_, self.gds_format_string(quote_xml(OutOfRangeString_).encode(ExternalEncoding), input_name='OutOfRangeString'), namespace_))
        for SeparatorColor_ in self.SeparatorColor:
            showIndent(outfile, level)
            outfile.write('<%sSeparatorColor>%s</%sSeparatorColor>\n' % (namespace_, self.gds_format_string(quote_xml(SeparatorColor_).encode(ExternalEncoding), input_name='SeparatorColor'), namespace_))
        for SeparatorWidth_ in self.SeparatorWidth:
            showIndent(outfile, level)
            outfile.write('<%sSeparatorWidth>%s</%sSeparatorWidth>\n' % (namespace_, self.gds_format_string(quote_xml(SeparatorWidth_).encode(ExternalEncoding), input_name='SeparatorWidth'), namespace_))
        for ShowDecimalPoint_ in self.ShowDecimalPoint:
            showIndent(outfile, level)
            outfile.write('<%sShowDecimalPoint>%s</%sShowDecimalPoint>\n' % (namespace_, self.gds_format_string(quote_xml(ShowDecimalPoint_).encode(ExternalEncoding), input_name='ShowDecimalPoint'), namespace_))
        for ShowLeadingZeros_ in self.ShowLeadingZeros:
            showIndent(outfile, level)
            outfile.write('<%sShowLeadingZeros>%s</%sShowLeadingZeros>\n' % (namespace_, self.gds_format_string(quote_xml(ShowLeadingZeros_).encode(ExternalEncoding), input_name='ShowLeadingZeros'), namespace_))
        for ShowSign_ in self.ShowSign:
            showIndent(outfile, level)
            outfile.write('<%sShowSign>%s</%sShowSign>\n' % (namespace_, self.gds_format_string(quote_xml(ShowSign_).encode(ExternalEncoding), input_name='ShowSign'), namespace_))
        for SnappingEnabled_ in self.SnappingEnabled:
            showIndent(outfile, level)
            outfile.write('<%sSnappingEnabled>%s</%sSnappingEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(SnappingEnabled_).encode(ExternalEncoding), input_name='SnappingEnabled'), namespace_))
        for SnappingInterval_ in self.SnappingInterval:
            showIndent(outfile, level)
            outfile.write('<%sSnappingInterval>%s</%sSnappingInterval>\n' % (namespace_, self.gds_format_string(quote_xml(SnappingInterval_).encode(ExternalEncoding), input_name='SnappingInterval'), namespace_))
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('<%sUseFontPercent>%s</%sUseFontPercent>\n' % (namespace_, self.gds_format_string(quote_xml(UseFontPercent_).encode(ExternalEncoding), input_name='UseFontPercent'), namespace_))
    def hasContent_(self):
        if (
            self.ActionInfo or
            self.ToolTip or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Hidden or
            self.ParentItem or
            self.Style or
            self.GaugeInputValue or
            self.MaximumValue or
            self.MinimumValue or
            self.NumericIndicatorRanges or
            self.ResizeMode or
            self.DecimalDigitColor or
            self.DecimalDigits or
            self.DigitColor or
            self.Digits or
            self.IndicatorStyle or
            self.LedDimColor or
            self.Multiplier or
            self.OffString or
            self.OutOfRangeString or
            self.SeparatorColor or
            self.SeparatorWidth or
            self.ShowDecimalPoint or
            self.ShowLeadingZeros or
            self.ShowSign or
            self.SnappingEnabled or
            self.SnappingInterval or
            self.UseFontPercent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumericIndicatorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ZIndex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentItem=[\n')
        level += 1
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ParentItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeInputValue=[\n')
        level += 1
        for GaugeInputValue_ in self.GaugeInputValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            GaugeInputValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaximumValue=[\n')
        level += 1
        for MaximumValue_ in self.MaximumValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            MaximumValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinimumValue=[\n')
        level += 1
        for MinimumValue_ in self.MinimumValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            MinimumValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NumericIndicatorRanges=[\n')
        level += 1
        for NumericIndicatorRanges_ in self.NumericIndicatorRanges:
            showIndent(outfile, level)
            outfile.write('model_.NumericIndicatorRangesType(\n')
            NumericIndicatorRanges_.exportLiteral(outfile, level, name_='NumericIndicatorRangesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ResizeMode=[\n')
        level += 1
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ResizeMode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DecimalDigitColor=[\n')
        level += 1
        for DecimalDigitColor_ in self.DecimalDigitColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DecimalDigitColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DecimalDigits=[\n')
        level += 1
        for DecimalDigits_ in self.DecimalDigits:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DecimalDigits_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DigitColor=[\n')
        level += 1
        for DigitColor_ in self.DigitColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DigitColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Digits=[\n')
        level += 1
        for Digits_ in self.Digits:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Digits_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IndicatorStyle=[\n')
        level += 1
        for IndicatorStyle_ in self.IndicatorStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IndicatorStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LedDimColor=[\n')
        level += 1
        for LedDimColor_ in self.LedDimColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LedDimColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Multiplier=[\n')
        level += 1
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Multiplier_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffString=[\n')
        level += 1
        for OffString_ in self.OffString:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OffString_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OutOfRangeString=[\n')
        level += 1
        for OutOfRangeString_ in self.OutOfRangeString:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OutOfRangeString_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SeparatorColor=[\n')
        level += 1
        for SeparatorColor_ in self.SeparatorColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SeparatorColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SeparatorWidth=[\n')
        level += 1
        for SeparatorWidth_ in self.SeparatorWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SeparatorWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShowDecimalPoint=[\n')
        level += 1
        for ShowDecimalPoint_ in self.ShowDecimalPoint:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShowDecimalPoint_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShowLeadingZeros=[\n')
        level += 1
        for ShowLeadingZeros_ in self.ShowLeadingZeros:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShowLeadingZeros_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShowSign=[\n')
        level += 1
        for ShowSign_ in self.ShowSign:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShowSign_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnappingEnabled=[\n')
        level += 1
        for SnappingEnabled_ in self.SnappingEnabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SnappingEnabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnappingInterval=[\n')
        level += 1
        for SnappingInterval_ in self.SnappingInterval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SnappingInterval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseFontPercent=[\n')
        level += 1
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseFontPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'ZIndex':
            ZIndex_ = child_.text
            ZIndex_ = self.gds_validate_string(ZIndex_, node, 'ZIndex')
            self.ZIndex.append(ZIndex_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ParentItem':
            ParentItem_ = child_.text
            ParentItem_ = self.gds_validate_string(ParentItem_, node, 'ParentItem')
            self.ParentItem.append(ParentItem_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'GaugeInputValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.GaugeInputValue.append(obj_)
        elif nodeName_ == 'MaximumValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.MaximumValue.append(obj_)
        elif nodeName_ == 'MinimumValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.MinimumValue.append(obj_)
        elif nodeName_ == 'NumericIndicatorRanges':
            obj_ = NumericIndicatorRangesType.factory()
            obj_.build(child_)
            self.NumericIndicatorRanges.append(obj_)
        elif nodeName_ == 'ResizeMode':
            ResizeMode_ = child_.text
            ResizeMode_ = self.gds_validate_string(ResizeMode_, node, 'ResizeMode')
            self.ResizeMode.append(ResizeMode_)
        elif nodeName_ == 'DecimalDigitColor':
            DecimalDigitColor_ = child_.text
            DecimalDigitColor_ = self.gds_validate_string(DecimalDigitColor_, node, 'DecimalDigitColor')
            self.DecimalDigitColor.append(DecimalDigitColor_)
        elif nodeName_ == 'DecimalDigits':
            DecimalDigits_ = child_.text
            DecimalDigits_ = self.gds_validate_string(DecimalDigits_, node, 'DecimalDigits')
            self.DecimalDigits.append(DecimalDigits_)
        elif nodeName_ == 'DigitColor':
            DigitColor_ = child_.text
            DigitColor_ = self.gds_validate_string(DigitColor_, node, 'DigitColor')
            self.DigitColor.append(DigitColor_)
        elif nodeName_ == 'Digits':
            Digits_ = child_.text
            Digits_ = self.gds_validate_string(Digits_, node, 'Digits')
            self.Digits.append(Digits_)
        elif nodeName_ == 'IndicatorStyle':
            IndicatorStyle_ = child_.text
            IndicatorStyle_ = self.gds_validate_string(IndicatorStyle_, node, 'IndicatorStyle')
            self.IndicatorStyle.append(IndicatorStyle_)
        elif nodeName_ == 'LedDimColor':
            LedDimColor_ = child_.text
            LedDimColor_ = self.gds_validate_string(LedDimColor_, node, 'LedDimColor')
            self.LedDimColor.append(LedDimColor_)
        elif nodeName_ == 'Multiplier':
            Multiplier_ = child_.text
            Multiplier_ = self.gds_validate_string(Multiplier_, node, 'Multiplier')
            self.Multiplier.append(Multiplier_)
        elif nodeName_ == 'OffString':
            OffString_ = child_.text
            OffString_ = self.gds_validate_string(OffString_, node, 'OffString')
            self.OffString.append(OffString_)
        elif nodeName_ == 'OutOfRangeString':
            OutOfRangeString_ = child_.text
            OutOfRangeString_ = self.gds_validate_string(OutOfRangeString_, node, 'OutOfRangeString')
            self.OutOfRangeString.append(OutOfRangeString_)
        elif nodeName_ == 'SeparatorColor':
            SeparatorColor_ = child_.text
            SeparatorColor_ = self.gds_validate_string(SeparatorColor_, node, 'SeparatorColor')
            self.SeparatorColor.append(SeparatorColor_)
        elif nodeName_ == 'SeparatorWidth':
            SeparatorWidth_ = child_.text
            SeparatorWidth_ = self.gds_validate_string(SeparatorWidth_, node, 'SeparatorWidth')
            self.SeparatorWidth.append(SeparatorWidth_)
        elif nodeName_ == 'ShowDecimalPoint':
            ShowDecimalPoint_ = child_.text
            ShowDecimalPoint_ = self.gds_validate_string(ShowDecimalPoint_, node, 'ShowDecimalPoint')
            self.ShowDecimalPoint.append(ShowDecimalPoint_)
        elif nodeName_ == 'ShowLeadingZeros':
            ShowLeadingZeros_ = child_.text
            ShowLeadingZeros_ = self.gds_validate_string(ShowLeadingZeros_, node, 'ShowLeadingZeros')
            self.ShowLeadingZeros.append(ShowLeadingZeros_)
        elif nodeName_ == 'ShowSign':
            ShowSign_ = child_.text
            ShowSign_ = self.gds_validate_string(ShowSign_, node, 'ShowSign')
            self.ShowSign.append(ShowSign_)
        elif nodeName_ == 'SnappingEnabled':
            SnappingEnabled_ = child_.text
            SnappingEnabled_ = self.gds_validate_string(SnappingEnabled_, node, 'SnappingEnabled')
            self.SnappingEnabled.append(SnappingEnabled_)
        elif nodeName_ == 'SnappingInterval':
            SnappingInterval_ = child_.text
            SnappingInterval_ = self.gds_validate_string(SnappingInterval_, node, 'SnappingInterval')
            self.SnappingInterval.append(SnappingInterval_)
        elif nodeName_ == 'UseFontPercent':
            UseFontPercent_ = child_.text
            UseFontPercent_ = self.gds_validate_string(UseFontPercent_, node, 'UseFontPercent')
            self.UseFontPercent.append(UseFontPercent_)
# end class NumericIndicatorType


class StateIndicatorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ActionInfo=None, ToolTip=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Hidden=None, ParentItem=None, Style=None, GaugeInputValue=None, IndicatorStates=None, StateImage=None, ResizeMode=None, Angle=None, IndicatorStyle=None, Text=None, UseFontPercent=None):
        self.Name = _cast(None, Name)
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ParentItem is None:
            self.ParentItem = []
        else:
            self.ParentItem = ParentItem
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if GaugeInputValue is None:
            self.GaugeInputValue = []
        else:
            self.GaugeInputValue = GaugeInputValue
        if IndicatorStates is None:
            self.IndicatorStates = []
        else:
            self.IndicatorStates = IndicatorStates
        if StateImage is None:
            self.StateImage = []
        else:
            self.StateImage = StateImage
        if ResizeMode is None:
            self.ResizeMode = []
        else:
            self.ResizeMode = ResizeMode
        if Angle is None:
            self.Angle = []
        else:
            self.Angle = Angle
        if IndicatorStyle is None:
            self.IndicatorStyle = []
        else:
            self.IndicatorStyle = IndicatorStyle
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if UseFontPercent is None:
            self.UseFontPercent = []
        else:
            self.UseFontPercent = UseFontPercent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if StateIndicatorType.subclass:
            return StateIndicatorType.subclass(*args_, **kwargs_)
        else:
            return StateIndicatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ParentItem(self): return self.ParentItem
    def set_ParentItem(self, ParentItem): self.ParentItem = ParentItem
    def add_ParentItem(self, value): self.ParentItem.append(value)
    def insert_ParentItem(self, index, value): self.ParentItem[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_GaugeInputValue(self): return self.GaugeInputValue
    def set_GaugeInputValue(self, GaugeInputValue): self.GaugeInputValue = GaugeInputValue
    def add_GaugeInputValue(self, value): self.GaugeInputValue.append(value)
    def insert_GaugeInputValue(self, index, value): self.GaugeInputValue[index] = value
    def get_IndicatorStates(self): return self.IndicatorStates
    def set_IndicatorStates(self, IndicatorStates): self.IndicatorStates = IndicatorStates
    def add_IndicatorStates(self, value): self.IndicatorStates.append(value)
    def insert_IndicatorStates(self, index, value): self.IndicatorStates[index] = value
    def get_StateImage(self): return self.StateImage
    def set_StateImage(self, StateImage): self.StateImage = StateImage
    def add_StateImage(self, value): self.StateImage.append(value)
    def insert_StateImage(self, index, value): self.StateImage[index] = value
    def get_ResizeMode(self): return self.ResizeMode
    def set_ResizeMode(self, ResizeMode): self.ResizeMode = ResizeMode
    def add_ResizeMode(self, value): self.ResizeMode.append(value)
    def insert_ResizeMode(self, index, value): self.ResizeMode[index] = value
    def get_Angle(self): return self.Angle
    def set_Angle(self, Angle): self.Angle = Angle
    def add_Angle(self, value): self.Angle.append(value)
    def insert_Angle(self, index, value): self.Angle[index] = value
    def get_IndicatorStyle(self): return self.IndicatorStyle
    def set_IndicatorStyle(self, IndicatorStyle): self.IndicatorStyle = IndicatorStyle
    def add_IndicatorStyle(self, value): self.IndicatorStyle.append(value)
    def insert_IndicatorStyle(self, index, value): self.IndicatorStyle[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_UseFontPercent(self): return self.UseFontPercent
    def set_UseFontPercent(self, UseFontPercent): self.UseFontPercent = UseFontPercent
    def add_UseFontPercent(self, value): self.UseFontPercent.append(value)
    def insert_UseFontPercent(self, index, value): self.UseFontPercent[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='StateIndicatorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateIndicatorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateIndicatorType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StateIndicatorType', fromsubclass_=False):
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_string(quote_xml(ZIndex_).encode(ExternalEncoding), input_name='ZIndex'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('<%sParentItem>%s</%sParentItem>\n' % (namespace_, self.gds_format_string(quote_xml(ParentItem_).encode(ExternalEncoding), input_name='ParentItem'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for GaugeInputValue_ in self.GaugeInputValue:
            GaugeInputValue_.export(outfile, level, namespace_, name_='GaugeInputValue')
        for IndicatorStates_ in self.IndicatorStates:
            IndicatorStates_.export(outfile, level, namespace_, name_='IndicatorStates')
        for StateImage_ in self.StateImage:
            StateImage_.export(outfile, level, namespace_, name_='StateImage')
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('<%sResizeMode>%s</%sResizeMode>\n' % (namespace_, self.gds_format_string(quote_xml(ResizeMode_).encode(ExternalEncoding), input_name='ResizeMode'), namespace_))
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('<%sAngle>%s</%sAngle>\n' % (namespace_, self.gds_format_string(quote_xml(Angle_).encode(ExternalEncoding), input_name='Angle'), namespace_))
        for IndicatorStyle_ in self.IndicatorStyle:
            showIndent(outfile, level)
            outfile.write('<%sIndicatorStyle>%s</%sIndicatorStyle>\n' % (namespace_, self.gds_format_string(quote_xml(IndicatorStyle_).encode(ExternalEncoding), input_name='IndicatorStyle'), namespace_))
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('<%sText>%s</%sText>\n' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_))
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('<%sUseFontPercent>%s</%sUseFontPercent>\n' % (namespace_, self.gds_format_string(quote_xml(UseFontPercent_).encode(ExternalEncoding), input_name='UseFontPercent'), namespace_))
    def hasContent_(self):
        if (
            self.ActionInfo or
            self.ToolTip or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Hidden or
            self.ParentItem or
            self.Style or
            self.GaugeInputValue or
            self.IndicatorStates or
            self.StateImage or
            self.ResizeMode or
            self.Angle or
            self.IndicatorStyle or
            self.Text or
            self.UseFontPercent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateIndicatorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ZIndex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentItem=[\n')
        level += 1
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ParentItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeInputValue=[\n')
        level += 1
        for GaugeInputValue_ in self.GaugeInputValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            GaugeInputValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IndicatorStates=[\n')
        level += 1
        for IndicatorStates_ in self.IndicatorStates:
            showIndent(outfile, level)
            outfile.write('model_.IndicatorStatesType(\n')
            IndicatorStates_.exportLiteral(outfile, level, name_='IndicatorStatesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StateImage=[\n')
        level += 1
        for StateImage_ in self.StateImage:
            showIndent(outfile, level)
            outfile.write('model_.StateImageType(\n')
            StateImage_.exportLiteral(outfile, level, name_='StateImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ResizeMode=[\n')
        level += 1
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ResizeMode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Angle=[\n')
        level += 1
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Angle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IndicatorStyle=[\n')
        level += 1
        for IndicatorStyle_ in self.IndicatorStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IndicatorStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseFontPercent=[\n')
        level += 1
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseFontPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'ZIndex':
            ZIndex_ = child_.text
            ZIndex_ = self.gds_validate_string(ZIndex_, node, 'ZIndex')
            self.ZIndex.append(ZIndex_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ParentItem':
            ParentItem_ = child_.text
            ParentItem_ = self.gds_validate_string(ParentItem_, node, 'ParentItem')
            self.ParentItem.append(ParentItem_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'GaugeInputValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.GaugeInputValue.append(obj_)
        elif nodeName_ == 'IndicatorStates':
            obj_ = IndicatorStatesType.factory()
            obj_.build(child_)
            self.IndicatorStates.append(obj_)
        elif nodeName_ == 'StateImage':
            obj_ = StateImageType.factory()
            obj_.build(child_)
            self.StateImage.append(obj_)
        elif nodeName_ == 'ResizeMode':
            ResizeMode_ = child_.text
            ResizeMode_ = self.gds_validate_string(ResizeMode_, node, 'ResizeMode')
            self.ResizeMode.append(ResizeMode_)
        elif nodeName_ == 'Angle':
            Angle_ = child_.text
            Angle_ = self.gds_validate_string(Angle_, node, 'Angle')
            self.Angle.append(Angle_)
        elif nodeName_ == 'IndicatorStyle':
            IndicatorStyle_ = child_.text
            IndicatorStyle_ = self.gds_validate_string(IndicatorStyle_, node, 'IndicatorStyle')
            self.IndicatorStyle.append(IndicatorStyle_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'UseFontPercent':
            UseFontPercent_ = child_.text
            UseFontPercent_ = self.gds_validate_string(UseFontPercent_, node, 'UseFontPercent')
            self.UseFontPercent.append(UseFontPercent_)
# end class StateIndicatorType


class GaugeImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ActionInfo=None, ToolTip=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Hidden=None, ParentItem=None, Source=None, Value=None, MIMEType=None, TransparentColor=None, Transparency=None, Angle=None, ResizeMode=None):
        self.Name = _cast(None, Name)
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ParentItem is None:
            self.ParentItem = []
        else:
            self.ParentItem = ParentItem
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if Transparency is None:
            self.Transparency = []
        else:
            self.Transparency = Transparency
        if Angle is None:
            self.Angle = []
        else:
            self.Angle = Angle
        if ResizeMode is None:
            self.ResizeMode = []
        else:
            self.ResizeMode = ResizeMode
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeImageType.subclass:
            return GaugeImageType.subclass(*args_, **kwargs_)
        else:
            return GaugeImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ParentItem(self): return self.ParentItem
    def set_ParentItem(self, ParentItem): self.ParentItem = ParentItem
    def add_ParentItem(self, value): self.ParentItem.append(value)
    def insert_ParentItem(self, index, value): self.ParentItem[index] = value
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_Transparency(self): return self.Transparency
    def set_Transparency(self, Transparency): self.Transparency = Transparency
    def add_Transparency(self, value): self.Transparency.append(value)
    def insert_Transparency(self, index, value): self.Transparency[index] = value
    def get_Angle(self): return self.Angle
    def set_Angle(self, Angle): self.Angle = Angle
    def add_Angle(self, value): self.Angle.append(value)
    def insert_Angle(self, index, value): self.Angle[index] = value
    def get_ResizeMode(self): return self.ResizeMode
    def set_ResizeMode(self, ResizeMode): self.ResizeMode = ResizeMode
    def add_ResizeMode(self, value): self.ResizeMode.append(value)
    def insert_ResizeMode(self, index, value): self.ResizeMode[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeImageType', fromsubclass_=False):
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_string(quote_xml(ZIndex_).encode(ExternalEncoding), input_name='ZIndex'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('<%sParentItem>%s</%sParentItem>\n' % (namespace_, self.gds_format_string(quote_xml(ParentItem_).encode(ExternalEncoding), input_name='ParentItem'), namespace_))
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('<%sTransparency>%s</%sTransparency>\n' % (namespace_, self.gds_format_string(quote_xml(Transparency_).encode(ExternalEncoding), input_name='Transparency'), namespace_))
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('<%sAngle>%s</%sAngle>\n' % (namespace_, self.gds_format_string(quote_xml(Angle_).encode(ExternalEncoding), input_name='Angle'), namespace_))
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('<%sResizeMode>%s</%sResizeMode>\n' % (namespace_, self.gds_format_string(quote_xml(ResizeMode_).encode(ExternalEncoding), input_name='ResizeMode'), namespace_))
    def hasContent_(self):
        if (
            self.ActionInfo or
            self.ToolTip or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Hidden or
            self.ParentItem or
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.Transparency or
            self.Angle or
            self.ResizeMode
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ZIndex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentItem=[\n')
        level += 1
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ParentItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Transparency=[\n')
        level += 1
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transparency_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Angle=[\n')
        level += 1
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Angle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ResizeMode=[\n')
        level += 1
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ResizeMode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'ZIndex':
            ZIndex_ = child_.text
            ZIndex_ = self.gds_validate_string(ZIndex_, node, 'ZIndex')
            self.ZIndex.append(ZIndex_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ParentItem':
            ParentItem_ = child_.text
            ParentItem_ = self.gds_validate_string(ParentItem_, node, 'ParentItem')
            self.ParentItem.append(ParentItem_)
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'Transparency':
            Transparency_ = child_.text
            Transparency_ = self.gds_validate_string(Transparency_, node, 'Transparency')
            self.Transparency.append(Transparency_)
        elif nodeName_ == 'Angle':
            Angle_ = child_.text
            Angle_ = self.gds_validate_string(Angle_, node, 'Angle')
            self.Angle.append(Angle_)
        elif nodeName_ == 'ResizeMode':
            ResizeMode_ = child_.text
            ResizeMode_ = self.gds_validate_string(ResizeMode_, node, 'ResizeMode')
            self.ResizeMode.append(ResizeMode_)
# end class GaugeImageType


class GaugeLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, ActionInfo=None, ToolTip=None, Top=None, Left=None, Height=None, Width=None, ZIndex=None, Hidden=None, ParentItem=None, Style=None, Text=None, Angle=None, ResizeMode=None, TextShadowOffset=None, UseFontPercent=None):
        self.Name = _cast(None, Name)
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if Top is None:
            self.Top = []
        else:
            self.Top = Top
        if Left is None:
            self.Left = []
        else:
            self.Left = Left
        if Height is None:
            self.Height = []
        else:
            self.Height = Height
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if ZIndex is None:
            self.ZIndex = []
        else:
            self.ZIndex = ZIndex
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if ParentItem is None:
            self.ParentItem = []
        else:
            self.ParentItem = ParentItem
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if Angle is None:
            self.Angle = []
        else:
            self.Angle = Angle
        if ResizeMode is None:
            self.ResizeMode = []
        else:
            self.ResizeMode = ResizeMode
        if TextShadowOffset is None:
            self.TextShadowOffset = []
        else:
            self.TextShadowOffset = TextShadowOffset
        if UseFontPercent is None:
            self.UseFontPercent = []
        else:
            self.UseFontPercent = UseFontPercent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeLabelType.subclass:
            return GaugeLabelType.subclass(*args_, **kwargs_)
        else:
            return GaugeLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_Top(self): return self.Top
    def set_Top(self, Top): self.Top = Top
    def add_Top(self, value): self.Top.append(value)
    def insert_Top(self, index, value): self.Top[index] = value
    def get_Left(self): return self.Left
    def set_Left(self, Left): self.Left = Left
    def add_Left(self, value): self.Left.append(value)
    def insert_Left(self, index, value): self.Left[index] = value
    def get_Height(self): return self.Height
    def set_Height(self, Height): self.Height = Height
    def add_Height(self, value): self.Height.append(value)
    def insert_Height(self, index, value): self.Height[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_ZIndex(self): return self.ZIndex
    def set_ZIndex(self, ZIndex): self.ZIndex = ZIndex
    def add_ZIndex(self, value): self.ZIndex.append(value)
    def insert_ZIndex(self, index, value): self.ZIndex[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_ParentItem(self): return self.ParentItem
    def set_ParentItem(self, ParentItem): self.ParentItem = ParentItem
    def add_ParentItem(self, value): self.ParentItem.append(value)
    def insert_ParentItem(self, index, value): self.ParentItem[index] = value
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_Angle(self): return self.Angle
    def set_Angle(self, Angle): self.Angle = Angle
    def add_Angle(self, value): self.Angle.append(value)
    def insert_Angle(self, index, value): self.Angle[index] = value
    def get_ResizeMode(self): return self.ResizeMode
    def set_ResizeMode(self, ResizeMode): self.ResizeMode = ResizeMode
    def add_ResizeMode(self, value): self.ResizeMode.append(value)
    def insert_ResizeMode(self, index, value): self.ResizeMode[index] = value
    def get_TextShadowOffset(self): return self.TextShadowOffset
    def set_TextShadowOffset(self, TextShadowOffset): self.TextShadowOffset = TextShadowOffset
    def add_TextShadowOffset(self, value): self.TextShadowOffset.append(value)
    def insert_TextShadowOffset(self, index, value): self.TextShadowOffset[index] = value
    def get_UseFontPercent(self): return self.UseFontPercent
    def set_UseFontPercent(self, UseFontPercent): self.UseFontPercent = UseFontPercent
    def add_UseFontPercent(self, value): self.UseFontPercent.append(value)
    def insert_UseFontPercent(self, index, value): self.UseFontPercent[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeLabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeLabelType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeLabelType', fromsubclass_=False):
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('<%sTop>%s</%sTop>\n' % (namespace_, self.gds_format_string(quote_xml(Top_).encode(ExternalEncoding), input_name='Top'), namespace_))
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('<%sLeft>%s</%sLeft>\n' % (namespace_, self.gds_format_string(quote_xml(Left_).encode(ExternalEncoding), input_name='Left'), namespace_))
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('<%sHeight>%s</%sHeight>\n' % (namespace_, self.gds_format_string(quote_xml(Height_).encode(ExternalEncoding), input_name='Height'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('<%sZIndex>%s</%sZIndex>\n' % (namespace_, self.gds_format_string(quote_xml(ZIndex_).encode(ExternalEncoding), input_name='ZIndex'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('<%sParentItem>%s</%sParentItem>\n' % (namespace_, self.gds_format_string(quote_xml(ParentItem_).encode(ExternalEncoding), input_name='ParentItem'), namespace_))
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('<%sText>%s</%sText>\n' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_))
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('<%sAngle>%s</%sAngle>\n' % (namespace_, self.gds_format_string(quote_xml(Angle_).encode(ExternalEncoding), input_name='Angle'), namespace_))
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('<%sResizeMode>%s</%sResizeMode>\n' % (namespace_, self.gds_format_string(quote_xml(ResizeMode_).encode(ExternalEncoding), input_name='ResizeMode'), namespace_))
        for TextShadowOffset_ in self.TextShadowOffset:
            showIndent(outfile, level)
            outfile.write('<%sTextShadowOffset>%s</%sTextShadowOffset>\n' % (namespace_, self.gds_format_string(quote_xml(TextShadowOffset_).encode(ExternalEncoding), input_name='TextShadowOffset'), namespace_))
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('<%sUseFontPercent>%s</%sUseFontPercent>\n' % (namespace_, self.gds_format_string(quote_xml(UseFontPercent_).encode(ExternalEncoding), input_name='UseFontPercent'), namespace_))
    def hasContent_(self):
        if (
            self.ActionInfo or
            self.ToolTip or
            self.Top or
            self.Left or
            self.Height or
            self.Width or
            self.ZIndex or
            self.Hidden or
            self.ParentItem or
            self.Style or
            self.Text or
            self.Angle or
            self.ResizeMode or
            self.TextShadowOffset or
            self.UseFontPercent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Top=[\n')
        level += 1
        for Top_ in self.Top:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Top_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Left=[\n')
        level += 1
        for Left_ in self.Left:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Left_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Height=[\n')
        level += 1
        for Height_ in self.Height:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Height_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ZIndex=[\n')
        level += 1
        for ZIndex_ in self.ZIndex:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ZIndex_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ParentItem=[\n')
        level += 1
        for ParentItem_ in self.ParentItem:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ParentItem_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Angle=[\n')
        level += 1
        for Angle_ in self.Angle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Angle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ResizeMode=[\n')
        level += 1
        for ResizeMode_ in self.ResizeMode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ResizeMode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TextShadowOffset=[\n')
        level += 1
        for TextShadowOffset_ in self.TextShadowOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TextShadowOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseFontPercent=[\n')
        level += 1
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseFontPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'Top':
            Top_ = child_.text
            Top_ = self.gds_validate_string(Top_, node, 'Top')
            self.Top.append(Top_)
        elif nodeName_ == 'Left':
            Left_ = child_.text
            Left_ = self.gds_validate_string(Left_, node, 'Left')
            self.Left.append(Left_)
        elif nodeName_ == 'Height':
            Height_ = child_.text
            Height_ = self.gds_validate_string(Height_, node, 'Height')
            self.Height.append(Height_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'ZIndex':
            ZIndex_ = child_.text
            ZIndex_ = self.gds_validate_string(ZIndex_, node, 'ZIndex')
            self.ZIndex.append(ZIndex_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'ParentItem':
            ParentItem_ = child_.text
            ParentItem_ = self.gds_validate_string(ParentItem_, node, 'ParentItem')
            self.ParentItem.append(ParentItem_)
        elif nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'Angle':
            Angle_ = child_.text
            Angle_ = self.gds_validate_string(Angle_, node, 'Angle')
            self.Angle.append(Angle_)
        elif nodeName_ == 'ResizeMode':
            ResizeMode_ = child_.text
            ResizeMode_ = self.gds_validate_string(ResizeMode_, node, 'ResizeMode')
            self.ResizeMode.append(ResizeMode_)
        elif nodeName_ == 'TextShadowOffset':
            TextShadowOffset_ = child_.text
            TextShadowOffset_ = self.gds_validate_string(TextShadowOffset_, node, 'TextShadowOffset')
            self.TextShadowOffset.append(TextShadowOffset_)
        elif nodeName_ == 'UseFontPercent':
            UseFontPercent_ = child_.text
            UseFontPercent_ = self.gds_validate_string(UseFontPercent_, node, 'UseFontPercent')
            self.UseFontPercent.append(UseFontPercent_)
# end class GaugeLabelType


class RadialScaleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, ToolTip=None, ScaleRanges=None, ScaleLabels=None, GaugeMajorTickMarks=None, GaugeMinorTickMarks=None, CustomLabels=None, MaximumValue=None, MinimumValue=None, MaximumPin=None, MinimumPin=None, Interval=None, IntervalOffset=None, Logarithmic=None, LogarithmicBase=None, Multiplier=None, Reversed=None, Hidden=None, Width=None, TickMarksOnTop=None, GaugePointers=None, Radius=None, StartAngle=None, SweepAngle=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ScaleRanges is None:
            self.ScaleRanges = []
        else:
            self.ScaleRanges = ScaleRanges
        if ScaleLabels is None:
            self.ScaleLabels = []
        else:
            self.ScaleLabels = ScaleLabels
        if GaugeMajorTickMarks is None:
            self.GaugeMajorTickMarks = []
        else:
            self.GaugeMajorTickMarks = GaugeMajorTickMarks
        if GaugeMinorTickMarks is None:
            self.GaugeMinorTickMarks = []
        else:
            self.GaugeMinorTickMarks = GaugeMinorTickMarks
        if CustomLabels is None:
            self.CustomLabels = []
        else:
            self.CustomLabels = CustomLabels
        if MaximumValue is None:
            self.MaximumValue = []
        else:
            self.MaximumValue = MaximumValue
        if MinimumValue is None:
            self.MinimumValue = []
        else:
            self.MinimumValue = MinimumValue
        if MaximumPin is None:
            self.MaximumPin = []
        else:
            self.MaximumPin = MaximumPin
        if MinimumPin is None:
            self.MinimumPin = []
        else:
            self.MinimumPin = MinimumPin
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if Logarithmic is None:
            self.Logarithmic = []
        else:
            self.Logarithmic = Logarithmic
        if LogarithmicBase is None:
            self.LogarithmicBase = []
        else:
            self.LogarithmicBase = LogarithmicBase
        if Multiplier is None:
            self.Multiplier = []
        else:
            self.Multiplier = Multiplier
        if Reversed is None:
            self.Reversed = []
        else:
            self.Reversed = Reversed
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if TickMarksOnTop is None:
            self.TickMarksOnTop = []
        else:
            self.TickMarksOnTop = TickMarksOnTop
        if GaugePointers is None:
            self.GaugePointers = []
        else:
            self.GaugePointers = GaugePointers
        if Radius is None:
            self.Radius = []
        else:
            self.Radius = Radius
        if StartAngle is None:
            self.StartAngle = []
        else:
            self.StartAngle = StartAngle
        if SweepAngle is None:
            self.SweepAngle = []
        else:
            self.SweepAngle = SweepAngle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RadialScaleType.subclass:
            return RadialScaleType.subclass(*args_, **kwargs_)
        else:
            return RadialScaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ScaleRanges(self): return self.ScaleRanges
    def set_ScaleRanges(self, ScaleRanges): self.ScaleRanges = ScaleRanges
    def add_ScaleRanges(self, value): self.ScaleRanges.append(value)
    def insert_ScaleRanges(self, index, value): self.ScaleRanges[index] = value
    def get_ScaleLabels(self): return self.ScaleLabels
    def set_ScaleLabels(self, ScaleLabels): self.ScaleLabels = ScaleLabels
    def add_ScaleLabels(self, value): self.ScaleLabels.append(value)
    def insert_ScaleLabels(self, index, value): self.ScaleLabels[index] = value
    def get_GaugeMajorTickMarks(self): return self.GaugeMajorTickMarks
    def set_GaugeMajorTickMarks(self, GaugeMajorTickMarks): self.GaugeMajorTickMarks = GaugeMajorTickMarks
    def add_GaugeMajorTickMarks(self, value): self.GaugeMajorTickMarks.append(value)
    def insert_GaugeMajorTickMarks(self, index, value): self.GaugeMajorTickMarks[index] = value
    def get_GaugeMinorTickMarks(self): return self.GaugeMinorTickMarks
    def set_GaugeMinorTickMarks(self, GaugeMinorTickMarks): self.GaugeMinorTickMarks = GaugeMinorTickMarks
    def add_GaugeMinorTickMarks(self, value): self.GaugeMinorTickMarks.append(value)
    def insert_GaugeMinorTickMarks(self, index, value): self.GaugeMinorTickMarks[index] = value
    def get_CustomLabels(self): return self.CustomLabels
    def set_CustomLabels(self, CustomLabels): self.CustomLabels = CustomLabels
    def add_CustomLabels(self, value): self.CustomLabels.append(value)
    def insert_CustomLabels(self, index, value): self.CustomLabels[index] = value
    def get_MaximumValue(self): return self.MaximumValue
    def set_MaximumValue(self, MaximumValue): self.MaximumValue = MaximumValue
    def add_MaximumValue(self, value): self.MaximumValue.append(value)
    def insert_MaximumValue(self, index, value): self.MaximumValue[index] = value
    def get_MinimumValue(self): return self.MinimumValue
    def set_MinimumValue(self, MinimumValue): self.MinimumValue = MinimumValue
    def add_MinimumValue(self, value): self.MinimumValue.append(value)
    def insert_MinimumValue(self, index, value): self.MinimumValue[index] = value
    def get_MaximumPin(self): return self.MaximumPin
    def set_MaximumPin(self, MaximumPin): self.MaximumPin = MaximumPin
    def add_MaximumPin(self, value): self.MaximumPin.append(value)
    def insert_MaximumPin(self, index, value): self.MaximumPin[index] = value
    def get_MinimumPin(self): return self.MinimumPin
    def set_MinimumPin(self, MinimumPin): self.MinimumPin = MinimumPin
    def add_MinimumPin(self, value): self.MinimumPin.append(value)
    def insert_MinimumPin(self, index, value): self.MinimumPin[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_Logarithmic(self): return self.Logarithmic
    def set_Logarithmic(self, Logarithmic): self.Logarithmic = Logarithmic
    def add_Logarithmic(self, value): self.Logarithmic.append(value)
    def insert_Logarithmic(self, index, value): self.Logarithmic[index] = value
    def get_LogarithmicBase(self): return self.LogarithmicBase
    def set_LogarithmicBase(self, LogarithmicBase): self.LogarithmicBase = LogarithmicBase
    def add_LogarithmicBase(self, value): self.LogarithmicBase.append(value)
    def insert_LogarithmicBase(self, index, value): self.LogarithmicBase[index] = value
    def get_Multiplier(self): return self.Multiplier
    def set_Multiplier(self, Multiplier): self.Multiplier = Multiplier
    def add_Multiplier(self, value): self.Multiplier.append(value)
    def insert_Multiplier(self, index, value): self.Multiplier[index] = value
    def get_Reversed(self): return self.Reversed
    def set_Reversed(self, Reversed): self.Reversed = Reversed
    def add_Reversed(self, value): self.Reversed.append(value)
    def insert_Reversed(self, index, value): self.Reversed[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_TickMarksOnTop(self): return self.TickMarksOnTop
    def set_TickMarksOnTop(self, TickMarksOnTop): self.TickMarksOnTop = TickMarksOnTop
    def add_TickMarksOnTop(self, value): self.TickMarksOnTop.append(value)
    def insert_TickMarksOnTop(self, index, value): self.TickMarksOnTop[index] = value
    def get_GaugePointers(self): return self.GaugePointers
    def set_GaugePointers(self, GaugePointers): self.GaugePointers = GaugePointers
    def add_GaugePointers(self, value): self.GaugePointers.append(value)
    def insert_GaugePointers(self, index, value): self.GaugePointers[index] = value
    def get_Radius(self): return self.Radius
    def set_Radius(self, Radius): self.Radius = Radius
    def add_Radius(self, value): self.Radius.append(value)
    def insert_Radius(self, index, value): self.Radius[index] = value
    def get_StartAngle(self): return self.StartAngle
    def set_StartAngle(self, StartAngle): self.StartAngle = StartAngle
    def add_StartAngle(self, value): self.StartAngle.append(value)
    def insert_StartAngle(self, index, value): self.StartAngle[index] = value
    def get_SweepAngle(self): return self.SweepAngle
    def set_SweepAngle(self, SweepAngle): self.SweepAngle = SweepAngle
    def add_SweepAngle(self, value): self.SweepAngle.append(value)
    def insert_SweepAngle(self, index, value): self.SweepAngle[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RadialScaleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialScaleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialScaleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RadialScaleType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for ScaleRanges_ in self.ScaleRanges:
            ScaleRanges_.export(outfile, level, namespace_, name_='ScaleRanges')
        for ScaleLabels_ in self.ScaleLabels:
            ScaleLabels_.export(outfile, level, namespace_, name_='ScaleLabels')
        for GaugeMajorTickMarks_ in self.GaugeMajorTickMarks:
            GaugeMajorTickMarks_.export(outfile, level, namespace_, name_='GaugeMajorTickMarks')
        for GaugeMinorTickMarks_ in self.GaugeMinorTickMarks:
            GaugeMinorTickMarks_.export(outfile, level, namespace_, name_='GaugeMinorTickMarks')
        for CustomLabels_ in self.CustomLabels:
            CustomLabels_.export(outfile, level, namespace_, name_='CustomLabels')
        for MaximumValue_ in self.MaximumValue:
            MaximumValue_.export(outfile, level, namespace_, name_='MaximumValue')
        for MinimumValue_ in self.MinimumValue:
            MinimumValue_.export(outfile, level, namespace_, name_='MinimumValue')
        for MaximumPin_ in self.MaximumPin:
            MaximumPin_.export(outfile, level, namespace_, name_='MaximumPin')
        for MinimumPin_ in self.MinimumPin:
            MinimumPin_.export(outfile, level, namespace_, name_='MinimumPin')
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for Logarithmic_ in self.Logarithmic:
            showIndent(outfile, level)
            outfile.write('<%sLogarithmic>%s</%sLogarithmic>\n' % (namespace_, self.gds_format_string(quote_xml(Logarithmic_).encode(ExternalEncoding), input_name='Logarithmic'), namespace_))
        for LogarithmicBase_ in self.LogarithmicBase:
            showIndent(outfile, level)
            outfile.write('<%sLogarithmicBase>%s</%sLogarithmicBase>\n' % (namespace_, self.gds_format_string(quote_xml(LogarithmicBase_).encode(ExternalEncoding), input_name='LogarithmicBase'), namespace_))
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('<%sMultiplier>%s</%sMultiplier>\n' % (namespace_, self.gds_format_string(quote_xml(Multiplier_).encode(ExternalEncoding), input_name='Multiplier'), namespace_))
        for Reversed_ in self.Reversed:
            showIndent(outfile, level)
            outfile.write('<%sReversed>%s</%sReversed>\n' % (namespace_, self.gds_format_string(quote_xml(Reversed_).encode(ExternalEncoding), input_name='Reversed'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for TickMarksOnTop_ in self.TickMarksOnTop:
            showIndent(outfile, level)
            outfile.write('<%sTickMarksOnTop>%s</%sTickMarksOnTop>\n' % (namespace_, self.gds_format_string(quote_xml(TickMarksOnTop_).encode(ExternalEncoding), input_name='TickMarksOnTop'), namespace_))
        for GaugePointers_ in self.GaugePointers:
            GaugePointers_.export(outfile, level, namespace_, name_='GaugePointers')
        for Radius_ in self.Radius:
            showIndent(outfile, level)
            outfile.write('<%sRadius>%s</%sRadius>\n' % (namespace_, self.gds_format_string(quote_xml(Radius_).encode(ExternalEncoding), input_name='Radius'), namespace_))
        for StartAngle_ in self.StartAngle:
            showIndent(outfile, level)
            outfile.write('<%sStartAngle>%s</%sStartAngle>\n' % (namespace_, self.gds_format_string(quote_xml(StartAngle_).encode(ExternalEncoding), input_name='StartAngle'), namespace_))
        for SweepAngle_ in self.SweepAngle:
            showIndent(outfile, level)
            outfile.write('<%sSweepAngle>%s</%sSweepAngle>\n' % (namespace_, self.gds_format_string(quote_xml(SweepAngle_).encode(ExternalEncoding), input_name='SweepAngle'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.ToolTip or
            self.ScaleRanges or
            self.ScaleLabels or
            self.GaugeMajorTickMarks or
            self.GaugeMinorTickMarks or
            self.CustomLabels or
            self.MaximumValue or
            self.MinimumValue or
            self.MaximumPin or
            self.MinimumPin or
            self.Interval or
            self.IntervalOffset or
            self.Logarithmic or
            self.LogarithmicBase or
            self.Multiplier or
            self.Reversed or
            self.Hidden or
            self.Width or
            self.TickMarksOnTop or
            self.GaugePointers or
            self.Radius or
            self.StartAngle or
            self.SweepAngle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RadialScaleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScaleRanges=[\n')
        level += 1
        for ScaleRanges_ in self.ScaleRanges:
            showIndent(outfile, level)
            outfile.write('model_.ScaleRangesType(\n')
            ScaleRanges_.exportLiteral(outfile, level, name_='ScaleRangesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScaleLabels=[\n')
        level += 1
        for ScaleLabels_ in self.ScaleLabels:
            showIndent(outfile, level)
            outfile.write('model_.ScaleLabelsType(\n')
            ScaleLabels_.exportLiteral(outfile, level, name_='ScaleLabelsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeMajorTickMarks=[\n')
        level += 1
        for GaugeMajorTickMarks_ in self.GaugeMajorTickMarks:
            showIndent(outfile, level)
            outfile.write('model_.GaugeTickMarksType(\n')
            GaugeMajorTickMarks_.exportLiteral(outfile, level, name_='GaugeTickMarksType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeMinorTickMarks=[\n')
        level += 1
        for GaugeMinorTickMarks_ in self.GaugeMinorTickMarks:
            showIndent(outfile, level)
            outfile.write('model_.GaugeTickMarksType(\n')
            GaugeMinorTickMarks_.exportLiteral(outfile, level, name_='GaugeTickMarksType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomLabels=[\n')
        level += 1
        for CustomLabels_ in self.CustomLabels:
            showIndent(outfile, level)
            outfile.write('model_.CustomLabelsType(\n')
            CustomLabels_.exportLiteral(outfile, level, name_='CustomLabelsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaximumValue=[\n')
        level += 1
        for MaximumValue_ in self.MaximumValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            MaximumValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinimumValue=[\n')
        level += 1
        for MinimumValue_ in self.MinimumValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            MinimumValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaximumPin=[\n')
        level += 1
        for MaximumPin_ in self.MaximumPin:
            showIndent(outfile, level)
            outfile.write('model_.ScalePinType(\n')
            MaximumPin_.exportLiteral(outfile, level, name_='ScalePinType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinimumPin=[\n')
        level += 1
        for MinimumPin_ in self.MinimumPin:
            showIndent(outfile, level)
            outfile.write('model_.ScalePinType(\n')
            MinimumPin_.exportLiteral(outfile, level, name_='ScalePinType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Logarithmic=[\n')
        level += 1
        for Logarithmic_ in self.Logarithmic:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Logarithmic_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LogarithmicBase=[\n')
        level += 1
        for LogarithmicBase_ in self.LogarithmicBase:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LogarithmicBase_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Multiplier=[\n')
        level += 1
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Multiplier_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Reversed=[\n')
        level += 1
        for Reversed_ in self.Reversed:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reversed_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TickMarksOnTop=[\n')
        level += 1
        for TickMarksOnTop_ in self.TickMarksOnTop:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TickMarksOnTop_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugePointers=[\n')
        level += 1
        for GaugePointers_ in self.GaugePointers:
            showIndent(outfile, level)
            outfile.write('model_.RadialPointersType(\n')
            GaugePointers_.exportLiteral(outfile, level, name_='RadialPointersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Radius=[\n')
        level += 1
        for Radius_ in self.Radius:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Radius_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StartAngle=[\n')
        level += 1
        for StartAngle_ in self.StartAngle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StartAngle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SweepAngle=[\n')
        level += 1
        for SweepAngle_ in self.SweepAngle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SweepAngle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'ScaleRanges':
            obj_ = ScaleRangesType.factory()
            obj_.build(child_)
            self.ScaleRanges.append(obj_)
        elif nodeName_ == 'ScaleLabels':
            obj_ = ScaleLabelsType.factory()
            obj_.build(child_)
            self.ScaleLabels.append(obj_)
        elif nodeName_ == 'GaugeMajorTickMarks':
            obj_ = GaugeTickMarksType.factory()
            obj_.build(child_)
            self.GaugeMajorTickMarks.append(obj_)
        elif nodeName_ == 'GaugeMinorTickMarks':
            obj_ = GaugeTickMarksType.factory()
            obj_.build(child_)
            self.GaugeMinorTickMarks.append(obj_)
        elif nodeName_ == 'CustomLabels':
            obj_ = CustomLabelsType.factory()
            obj_.build(child_)
            self.CustomLabels.append(obj_)
        elif nodeName_ == 'MaximumValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.MaximumValue.append(obj_)
        elif nodeName_ == 'MinimumValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.MinimumValue.append(obj_)
        elif nodeName_ == 'MaximumPin':
            obj_ = ScalePinType.factory()
            obj_.build(child_)
            self.MaximumPin.append(obj_)
        elif nodeName_ == 'MinimumPin':
            obj_ = ScalePinType.factory()
            obj_.build(child_)
            self.MinimumPin.append(obj_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'Logarithmic':
            Logarithmic_ = child_.text
            Logarithmic_ = self.gds_validate_string(Logarithmic_, node, 'Logarithmic')
            self.Logarithmic.append(Logarithmic_)
        elif nodeName_ == 'LogarithmicBase':
            LogarithmicBase_ = child_.text
            LogarithmicBase_ = self.gds_validate_string(LogarithmicBase_, node, 'LogarithmicBase')
            self.LogarithmicBase.append(LogarithmicBase_)
        elif nodeName_ == 'Multiplier':
            Multiplier_ = child_.text
            Multiplier_ = self.gds_validate_string(Multiplier_, node, 'Multiplier')
            self.Multiplier.append(Multiplier_)
        elif nodeName_ == 'Reversed':
            Reversed_ = child_.text
            Reversed_ = self.gds_validate_string(Reversed_, node, 'Reversed')
            self.Reversed.append(Reversed_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'TickMarksOnTop':
            TickMarksOnTop_ = child_.text
            TickMarksOnTop_ = self.gds_validate_string(TickMarksOnTop_, node, 'TickMarksOnTop')
            self.TickMarksOnTop.append(TickMarksOnTop_)
        elif nodeName_ == 'GaugePointers':
            obj_ = RadialPointersType.factory()
            obj_.build(child_)
            self.GaugePointers.append(obj_)
        elif nodeName_ == 'Radius':
            Radius_ = child_.text
            Radius_ = self.gds_validate_string(Radius_, node, 'Radius')
            self.Radius.append(Radius_)
        elif nodeName_ == 'StartAngle':
            StartAngle_ = child_.text
            StartAngle_ = self.gds_validate_string(StartAngle_, node, 'StartAngle')
            self.StartAngle.append(StartAngle_)
        elif nodeName_ == 'SweepAngle':
            SweepAngle_ = child_.text
            SweepAngle_ = self.gds_validate_string(SweepAngle_, node, 'SweepAngle')
            self.SweepAngle.append(SweepAngle_)
# end class RadialScaleType


class LinearScaleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, ToolTip=None, ScaleRanges=None, ScaleLabels=None, GaugeMajorTickMarks=None, GaugeMinorTickMarks=None, CustomLabels=None, MaximumValue=None, MinimumValue=None, MaximumPin=None, MinimumPin=None, Interval=None, IntervalOffset=None, Logarithmic=None, LogarithmicBase=None, Multiplier=None, Reversed=None, Hidden=None, Width=None, TickMarksOnTop=None, GaugePointers=None, StartMargin=None, EndMargin=None, Position=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if ScaleRanges is None:
            self.ScaleRanges = []
        else:
            self.ScaleRanges = ScaleRanges
        if ScaleLabels is None:
            self.ScaleLabels = []
        else:
            self.ScaleLabels = ScaleLabels
        if GaugeMajorTickMarks is None:
            self.GaugeMajorTickMarks = []
        else:
            self.GaugeMajorTickMarks = GaugeMajorTickMarks
        if GaugeMinorTickMarks is None:
            self.GaugeMinorTickMarks = []
        else:
            self.GaugeMinorTickMarks = GaugeMinorTickMarks
        if CustomLabels is None:
            self.CustomLabels = []
        else:
            self.CustomLabels = CustomLabels
        if MaximumValue is None:
            self.MaximumValue = []
        else:
            self.MaximumValue = MaximumValue
        if MinimumValue is None:
            self.MinimumValue = []
        else:
            self.MinimumValue = MinimumValue
        if MaximumPin is None:
            self.MaximumPin = []
        else:
            self.MaximumPin = MaximumPin
        if MinimumPin is None:
            self.MinimumPin = []
        else:
            self.MinimumPin = MinimumPin
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if Logarithmic is None:
            self.Logarithmic = []
        else:
            self.Logarithmic = Logarithmic
        if LogarithmicBase is None:
            self.LogarithmicBase = []
        else:
            self.LogarithmicBase = LogarithmicBase
        if Multiplier is None:
            self.Multiplier = []
        else:
            self.Multiplier = Multiplier
        if Reversed is None:
            self.Reversed = []
        else:
            self.Reversed = Reversed
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if TickMarksOnTop is None:
            self.TickMarksOnTop = []
        else:
            self.TickMarksOnTop = TickMarksOnTop
        if GaugePointers is None:
            self.GaugePointers = []
        else:
            self.GaugePointers = GaugePointers
        if StartMargin is None:
            self.StartMargin = []
        else:
            self.StartMargin = StartMargin
        if EndMargin is None:
            self.EndMargin = []
        else:
            self.EndMargin = EndMargin
        if Position is None:
            self.Position = []
        else:
            self.Position = Position
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LinearScaleType.subclass:
            return LinearScaleType.subclass(*args_, **kwargs_)
        else:
            return LinearScaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_ScaleRanges(self): return self.ScaleRanges
    def set_ScaleRanges(self, ScaleRanges): self.ScaleRanges = ScaleRanges
    def add_ScaleRanges(self, value): self.ScaleRanges.append(value)
    def insert_ScaleRanges(self, index, value): self.ScaleRanges[index] = value
    def get_ScaleLabels(self): return self.ScaleLabels
    def set_ScaleLabels(self, ScaleLabels): self.ScaleLabels = ScaleLabels
    def add_ScaleLabels(self, value): self.ScaleLabels.append(value)
    def insert_ScaleLabels(self, index, value): self.ScaleLabels[index] = value
    def get_GaugeMajorTickMarks(self): return self.GaugeMajorTickMarks
    def set_GaugeMajorTickMarks(self, GaugeMajorTickMarks): self.GaugeMajorTickMarks = GaugeMajorTickMarks
    def add_GaugeMajorTickMarks(self, value): self.GaugeMajorTickMarks.append(value)
    def insert_GaugeMajorTickMarks(self, index, value): self.GaugeMajorTickMarks[index] = value
    def get_GaugeMinorTickMarks(self): return self.GaugeMinorTickMarks
    def set_GaugeMinorTickMarks(self, GaugeMinorTickMarks): self.GaugeMinorTickMarks = GaugeMinorTickMarks
    def add_GaugeMinorTickMarks(self, value): self.GaugeMinorTickMarks.append(value)
    def insert_GaugeMinorTickMarks(self, index, value): self.GaugeMinorTickMarks[index] = value
    def get_CustomLabels(self): return self.CustomLabels
    def set_CustomLabels(self, CustomLabels): self.CustomLabels = CustomLabels
    def add_CustomLabels(self, value): self.CustomLabels.append(value)
    def insert_CustomLabels(self, index, value): self.CustomLabels[index] = value
    def get_MaximumValue(self): return self.MaximumValue
    def set_MaximumValue(self, MaximumValue): self.MaximumValue = MaximumValue
    def add_MaximumValue(self, value): self.MaximumValue.append(value)
    def insert_MaximumValue(self, index, value): self.MaximumValue[index] = value
    def get_MinimumValue(self): return self.MinimumValue
    def set_MinimumValue(self, MinimumValue): self.MinimumValue = MinimumValue
    def add_MinimumValue(self, value): self.MinimumValue.append(value)
    def insert_MinimumValue(self, index, value): self.MinimumValue[index] = value
    def get_MaximumPin(self): return self.MaximumPin
    def set_MaximumPin(self, MaximumPin): self.MaximumPin = MaximumPin
    def add_MaximumPin(self, value): self.MaximumPin.append(value)
    def insert_MaximumPin(self, index, value): self.MaximumPin[index] = value
    def get_MinimumPin(self): return self.MinimumPin
    def set_MinimumPin(self, MinimumPin): self.MinimumPin = MinimumPin
    def add_MinimumPin(self, value): self.MinimumPin.append(value)
    def insert_MinimumPin(self, index, value): self.MinimumPin[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_Logarithmic(self): return self.Logarithmic
    def set_Logarithmic(self, Logarithmic): self.Logarithmic = Logarithmic
    def add_Logarithmic(self, value): self.Logarithmic.append(value)
    def insert_Logarithmic(self, index, value): self.Logarithmic[index] = value
    def get_LogarithmicBase(self): return self.LogarithmicBase
    def set_LogarithmicBase(self, LogarithmicBase): self.LogarithmicBase = LogarithmicBase
    def add_LogarithmicBase(self, value): self.LogarithmicBase.append(value)
    def insert_LogarithmicBase(self, index, value): self.LogarithmicBase[index] = value
    def get_Multiplier(self): return self.Multiplier
    def set_Multiplier(self, Multiplier): self.Multiplier = Multiplier
    def add_Multiplier(self, value): self.Multiplier.append(value)
    def insert_Multiplier(self, index, value): self.Multiplier[index] = value
    def get_Reversed(self): return self.Reversed
    def set_Reversed(self, Reversed): self.Reversed = Reversed
    def add_Reversed(self, value): self.Reversed.append(value)
    def insert_Reversed(self, index, value): self.Reversed[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_TickMarksOnTop(self): return self.TickMarksOnTop
    def set_TickMarksOnTop(self, TickMarksOnTop): self.TickMarksOnTop = TickMarksOnTop
    def add_TickMarksOnTop(self, value): self.TickMarksOnTop.append(value)
    def insert_TickMarksOnTop(self, index, value): self.TickMarksOnTop[index] = value
    def get_GaugePointers(self): return self.GaugePointers
    def set_GaugePointers(self, GaugePointers): self.GaugePointers = GaugePointers
    def add_GaugePointers(self, value): self.GaugePointers.append(value)
    def insert_GaugePointers(self, index, value): self.GaugePointers[index] = value
    def get_StartMargin(self): return self.StartMargin
    def set_StartMargin(self, StartMargin): self.StartMargin = StartMargin
    def add_StartMargin(self, value): self.StartMargin.append(value)
    def insert_StartMargin(self, index, value): self.StartMargin[index] = value
    def get_EndMargin(self): return self.EndMargin
    def set_EndMargin(self, EndMargin): self.EndMargin = EndMargin
    def add_EndMargin(self, value): self.EndMargin.append(value)
    def insert_EndMargin(self, index, value): self.EndMargin[index] = value
    def get_Position(self): return self.Position
    def set_Position(self, Position): self.Position = Position
    def add_Position(self, value): self.Position.append(value)
    def insert_Position(self, index, value): self.Position[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LinearScaleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearScaleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearScaleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinearScaleType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for ScaleRanges_ in self.ScaleRanges:
            ScaleRanges_.export(outfile, level, namespace_, name_='ScaleRanges')
        for ScaleLabels_ in self.ScaleLabels:
            ScaleLabels_.export(outfile, level, namespace_, name_='ScaleLabels')
        for GaugeMajorTickMarks_ in self.GaugeMajorTickMarks:
            GaugeMajorTickMarks_.export(outfile, level, namespace_, name_='GaugeMajorTickMarks')
        for GaugeMinorTickMarks_ in self.GaugeMinorTickMarks:
            GaugeMinorTickMarks_.export(outfile, level, namespace_, name_='GaugeMinorTickMarks')
        for CustomLabels_ in self.CustomLabels:
            CustomLabels_.export(outfile, level, namespace_, name_='CustomLabels')
        for MaximumValue_ in self.MaximumValue:
            MaximumValue_.export(outfile, level, namespace_, name_='MaximumValue')
        for MinimumValue_ in self.MinimumValue:
            MinimumValue_.export(outfile, level, namespace_, name_='MinimumValue')
        for MaximumPin_ in self.MaximumPin:
            MaximumPin_.export(outfile, level, namespace_, name_='MaximumPin')
        for MinimumPin_ in self.MinimumPin:
            MinimumPin_.export(outfile, level, namespace_, name_='MinimumPin')
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for Logarithmic_ in self.Logarithmic:
            showIndent(outfile, level)
            outfile.write('<%sLogarithmic>%s</%sLogarithmic>\n' % (namespace_, self.gds_format_string(quote_xml(Logarithmic_).encode(ExternalEncoding), input_name='Logarithmic'), namespace_))
        for LogarithmicBase_ in self.LogarithmicBase:
            showIndent(outfile, level)
            outfile.write('<%sLogarithmicBase>%s</%sLogarithmicBase>\n' % (namespace_, self.gds_format_string(quote_xml(LogarithmicBase_).encode(ExternalEncoding), input_name='LogarithmicBase'), namespace_))
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('<%sMultiplier>%s</%sMultiplier>\n' % (namespace_, self.gds_format_string(quote_xml(Multiplier_).encode(ExternalEncoding), input_name='Multiplier'), namespace_))
        for Reversed_ in self.Reversed:
            showIndent(outfile, level)
            outfile.write('<%sReversed>%s</%sReversed>\n' % (namespace_, self.gds_format_string(quote_xml(Reversed_).encode(ExternalEncoding), input_name='Reversed'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for TickMarksOnTop_ in self.TickMarksOnTop:
            showIndent(outfile, level)
            outfile.write('<%sTickMarksOnTop>%s</%sTickMarksOnTop>\n' % (namespace_, self.gds_format_string(quote_xml(TickMarksOnTop_).encode(ExternalEncoding), input_name='TickMarksOnTop'), namespace_))
        for GaugePointers_ in self.GaugePointers:
            GaugePointers_.export(outfile, level, namespace_, name_='GaugePointers')
        for StartMargin_ in self.StartMargin:
            showIndent(outfile, level)
            outfile.write('<%sStartMargin>%s</%sStartMargin>\n' % (namespace_, self.gds_format_string(quote_xml(StartMargin_).encode(ExternalEncoding), input_name='StartMargin'), namespace_))
        for EndMargin_ in self.EndMargin:
            showIndent(outfile, level)
            outfile.write('<%sEndMargin>%s</%sEndMargin>\n' % (namespace_, self.gds_format_string(quote_xml(EndMargin_).encode(ExternalEncoding), input_name='EndMargin'), namespace_))
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('<%sPosition>%s</%sPosition>\n' % (namespace_, self.gds_format_string(quote_xml(Position_).encode(ExternalEncoding), input_name='Position'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.ToolTip or
            self.ScaleRanges or
            self.ScaleLabels or
            self.GaugeMajorTickMarks or
            self.GaugeMinorTickMarks or
            self.CustomLabels or
            self.MaximumValue or
            self.MinimumValue or
            self.MaximumPin or
            self.MinimumPin or
            self.Interval or
            self.IntervalOffset or
            self.Logarithmic or
            self.LogarithmicBase or
            self.Multiplier or
            self.Reversed or
            self.Hidden or
            self.Width or
            self.TickMarksOnTop or
            self.GaugePointers or
            self.StartMargin or
            self.EndMargin or
            self.Position
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearScaleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScaleRanges=[\n')
        level += 1
        for ScaleRanges_ in self.ScaleRanges:
            showIndent(outfile, level)
            outfile.write('model_.ScaleRangesType(\n')
            ScaleRanges_.exportLiteral(outfile, level, name_='ScaleRangesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScaleLabels=[\n')
        level += 1
        for ScaleLabels_ in self.ScaleLabels:
            showIndent(outfile, level)
            outfile.write('model_.ScaleLabelsType(\n')
            ScaleLabels_.exportLiteral(outfile, level, name_='ScaleLabelsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeMajorTickMarks=[\n')
        level += 1
        for GaugeMajorTickMarks_ in self.GaugeMajorTickMarks:
            showIndent(outfile, level)
            outfile.write('model_.GaugeTickMarksType(\n')
            GaugeMajorTickMarks_.exportLiteral(outfile, level, name_='GaugeTickMarksType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeMinorTickMarks=[\n')
        level += 1
        for GaugeMinorTickMarks_ in self.GaugeMinorTickMarks:
            showIndent(outfile, level)
            outfile.write('model_.GaugeTickMarksType(\n')
            GaugeMinorTickMarks_.exportLiteral(outfile, level, name_='GaugeTickMarksType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CustomLabels=[\n')
        level += 1
        for CustomLabels_ in self.CustomLabels:
            showIndent(outfile, level)
            outfile.write('model_.CustomLabelsType(\n')
            CustomLabels_.exportLiteral(outfile, level, name_='CustomLabelsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaximumValue=[\n')
        level += 1
        for MaximumValue_ in self.MaximumValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            MaximumValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinimumValue=[\n')
        level += 1
        for MinimumValue_ in self.MinimumValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            MinimumValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MaximumPin=[\n')
        level += 1
        for MaximumPin_ in self.MaximumPin:
            showIndent(outfile, level)
            outfile.write('model_.ScalePinType(\n')
            MaximumPin_.exportLiteral(outfile, level, name_='ScalePinType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MinimumPin=[\n')
        level += 1
        for MinimumPin_ in self.MinimumPin:
            showIndent(outfile, level)
            outfile.write('model_.ScalePinType(\n')
            MinimumPin_.exportLiteral(outfile, level, name_='ScalePinType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Logarithmic=[\n')
        level += 1
        for Logarithmic_ in self.Logarithmic:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Logarithmic_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LogarithmicBase=[\n')
        level += 1
        for LogarithmicBase_ in self.LogarithmicBase:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(LogarithmicBase_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Multiplier=[\n')
        level += 1
        for Multiplier_ in self.Multiplier:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Multiplier_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Reversed=[\n')
        level += 1
        for Reversed_ in self.Reversed:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reversed_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TickMarksOnTop=[\n')
        level += 1
        for TickMarksOnTop_ in self.TickMarksOnTop:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TickMarksOnTop_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugePointers=[\n')
        level += 1
        for GaugePointers_ in self.GaugePointers:
            showIndent(outfile, level)
            outfile.write('model_.LinearPointersType(\n')
            GaugePointers_.exportLiteral(outfile, level, name_='LinearPointersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StartMargin=[\n')
        level += 1
        for StartMargin_ in self.StartMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StartMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EndMargin=[\n')
        level += 1
        for EndMargin_ in self.EndMargin:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EndMargin_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Position=[\n')
        level += 1
        for Position_ in self.Position:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Position_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'ScaleRanges':
            obj_ = ScaleRangesType.factory()
            obj_.build(child_)
            self.ScaleRanges.append(obj_)
        elif nodeName_ == 'ScaleLabels':
            obj_ = ScaleLabelsType.factory()
            obj_.build(child_)
            self.ScaleLabels.append(obj_)
        elif nodeName_ == 'GaugeMajorTickMarks':
            obj_ = GaugeTickMarksType.factory()
            obj_.build(child_)
            self.GaugeMajorTickMarks.append(obj_)
        elif nodeName_ == 'GaugeMinorTickMarks':
            obj_ = GaugeTickMarksType.factory()
            obj_.build(child_)
            self.GaugeMinorTickMarks.append(obj_)
        elif nodeName_ == 'CustomLabels':
            obj_ = CustomLabelsType.factory()
            obj_.build(child_)
            self.CustomLabels.append(obj_)
        elif nodeName_ == 'MaximumValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.MaximumValue.append(obj_)
        elif nodeName_ == 'MinimumValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.MinimumValue.append(obj_)
        elif nodeName_ == 'MaximumPin':
            obj_ = ScalePinType.factory()
            obj_.build(child_)
            self.MaximumPin.append(obj_)
        elif nodeName_ == 'MinimumPin':
            obj_ = ScalePinType.factory()
            obj_.build(child_)
            self.MinimumPin.append(obj_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'Logarithmic':
            Logarithmic_ = child_.text
            Logarithmic_ = self.gds_validate_string(Logarithmic_, node, 'Logarithmic')
            self.Logarithmic.append(Logarithmic_)
        elif nodeName_ == 'LogarithmicBase':
            LogarithmicBase_ = child_.text
            LogarithmicBase_ = self.gds_validate_string(LogarithmicBase_, node, 'LogarithmicBase')
            self.LogarithmicBase.append(LogarithmicBase_)
        elif nodeName_ == 'Multiplier':
            Multiplier_ = child_.text
            Multiplier_ = self.gds_validate_string(Multiplier_, node, 'Multiplier')
            self.Multiplier.append(Multiplier_)
        elif nodeName_ == 'Reversed':
            Reversed_ = child_.text
            Reversed_ = self.gds_validate_string(Reversed_, node, 'Reversed')
            self.Reversed.append(Reversed_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'TickMarksOnTop':
            TickMarksOnTop_ = child_.text
            TickMarksOnTop_ = self.gds_validate_string(TickMarksOnTop_, node, 'TickMarksOnTop')
            self.TickMarksOnTop.append(TickMarksOnTop_)
        elif nodeName_ == 'GaugePointers':
            obj_ = LinearPointersType.factory()
            obj_.build(child_)
            self.GaugePointers.append(obj_)
        elif nodeName_ == 'StartMargin':
            StartMargin_ = child_.text
            StartMargin_ = self.gds_validate_string(StartMargin_, node, 'StartMargin')
            self.StartMargin.append(StartMargin_)
        elif nodeName_ == 'EndMargin':
            EndMargin_ = child_.text
            EndMargin_ = self.gds_validate_string(EndMargin_, node, 'EndMargin')
            self.EndMargin.append(EndMargin_)
        elif nodeName_ == 'Position':
            Position_ = child_.text
            Position_ = self.gds_validate_string(Position_, node, 'Position')
            self.Position.append(Position_)
# end class LinearScaleType


class RadialPointerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, ToolTip=None, GaugeInputValue=None, PointerImage=None, BarStart=None, DistanceFromScale=None, MarkerLength=None, MarkerStyle=None, Placement=None, SnappingEnabled=None, SnappingInterval=None, Hidden=None, Width=None, Type=None, PointerCap=None, NeedleStyle=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if GaugeInputValue is None:
            self.GaugeInputValue = []
        else:
            self.GaugeInputValue = GaugeInputValue
        if PointerImage is None:
            self.PointerImage = []
        else:
            self.PointerImage = PointerImage
        if BarStart is None:
            self.BarStart = []
        else:
            self.BarStart = BarStart
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if MarkerLength is None:
            self.MarkerLength = []
        else:
            self.MarkerLength = MarkerLength
        if MarkerStyle is None:
            self.MarkerStyle = []
        else:
            self.MarkerStyle = MarkerStyle
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if SnappingEnabled is None:
            self.SnappingEnabled = []
        else:
            self.SnappingEnabled = SnappingEnabled
        if SnappingInterval is None:
            self.SnappingInterval = []
        else:
            self.SnappingInterval = SnappingInterval
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if PointerCap is None:
            self.PointerCap = []
        else:
            self.PointerCap = PointerCap
        if NeedleStyle is None:
            self.NeedleStyle = []
        else:
            self.NeedleStyle = NeedleStyle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RadialPointerType.subclass:
            return RadialPointerType.subclass(*args_, **kwargs_)
        else:
            return RadialPointerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_GaugeInputValue(self): return self.GaugeInputValue
    def set_GaugeInputValue(self, GaugeInputValue): self.GaugeInputValue = GaugeInputValue
    def add_GaugeInputValue(self, value): self.GaugeInputValue.append(value)
    def insert_GaugeInputValue(self, index, value): self.GaugeInputValue[index] = value
    def get_PointerImage(self): return self.PointerImage
    def set_PointerImage(self, PointerImage): self.PointerImage = PointerImage
    def add_PointerImage(self, value): self.PointerImage.append(value)
    def insert_PointerImage(self, index, value): self.PointerImage[index] = value
    def get_BarStart(self): return self.BarStart
    def set_BarStart(self, BarStart): self.BarStart = BarStart
    def add_BarStart(self, value): self.BarStart.append(value)
    def insert_BarStart(self, index, value): self.BarStart[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_MarkerLength(self): return self.MarkerLength
    def set_MarkerLength(self, MarkerLength): self.MarkerLength = MarkerLength
    def add_MarkerLength(self, value): self.MarkerLength.append(value)
    def insert_MarkerLength(self, index, value): self.MarkerLength[index] = value
    def get_MarkerStyle(self): return self.MarkerStyle
    def set_MarkerStyle(self, MarkerStyle): self.MarkerStyle = MarkerStyle
    def add_MarkerStyle(self, value): self.MarkerStyle.append(value)
    def insert_MarkerStyle(self, index, value): self.MarkerStyle[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_SnappingEnabled(self): return self.SnappingEnabled
    def set_SnappingEnabled(self, SnappingEnabled): self.SnappingEnabled = SnappingEnabled
    def add_SnappingEnabled(self, value): self.SnappingEnabled.append(value)
    def insert_SnappingEnabled(self, index, value): self.SnappingEnabled[index] = value
    def get_SnappingInterval(self): return self.SnappingInterval
    def set_SnappingInterval(self, SnappingInterval): self.SnappingInterval = SnappingInterval
    def add_SnappingInterval(self, value): self.SnappingInterval.append(value)
    def insert_SnappingInterval(self, index, value): self.SnappingInterval[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_PointerCap(self): return self.PointerCap
    def set_PointerCap(self, PointerCap): self.PointerCap = PointerCap
    def add_PointerCap(self, value): self.PointerCap.append(value)
    def insert_PointerCap(self, index, value): self.PointerCap[index] = value
    def get_NeedleStyle(self): return self.NeedleStyle
    def set_NeedleStyle(self, NeedleStyle): self.NeedleStyle = NeedleStyle
    def add_NeedleStyle(self, value): self.NeedleStyle.append(value)
    def insert_NeedleStyle(self, index, value): self.NeedleStyle[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RadialPointerType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialPointerType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialPointerType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RadialPointerType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for GaugeInputValue_ in self.GaugeInputValue:
            GaugeInputValue_.export(outfile, level, namespace_, name_='GaugeInputValue')
        for PointerImage_ in self.PointerImage:
            PointerImage_.export(outfile, level, namespace_, name_='PointerImage')
        for BarStart_ in self.BarStart:
            showIndent(outfile, level)
            outfile.write('<%sBarStart>%s</%sBarStart>\n' % (namespace_, self.gds_format_string(quote_xml(BarStart_).encode(ExternalEncoding), input_name='BarStart'), namespace_))
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for MarkerLength_ in self.MarkerLength:
            showIndent(outfile, level)
            outfile.write('<%sMarkerLength>%s</%sMarkerLength>\n' % (namespace_, self.gds_format_string(quote_xml(MarkerLength_).encode(ExternalEncoding), input_name='MarkerLength'), namespace_))
        for MarkerStyle_ in self.MarkerStyle:
            showIndent(outfile, level)
            outfile.write('<%sMarkerStyle>%s</%sMarkerStyle>\n' % (namespace_, self.gds_format_string(quote_xml(MarkerStyle_).encode(ExternalEncoding), input_name='MarkerStyle'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for SnappingEnabled_ in self.SnappingEnabled:
            showIndent(outfile, level)
            outfile.write('<%sSnappingEnabled>%s</%sSnappingEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(SnappingEnabled_).encode(ExternalEncoding), input_name='SnappingEnabled'), namespace_))
        for SnappingInterval_ in self.SnappingInterval:
            showIndent(outfile, level)
            outfile.write('<%sSnappingInterval>%s</%sSnappingInterval>\n' % (namespace_, self.gds_format_string(quote_xml(SnappingInterval_).encode(ExternalEncoding), input_name='SnappingInterval'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(Type_).encode(ExternalEncoding), input_name='Type'), namespace_))
        for PointerCap_ in self.PointerCap:
            PointerCap_.export(outfile, level, namespace_, name_='PointerCap')
        for NeedleStyle_ in self.NeedleStyle:
            showIndent(outfile, level)
            outfile.write('<%sNeedleStyle>%s</%sNeedleStyle>\n' % (namespace_, self.gds_format_string(quote_xml(NeedleStyle_).encode(ExternalEncoding), input_name='NeedleStyle'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.ToolTip or
            self.GaugeInputValue or
            self.PointerImage or
            self.BarStart or
            self.DistanceFromScale or
            self.MarkerLength or
            self.MarkerStyle or
            self.Placement or
            self.SnappingEnabled or
            self.SnappingInterval or
            self.Hidden or
            self.Width or
            self.Type or
            self.PointerCap or
            self.NeedleStyle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RadialPointerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeInputValue=[\n')
        level += 1
        for GaugeInputValue_ in self.GaugeInputValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            GaugeInputValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PointerImage=[\n')
        level += 1
        for PointerImage_ in self.PointerImage:
            showIndent(outfile, level)
            outfile.write('model_.PointerImageType(\n')
            PointerImage_.exportLiteral(outfile, level, name_='PointerImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BarStart=[\n')
        level += 1
        for BarStart_ in self.BarStart:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BarStart_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarkerLength=[\n')
        level += 1
        for MarkerLength_ in self.MarkerLength:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarkerLength_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarkerStyle=[\n')
        level += 1
        for MarkerStyle_ in self.MarkerStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarkerStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnappingEnabled=[\n')
        level += 1
        for SnappingEnabled_ in self.SnappingEnabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SnappingEnabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnappingInterval=[\n')
        level += 1
        for SnappingInterval_ in self.SnappingInterval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SnappingInterval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PointerCap=[\n')
        level += 1
        for PointerCap_ in self.PointerCap:
            showIndent(outfile, level)
            outfile.write('model_.PointerCapType(\n')
            PointerCap_.exportLiteral(outfile, level, name_='PointerCapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NeedleStyle=[\n')
        level += 1
        for NeedleStyle_ in self.NeedleStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(NeedleStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'GaugeInputValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.GaugeInputValue.append(obj_)
        elif nodeName_ == 'PointerImage':
            obj_ = PointerImageType.factory()
            obj_.build(child_)
            self.PointerImage.append(obj_)
        elif nodeName_ == 'BarStart':
            BarStart_ = child_.text
            BarStart_ = self.gds_validate_string(BarStart_, node, 'BarStart')
            self.BarStart.append(BarStart_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'MarkerLength':
            MarkerLength_ = child_.text
            MarkerLength_ = self.gds_validate_string(MarkerLength_, node, 'MarkerLength')
            self.MarkerLength.append(MarkerLength_)
        elif nodeName_ == 'MarkerStyle':
            MarkerStyle_ = child_.text
            MarkerStyle_ = self.gds_validate_string(MarkerStyle_, node, 'MarkerStyle')
            self.MarkerStyle.append(MarkerStyle_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'SnappingEnabled':
            SnappingEnabled_ = child_.text
            SnappingEnabled_ = self.gds_validate_string(SnappingEnabled_, node, 'SnappingEnabled')
            self.SnappingEnabled.append(SnappingEnabled_)
        elif nodeName_ == 'SnappingInterval':
            SnappingInterval_ = child_.text
            SnappingInterval_ = self.gds_validate_string(SnappingInterval_, node, 'SnappingInterval')
            self.SnappingInterval.append(SnappingInterval_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
        elif nodeName_ == 'PointerCap':
            obj_ = PointerCapType.factory()
            obj_.build(child_)
            self.PointerCap.append(obj_)
        elif nodeName_ == 'NeedleStyle':
            NeedleStyle_ = child_.text
            NeedleStyle_ = self.gds_validate_string(NeedleStyle_, node, 'NeedleStyle')
            self.NeedleStyle.append(NeedleStyle_)
# end class RadialPointerType


class LinearPointerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, ActionInfo=None, ToolTip=None, GaugeInputValue=None, PointerImage=None, BarStart=None, DistanceFromScale=None, MarkerLength=None, MarkerStyle=None, Placement=None, SnappingEnabled=None, SnappingInterval=None, Hidden=None, Width=None, Type=None, Thermometer=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if GaugeInputValue is None:
            self.GaugeInputValue = []
        else:
            self.GaugeInputValue = GaugeInputValue
        if PointerImage is None:
            self.PointerImage = []
        else:
            self.PointerImage = PointerImage
        if BarStart is None:
            self.BarStart = []
        else:
            self.BarStart = BarStart
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if MarkerLength is None:
            self.MarkerLength = []
        else:
            self.MarkerLength = MarkerLength
        if MarkerStyle is None:
            self.MarkerStyle = []
        else:
            self.MarkerStyle = MarkerStyle
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if SnappingEnabled is None:
            self.SnappingEnabled = []
        else:
            self.SnappingEnabled = SnappingEnabled
        if SnappingInterval is None:
            self.SnappingInterval = []
        else:
            self.SnappingInterval = SnappingInterval
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if Type is None:
            self.Type = []
        else:
            self.Type = Type
        if Thermometer is None:
            self.Thermometer = []
        else:
            self.Thermometer = Thermometer
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LinearPointerType.subclass:
            return LinearPointerType.subclass(*args_, **kwargs_)
        else:
            return LinearPointerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_GaugeInputValue(self): return self.GaugeInputValue
    def set_GaugeInputValue(self, GaugeInputValue): self.GaugeInputValue = GaugeInputValue
    def add_GaugeInputValue(self, value): self.GaugeInputValue.append(value)
    def insert_GaugeInputValue(self, index, value): self.GaugeInputValue[index] = value
    def get_PointerImage(self): return self.PointerImage
    def set_PointerImage(self, PointerImage): self.PointerImage = PointerImage
    def add_PointerImage(self, value): self.PointerImage.append(value)
    def insert_PointerImage(self, index, value): self.PointerImage[index] = value
    def get_BarStart(self): return self.BarStart
    def set_BarStart(self, BarStart): self.BarStart = BarStart
    def add_BarStart(self, value): self.BarStart.append(value)
    def insert_BarStart(self, index, value): self.BarStart[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_MarkerLength(self): return self.MarkerLength
    def set_MarkerLength(self, MarkerLength): self.MarkerLength = MarkerLength
    def add_MarkerLength(self, value): self.MarkerLength.append(value)
    def insert_MarkerLength(self, index, value): self.MarkerLength[index] = value
    def get_MarkerStyle(self): return self.MarkerStyle
    def set_MarkerStyle(self, MarkerStyle): self.MarkerStyle = MarkerStyle
    def add_MarkerStyle(self, value): self.MarkerStyle.append(value)
    def insert_MarkerStyle(self, index, value): self.MarkerStyle[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_SnappingEnabled(self): return self.SnappingEnabled
    def set_SnappingEnabled(self, SnappingEnabled): self.SnappingEnabled = SnappingEnabled
    def add_SnappingEnabled(self, value): self.SnappingEnabled.append(value)
    def insert_SnappingEnabled(self, index, value): self.SnappingEnabled[index] = value
    def get_SnappingInterval(self): return self.SnappingInterval
    def set_SnappingInterval(self, SnappingInterval): self.SnappingInterval = SnappingInterval
    def add_SnappingInterval(self, value): self.SnappingInterval.append(value)
    def insert_SnappingInterval(self, index, value): self.SnappingInterval[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def add_Type(self, value): self.Type.append(value)
    def insert_Type(self, index, value): self.Type[index] = value
    def get_Thermometer(self): return self.Thermometer
    def set_Thermometer(self, Thermometer): self.Thermometer = Thermometer
    def add_Thermometer(self, value): self.Thermometer.append(value)
    def insert_Thermometer(self, index, value): self.Thermometer[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LinearPointerType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearPointerType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearPointerType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinearPointerType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for GaugeInputValue_ in self.GaugeInputValue:
            GaugeInputValue_.export(outfile, level, namespace_, name_='GaugeInputValue')
        for PointerImage_ in self.PointerImage:
            PointerImage_.export(outfile, level, namespace_, name_='PointerImage')
        for BarStart_ in self.BarStart:
            showIndent(outfile, level)
            outfile.write('<%sBarStart>%s</%sBarStart>\n' % (namespace_, self.gds_format_string(quote_xml(BarStart_).encode(ExternalEncoding), input_name='BarStart'), namespace_))
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for MarkerLength_ in self.MarkerLength:
            showIndent(outfile, level)
            outfile.write('<%sMarkerLength>%s</%sMarkerLength>\n' % (namespace_, self.gds_format_string(quote_xml(MarkerLength_).encode(ExternalEncoding), input_name='MarkerLength'), namespace_))
        for MarkerStyle_ in self.MarkerStyle:
            showIndent(outfile, level)
            outfile.write('<%sMarkerStyle>%s</%sMarkerStyle>\n' % (namespace_, self.gds_format_string(quote_xml(MarkerStyle_).encode(ExternalEncoding), input_name='MarkerStyle'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for SnappingEnabled_ in self.SnappingEnabled:
            showIndent(outfile, level)
            outfile.write('<%sSnappingEnabled>%s</%sSnappingEnabled>\n' % (namespace_, self.gds_format_string(quote_xml(SnappingEnabled_).encode(ExternalEncoding), input_name='SnappingEnabled'), namespace_))
        for SnappingInterval_ in self.SnappingInterval:
            showIndent(outfile, level)
            outfile.write('<%sSnappingInterval>%s</%sSnappingInterval>\n' % (namespace_, self.gds_format_string(quote_xml(SnappingInterval_).encode(ExternalEncoding), input_name='SnappingInterval'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(Type_).encode(ExternalEncoding), input_name='Type'), namespace_))
        for Thermometer_ in self.Thermometer:
            Thermometer_.export(outfile, level, namespace_, name_='Thermometer')
    def hasContent_(self):
        if (
            self.Style or
            self.ActionInfo or
            self.ToolTip or
            self.GaugeInputValue or
            self.PointerImage or
            self.BarStart or
            self.DistanceFromScale or
            self.MarkerLength or
            self.MarkerStyle or
            self.Placement or
            self.SnappingEnabled or
            self.SnappingInterval or
            self.Hidden or
            self.Width or
            self.Type or
            self.Thermometer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearPointerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GaugeInputValue=[\n')
        level += 1
        for GaugeInputValue_ in self.GaugeInputValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            GaugeInputValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PointerImage=[\n')
        level += 1
        for PointerImage_ in self.PointerImage:
            showIndent(outfile, level)
            outfile.write('model_.PointerImageType(\n')
            PointerImage_.exportLiteral(outfile, level, name_='PointerImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BarStart=[\n')
        level += 1
        for BarStart_ in self.BarStart:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BarStart_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarkerLength=[\n')
        level += 1
        for MarkerLength_ in self.MarkerLength:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarkerLength_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MarkerStyle=[\n')
        level += 1
        for MarkerStyle_ in self.MarkerStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MarkerStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnappingEnabled=[\n')
        level += 1
        for SnappingEnabled_ in self.SnappingEnabled:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SnappingEnabled_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SnappingInterval=[\n')
        level += 1
        for SnappingInterval_ in self.SnappingInterval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SnappingInterval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Type=[\n')
        level += 1
        for Type_ in self.Type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Thermometer=[\n')
        level += 1
        for Thermometer_ in self.Thermometer:
            showIndent(outfile, level)
            outfile.write('model_.ThermometerType(\n')
            Thermometer_.exportLiteral(outfile, level, name_='ThermometerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'GaugeInputValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.GaugeInputValue.append(obj_)
        elif nodeName_ == 'PointerImage':
            obj_ = PointerImageType.factory()
            obj_.build(child_)
            self.PointerImage.append(obj_)
        elif nodeName_ == 'BarStart':
            BarStart_ = child_.text
            BarStart_ = self.gds_validate_string(BarStart_, node, 'BarStart')
            self.BarStart.append(BarStart_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'MarkerLength':
            MarkerLength_ = child_.text
            MarkerLength_ = self.gds_validate_string(MarkerLength_, node, 'MarkerLength')
            self.MarkerLength.append(MarkerLength_)
        elif nodeName_ == 'MarkerStyle':
            MarkerStyle_ = child_.text
            MarkerStyle_ = self.gds_validate_string(MarkerStyle_, node, 'MarkerStyle')
            self.MarkerStyle.append(MarkerStyle_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'SnappingEnabled':
            SnappingEnabled_ = child_.text
            SnappingEnabled_ = self.gds_validate_string(SnappingEnabled_, node, 'SnappingEnabled')
            self.SnappingEnabled.append(SnappingEnabled_)
        elif nodeName_ == 'SnappingInterval':
            SnappingInterval_ = child_.text
            SnappingInterval_ = self.gds_validate_string(SnappingInterval_, node, 'SnappingInterval')
            self.SnappingInterval.append(SnappingInterval_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type.append(Type_)
        elif nodeName_ == 'Thermometer':
            obj_ = ThermometerType.factory()
            obj_.build(child_)
            self.Thermometer.append(obj_)
# end class LinearPointerType


class ThermometerType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, BulbOffset=None, BulbSize=None, ThermometerStyle=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if BulbOffset is None:
            self.BulbOffset = []
        else:
            self.BulbOffset = BulbOffset
        if BulbSize is None:
            self.BulbSize = []
        else:
            self.BulbSize = BulbSize
        if ThermometerStyle is None:
            self.ThermometerStyle = []
        else:
            self.ThermometerStyle = ThermometerStyle
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ThermometerType.subclass:
            return ThermometerType.subclass(*args_, **kwargs_)
        else:
            return ThermometerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_BulbOffset(self): return self.BulbOffset
    def set_BulbOffset(self, BulbOffset): self.BulbOffset = BulbOffset
    def add_BulbOffset(self, value): self.BulbOffset.append(value)
    def insert_BulbOffset(self, index, value): self.BulbOffset[index] = value
    def get_BulbSize(self): return self.BulbSize
    def set_BulbSize(self, BulbSize): self.BulbSize = BulbSize
    def add_BulbSize(self, value): self.BulbSize.append(value)
    def insert_BulbSize(self, index, value): self.BulbSize[index] = value
    def get_ThermometerStyle(self): return self.ThermometerStyle
    def set_ThermometerStyle(self, ThermometerStyle): self.ThermometerStyle = ThermometerStyle
    def add_ThermometerStyle(self, value): self.ThermometerStyle.append(value)
    def insert_ThermometerStyle(self, index, value): self.ThermometerStyle[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ThermometerType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ThermometerType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ThermometerType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ThermometerType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for BulbOffset_ in self.BulbOffset:
            showIndent(outfile, level)
            outfile.write('<%sBulbOffset>%s</%sBulbOffset>\n' % (namespace_, self.gds_format_string(quote_xml(BulbOffset_).encode(ExternalEncoding), input_name='BulbOffset'), namespace_))
        for BulbSize_ in self.BulbSize:
            showIndent(outfile, level)
            outfile.write('<%sBulbSize>%s</%sBulbSize>\n' % (namespace_, self.gds_format_string(quote_xml(BulbSize_).encode(ExternalEncoding), input_name='BulbSize'), namespace_))
        for ThermometerStyle_ in self.ThermometerStyle:
            showIndent(outfile, level)
            outfile.write('<%sThermometerStyle>%s</%sThermometerStyle>\n' % (namespace_, self.gds_format_string(quote_xml(ThermometerStyle_).encode(ExternalEncoding), input_name='ThermometerStyle'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.BulbOffset or
            self.BulbSize or
            self.ThermometerStyle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ThermometerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BulbOffset=[\n')
        level += 1
        for BulbOffset_ in self.BulbOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BulbOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BulbSize=[\n')
        level += 1
        for BulbSize_ in self.BulbSize:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BulbSize_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ThermometerStyle=[\n')
        level += 1
        for ThermometerStyle_ in self.ThermometerStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ThermometerStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'BulbOffset':
            BulbOffset_ = child_.text
            BulbOffset_ = self.gds_validate_string(BulbOffset_, node, 'BulbOffset')
            self.BulbOffset.append(BulbOffset_)
        elif nodeName_ == 'BulbSize':
            BulbSize_ = child_.text
            BulbSize_ = self.gds_validate_string(BulbSize_, node, 'BulbSize')
            self.BulbSize.append(BulbSize_)
        elif nodeName_ == 'ThermometerStyle':
            ThermometerStyle_ = child_.text
            ThermometerStyle_ = self.gds_validate_string(ThermometerStyle_, node, 'ThermometerStyle')
            self.ThermometerStyle.append(ThermometerStyle_)
# end class ThermometerType


class PointerCapType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, CapImage=None, OnTop=None, Reflection=None, CapStyle=None, Hidden=None, Width=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if CapImage is None:
            self.CapImage = []
        else:
            self.CapImage = CapImage
        if OnTop is None:
            self.OnTop = []
        else:
            self.OnTop = OnTop
        if Reflection is None:
            self.Reflection = []
        else:
            self.Reflection = Reflection
        if CapStyle is None:
            self.CapStyle = []
        else:
            self.CapStyle = CapStyle
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PointerCapType.subclass:
            return PointerCapType.subclass(*args_, **kwargs_)
        else:
            return PointerCapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_CapImage(self): return self.CapImage
    def set_CapImage(self, CapImage): self.CapImage = CapImage
    def add_CapImage(self, value): self.CapImage.append(value)
    def insert_CapImage(self, index, value): self.CapImage[index] = value
    def get_OnTop(self): return self.OnTop
    def set_OnTop(self, OnTop): self.OnTop = OnTop
    def add_OnTop(self, value): self.OnTop.append(value)
    def insert_OnTop(self, index, value): self.OnTop[index] = value
    def get_Reflection(self): return self.Reflection
    def set_Reflection(self, Reflection): self.Reflection = Reflection
    def add_Reflection(self, value): self.Reflection.append(value)
    def insert_Reflection(self, index, value): self.Reflection[index] = value
    def get_CapStyle(self): return self.CapStyle
    def set_CapStyle(self, CapStyle): self.CapStyle = CapStyle
    def add_CapStyle(self, value): self.CapStyle.append(value)
    def insert_CapStyle(self, index, value): self.CapStyle[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PointerCapType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointerCapType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointerCapType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PointerCapType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for CapImage_ in self.CapImage:
            CapImage_.export(outfile, level, namespace_, name_='CapImage')
        for OnTop_ in self.OnTop:
            showIndent(outfile, level)
            outfile.write('<%sOnTop>%s</%sOnTop>\n' % (namespace_, self.gds_format_string(quote_xml(OnTop_).encode(ExternalEncoding), input_name='OnTop'), namespace_))
        for Reflection_ in self.Reflection:
            showIndent(outfile, level)
            outfile.write('<%sReflection>%s</%sReflection>\n' % (namespace_, self.gds_format_string(quote_xml(Reflection_).encode(ExternalEncoding), input_name='Reflection'), namespace_))
        for CapStyle_ in self.CapStyle:
            showIndent(outfile, level)
            outfile.write('<%sCapStyle>%s</%sCapStyle>\n' % (namespace_, self.gds_format_string(quote_xml(CapStyle_).encode(ExternalEncoding), input_name='CapStyle'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.CapImage or
            self.OnTop or
            self.Reflection or
            self.CapStyle or
            self.Hidden or
            self.Width
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointerCapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CapImage=[\n')
        level += 1
        for CapImage_ in self.CapImage:
            showIndent(outfile, level)
            outfile.write('model_.CapImageType(\n')
            CapImage_.exportLiteral(outfile, level, name_='CapImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OnTop=[\n')
        level += 1
        for OnTop_ in self.OnTop:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OnTop_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Reflection=[\n')
        level += 1
        for Reflection_ in self.Reflection:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reflection_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CapStyle=[\n')
        level += 1
        for CapStyle_ in self.CapStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CapStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'CapImage':
            obj_ = CapImageType.factory()
            obj_.build(child_)
            self.CapImage.append(obj_)
        elif nodeName_ == 'OnTop':
            OnTop_ = child_.text
            OnTop_ = self.gds_validate_string(OnTop_, node, 'OnTop')
            self.OnTop.append(OnTop_)
        elif nodeName_ == 'Reflection':
            Reflection_ = child_.text
            Reflection_ = self.gds_validate_string(Reflection_, node, 'Reflection')
            self.Reflection.append(Reflection_)
        elif nodeName_ == 'CapStyle':
            CapStyle_ = child_.text
            CapStyle_ = self.gds_validate_string(CapStyle_, node, 'CapStyle')
            self.CapStyle.append(CapStyle_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
# end class PointerCapType


class NumericIndicatorRangeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, StartValue=None, EndValue=None, DecimalDigitColor=None, DigitColor=None):
        self.Name = _cast(None, Name)
        if StartValue is None:
            self.StartValue = []
        else:
            self.StartValue = StartValue
        if EndValue is None:
            self.EndValue = []
        else:
            self.EndValue = EndValue
        if DecimalDigitColor is None:
            self.DecimalDigitColor = []
        else:
            self.DecimalDigitColor = DecimalDigitColor
        if DigitColor is None:
            self.DigitColor = []
        else:
            self.DigitColor = DigitColor
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NumericIndicatorRangeType.subclass:
            return NumericIndicatorRangeType.subclass(*args_, **kwargs_)
        else:
            return NumericIndicatorRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartValue(self): return self.StartValue
    def set_StartValue(self, StartValue): self.StartValue = StartValue
    def add_StartValue(self, value): self.StartValue.append(value)
    def insert_StartValue(self, index, value): self.StartValue[index] = value
    def get_EndValue(self): return self.EndValue
    def set_EndValue(self, EndValue): self.EndValue = EndValue
    def add_EndValue(self, value): self.EndValue.append(value)
    def insert_EndValue(self, index, value): self.EndValue[index] = value
    def get_DecimalDigitColor(self): return self.DecimalDigitColor
    def set_DecimalDigitColor(self, DecimalDigitColor): self.DecimalDigitColor = DecimalDigitColor
    def add_DecimalDigitColor(self, value): self.DecimalDigitColor.append(value)
    def insert_DecimalDigitColor(self, index, value): self.DecimalDigitColor[index] = value
    def get_DigitColor(self): return self.DigitColor
    def set_DigitColor(self, DigitColor): self.DigitColor = DigitColor
    def add_DigitColor(self, value): self.DigitColor.append(value)
    def insert_DigitColor(self, index, value): self.DigitColor[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NumericIndicatorRangeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumericIndicatorRangeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumericIndicatorRangeType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NumericIndicatorRangeType', fromsubclass_=False):
        for StartValue_ in self.StartValue:
            StartValue_.export(outfile, level, namespace_, name_='StartValue')
        for EndValue_ in self.EndValue:
            EndValue_.export(outfile, level, namespace_, name_='EndValue')
        for DecimalDigitColor_ in self.DecimalDigitColor:
            showIndent(outfile, level)
            outfile.write('<%sDecimalDigitColor>%s</%sDecimalDigitColor>\n' % (namespace_, self.gds_format_string(quote_xml(DecimalDigitColor_).encode(ExternalEncoding), input_name='DecimalDigitColor'), namespace_))
        for DigitColor_ in self.DigitColor:
            showIndent(outfile, level)
            outfile.write('<%sDigitColor>%s</%sDigitColor>\n' % (namespace_, self.gds_format_string(quote_xml(DigitColor_).encode(ExternalEncoding), input_name='DigitColor'), namespace_))
    def hasContent_(self):
        if (
            self.StartValue or
            self.EndValue or
            self.DecimalDigitColor or
            self.DigitColor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumericIndicatorRangeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StartValue=[\n')
        level += 1
        for StartValue_ in self.StartValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            StartValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EndValue=[\n')
        level += 1
        for EndValue_ in self.EndValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            EndValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DecimalDigitColor=[\n')
        level += 1
        for DecimalDigitColor_ in self.DecimalDigitColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DecimalDigitColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DigitColor=[\n')
        level += 1
        for DigitColor_ in self.DigitColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DigitColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.StartValue.append(obj_)
        elif nodeName_ == 'EndValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.EndValue.append(obj_)
        elif nodeName_ == 'DecimalDigitColor':
            DecimalDigitColor_ = child_.text
            DecimalDigitColor_ = self.gds_validate_string(DecimalDigitColor_, node, 'DecimalDigitColor')
            self.DecimalDigitColor.append(DecimalDigitColor_)
        elif nodeName_ == 'DigitColor':
            DigitColor_ = child_.text
            DigitColor_ = self.gds_validate_string(DigitColor_, node, 'DigitColor')
            self.DigitColor.append(DigitColor_)
# end class NumericIndicatorRangeType


class IndicatorStateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, StartValue=None, EndValue=None, StateImage=None, Text=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if StartValue is None:
            self.StartValue = []
        else:
            self.StartValue = StartValue
        if EndValue is None:
            self.EndValue = []
        else:
            self.EndValue = EndValue
        if StateImage is None:
            self.StateImage = []
        else:
            self.StateImage = StateImage
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IndicatorStateType.subclass:
            return IndicatorStateType.subclass(*args_, **kwargs_)
        else:
            return IndicatorStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_StartValue(self): return self.StartValue
    def set_StartValue(self, StartValue): self.StartValue = StartValue
    def add_StartValue(self, value): self.StartValue.append(value)
    def insert_StartValue(self, index, value): self.StartValue[index] = value
    def get_EndValue(self): return self.EndValue
    def set_EndValue(self, EndValue): self.EndValue = EndValue
    def add_EndValue(self, value): self.EndValue.append(value)
    def insert_EndValue(self, index, value): self.EndValue[index] = value
    def get_StateImage(self): return self.StateImage
    def set_StateImage(self, StateImage): self.StateImage = StateImage
    def add_StateImage(self, value): self.StateImage.append(value)
    def insert_StateImage(self, index, value): self.StateImage[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='IndicatorStateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorStateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndicatorStateType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IndicatorStateType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for StartValue_ in self.StartValue:
            StartValue_.export(outfile, level, namespace_, name_='StartValue')
        for EndValue_ in self.EndValue:
            EndValue_.export(outfile, level, namespace_, name_='EndValue')
        for StateImage_ in self.StateImage:
            StateImage_.export(outfile, level, namespace_, name_='StateImage')
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('<%sText>%s</%sText>\n' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.StartValue or
            self.EndValue or
            self.StateImage or
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndicatorStateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StartValue=[\n')
        level += 1
        for StartValue_ in self.StartValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            StartValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EndValue=[\n')
        level += 1
        for EndValue_ in self.EndValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            EndValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StateImage=[\n')
        level += 1
        for StateImage_ in self.StateImage:
            showIndent(outfile, level)
            outfile.write('model_.StateImageType(\n')
            StateImage_.exportLiteral(outfile, level, name_='StateImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'StartValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.StartValue.append(obj_)
        elif nodeName_ == 'EndValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.EndValue.append(obj_)
        elif nodeName_ == 'StateImage':
            obj_ = StateImageType.factory()
            obj_.build(child_)
            self.StateImage.append(obj_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
# end class IndicatorStateType


class ScaleRangeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, BackgroundGradientType=None, ActionInfo=None, ToolTip=None, StartValue=None, EndValue=None, StartWidth=None, EndWidth=None, DistanceFromScale=None, InRangeBarPointerColor=None, InRangeLabelColor=None, InRangeTickMarksColor=None, Placement=None, Hidden=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if BackgroundGradientType is None:
            self.BackgroundGradientType = []
        else:
            self.BackgroundGradientType = BackgroundGradientType
        if ActionInfo is None:
            self.ActionInfo = []
        else:
            self.ActionInfo = ActionInfo
        if ToolTip is None:
            self.ToolTip = []
        else:
            self.ToolTip = ToolTip
        if StartValue is None:
            self.StartValue = []
        else:
            self.StartValue = StartValue
        if EndValue is None:
            self.EndValue = []
        else:
            self.EndValue = EndValue
        if StartWidth is None:
            self.StartWidth = []
        else:
            self.StartWidth = StartWidth
        if EndWidth is None:
            self.EndWidth = []
        else:
            self.EndWidth = EndWidth
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if InRangeBarPointerColor is None:
            self.InRangeBarPointerColor = []
        else:
            self.InRangeBarPointerColor = InRangeBarPointerColor
        if InRangeLabelColor is None:
            self.InRangeLabelColor = []
        else:
            self.InRangeLabelColor = InRangeLabelColor
        if InRangeTickMarksColor is None:
            self.InRangeTickMarksColor = []
        else:
            self.InRangeTickMarksColor = InRangeTickMarksColor
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ScaleRangeType.subclass:
            return ScaleRangeType.subclass(*args_, **kwargs_)
        else:
            return ScaleRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_BackgroundGradientType(self): return self.BackgroundGradientType
    def set_BackgroundGradientType(self, BackgroundGradientType): self.BackgroundGradientType = BackgroundGradientType
    def add_BackgroundGradientType(self, value): self.BackgroundGradientType.append(value)
    def insert_BackgroundGradientType(self, index, value): self.BackgroundGradientType[index] = value
    def get_ActionInfo(self): return self.ActionInfo
    def set_ActionInfo(self, ActionInfo): self.ActionInfo = ActionInfo
    def add_ActionInfo(self, value): self.ActionInfo.append(value)
    def insert_ActionInfo(self, index, value): self.ActionInfo[index] = value
    def get_ToolTip(self): return self.ToolTip
    def set_ToolTip(self, ToolTip): self.ToolTip = ToolTip
    def add_ToolTip(self, value): self.ToolTip.append(value)
    def insert_ToolTip(self, index, value): self.ToolTip[index] = value
    def get_StartValue(self): return self.StartValue
    def set_StartValue(self, StartValue): self.StartValue = StartValue
    def add_StartValue(self, value): self.StartValue.append(value)
    def insert_StartValue(self, index, value): self.StartValue[index] = value
    def get_EndValue(self): return self.EndValue
    def set_EndValue(self, EndValue): self.EndValue = EndValue
    def add_EndValue(self, value): self.EndValue.append(value)
    def insert_EndValue(self, index, value): self.EndValue[index] = value
    def get_StartWidth(self): return self.StartWidth
    def set_StartWidth(self, StartWidth): self.StartWidth = StartWidth
    def add_StartWidth(self, value): self.StartWidth.append(value)
    def insert_StartWidth(self, index, value): self.StartWidth[index] = value
    def get_EndWidth(self): return self.EndWidth
    def set_EndWidth(self, EndWidth): self.EndWidth = EndWidth
    def add_EndWidth(self, value): self.EndWidth.append(value)
    def insert_EndWidth(self, index, value): self.EndWidth[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_InRangeBarPointerColor(self): return self.InRangeBarPointerColor
    def set_InRangeBarPointerColor(self, InRangeBarPointerColor): self.InRangeBarPointerColor = InRangeBarPointerColor
    def add_InRangeBarPointerColor(self, value): self.InRangeBarPointerColor.append(value)
    def insert_InRangeBarPointerColor(self, index, value): self.InRangeBarPointerColor[index] = value
    def get_InRangeLabelColor(self): return self.InRangeLabelColor
    def set_InRangeLabelColor(self, InRangeLabelColor): self.InRangeLabelColor = InRangeLabelColor
    def add_InRangeLabelColor(self, value): self.InRangeLabelColor.append(value)
    def insert_InRangeLabelColor(self, index, value): self.InRangeLabelColor[index] = value
    def get_InRangeTickMarksColor(self): return self.InRangeTickMarksColor
    def set_InRangeTickMarksColor(self, InRangeTickMarksColor): self.InRangeTickMarksColor = InRangeTickMarksColor
    def add_InRangeTickMarksColor(self, value): self.InRangeTickMarksColor.append(value)
    def insert_InRangeTickMarksColor(self, index, value): self.InRangeTickMarksColor[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ScaleRangeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScaleRangeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScaleRangeType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ScaleRangeType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for BackgroundGradientType_ in self.BackgroundGradientType:
            showIndent(outfile, level)
            outfile.write('<%sBackgroundGradientType>%s</%sBackgroundGradientType>\n' % (namespace_, self.gds_format_string(quote_xml(BackgroundGradientType_).encode(ExternalEncoding), input_name='BackgroundGradientType'), namespace_))
        for ActionInfo_ in self.ActionInfo:
            ActionInfo_.export(outfile, level, namespace_, name_='ActionInfo')
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('<%sToolTip>%s</%sToolTip>\n' % (namespace_, self.gds_format_string(quote_xml(ToolTip_).encode(ExternalEncoding), input_name='ToolTip'), namespace_))
        for StartValue_ in self.StartValue:
            StartValue_.export(outfile, level, namespace_, name_='StartValue')
        for EndValue_ in self.EndValue:
            EndValue_.export(outfile, level, namespace_, name_='EndValue')
        for StartWidth_ in self.StartWidth:
            showIndent(outfile, level)
            outfile.write('<%sStartWidth>%s</%sStartWidth>\n' % (namespace_, self.gds_format_string(quote_xml(StartWidth_).encode(ExternalEncoding), input_name='StartWidth'), namespace_))
        for EndWidth_ in self.EndWidth:
            showIndent(outfile, level)
            outfile.write('<%sEndWidth>%s</%sEndWidth>\n' % (namespace_, self.gds_format_string(quote_xml(EndWidth_).encode(ExternalEncoding), input_name='EndWidth'), namespace_))
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for InRangeBarPointerColor_ in self.InRangeBarPointerColor:
            showIndent(outfile, level)
            outfile.write('<%sInRangeBarPointerColor>%s</%sInRangeBarPointerColor>\n' % (namespace_, self.gds_format_string(quote_xml(InRangeBarPointerColor_).encode(ExternalEncoding), input_name='InRangeBarPointerColor'), namespace_))
        for InRangeLabelColor_ in self.InRangeLabelColor:
            showIndent(outfile, level)
            outfile.write('<%sInRangeLabelColor>%s</%sInRangeLabelColor>\n' % (namespace_, self.gds_format_string(quote_xml(InRangeLabelColor_).encode(ExternalEncoding), input_name='InRangeLabelColor'), namespace_))
        for InRangeTickMarksColor_ in self.InRangeTickMarksColor:
            showIndent(outfile, level)
            outfile.write('<%sInRangeTickMarksColor>%s</%sInRangeTickMarksColor>\n' % (namespace_, self.gds_format_string(quote_xml(InRangeTickMarksColor_).encode(ExternalEncoding), input_name='InRangeTickMarksColor'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.BackgroundGradientType or
            self.ActionInfo or
            self.ToolTip or
            self.StartValue or
            self.EndValue or
            self.StartWidth or
            self.EndWidth or
            self.DistanceFromScale or
            self.InRangeBarPointerColor or
            self.InRangeLabelColor or
            self.InRangeTickMarksColor or
            self.Placement or
            self.Hidden
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScaleRangeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('BackgroundGradientType=[\n')
        level += 1
        for BackgroundGradientType_ in self.BackgroundGradientType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(BackgroundGradientType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ActionInfo=[\n')
        level += 1
        for ActionInfo_ in self.ActionInfo:
            showIndent(outfile, level)
            outfile.write('model_.ActionInfoType(\n')
            ActionInfo_.exportLiteral(outfile, level, name_='ActionInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ToolTip=[\n')
        level += 1
        for ToolTip_ in self.ToolTip:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ToolTip_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StartValue=[\n')
        level += 1
        for StartValue_ in self.StartValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            StartValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EndValue=[\n')
        level += 1
        for EndValue_ in self.EndValue:
            showIndent(outfile, level)
            outfile.write('model_.GaugeInputValueType(\n')
            EndValue_.exportLiteral(outfile, level, name_='GaugeInputValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StartWidth=[\n')
        level += 1
        for StartWidth_ in self.StartWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StartWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EndWidth=[\n')
        level += 1
        for EndWidth_ in self.EndWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EndWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InRangeBarPointerColor=[\n')
        level += 1
        for InRangeBarPointerColor_ in self.InRangeBarPointerColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InRangeBarPointerColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InRangeLabelColor=[\n')
        level += 1
        for InRangeLabelColor_ in self.InRangeLabelColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InRangeLabelColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InRangeTickMarksColor=[\n')
        level += 1
        for InRangeTickMarksColor_ in self.InRangeTickMarksColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(InRangeTickMarksColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'BackgroundGradientType':
            BackgroundGradientType_ = child_.text
            BackgroundGradientType_ = self.gds_validate_string(BackgroundGradientType_, node, 'BackgroundGradientType')
            self.BackgroundGradientType.append(BackgroundGradientType_)
        elif nodeName_ == 'ActionInfo':
            obj_ = ActionInfoType.factory()
            obj_.build(child_)
            self.ActionInfo.append(obj_)
        elif nodeName_ == 'ToolTip':
            ToolTip_ = child_.text
            ToolTip_ = self.gds_validate_string(ToolTip_, node, 'ToolTip')
            self.ToolTip.append(ToolTip_)
        elif nodeName_ == 'StartValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.StartValue.append(obj_)
        elif nodeName_ == 'EndValue':
            obj_ = GaugeInputValueType.factory()
            obj_.build(child_)
            self.EndValue.append(obj_)
        elif nodeName_ == 'StartWidth':
            StartWidth_ = child_.text
            StartWidth_ = self.gds_validate_string(StartWidth_, node, 'StartWidth')
            self.StartWidth.append(StartWidth_)
        elif nodeName_ == 'EndWidth':
            EndWidth_ = child_.text
            EndWidth_ = self.gds_validate_string(EndWidth_, node, 'EndWidth')
            self.EndWidth.append(EndWidth_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'InRangeBarPointerColor':
            InRangeBarPointerColor_ = child_.text
            InRangeBarPointerColor_ = self.gds_validate_string(InRangeBarPointerColor_, node, 'InRangeBarPointerColor')
            self.InRangeBarPointerColor.append(InRangeBarPointerColor_)
        elif nodeName_ == 'InRangeLabelColor':
            InRangeLabelColor_ = child_.text
            InRangeLabelColor_ = self.gds_validate_string(InRangeLabelColor_, node, 'InRangeLabelColor')
            self.InRangeLabelColor.append(InRangeLabelColor_)
        elif nodeName_ == 'InRangeTickMarksColor':
            InRangeTickMarksColor_ = child_.text
            InRangeTickMarksColor_ = self.gds_validate_string(InRangeTickMarksColor_, node, 'InRangeTickMarksColor')
            self.InRangeTickMarksColor.append(InRangeTickMarksColor_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
# end class ScaleRangeType


class ScaleLabelsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, Interval=None, IntervalOffset=None, AllowUpsideDown=None, DistanceFromScale=None, FontAngle=None, Placement=None, RotateLabels=None, ShowEndLabels=None, Hidden=None, UseFontPercent=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        if AllowUpsideDown is None:
            self.AllowUpsideDown = []
        else:
            self.AllowUpsideDown = AllowUpsideDown
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if FontAngle is None:
            self.FontAngle = []
        else:
            self.FontAngle = FontAngle
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if RotateLabels is None:
            self.RotateLabels = []
        else:
            self.RotateLabels = RotateLabels
        if ShowEndLabels is None:
            self.ShowEndLabels = []
        else:
            self.ShowEndLabels = ShowEndLabels
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if UseFontPercent is None:
            self.UseFontPercent = []
        else:
            self.UseFontPercent = UseFontPercent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ScaleLabelsType.subclass:
            return ScaleLabelsType.subclass(*args_, **kwargs_)
        else:
            return ScaleLabelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_AllowUpsideDown(self): return self.AllowUpsideDown
    def set_AllowUpsideDown(self, AllowUpsideDown): self.AllowUpsideDown = AllowUpsideDown
    def add_AllowUpsideDown(self, value): self.AllowUpsideDown.append(value)
    def insert_AllowUpsideDown(self, index, value): self.AllowUpsideDown[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_FontAngle(self): return self.FontAngle
    def set_FontAngle(self, FontAngle): self.FontAngle = FontAngle
    def add_FontAngle(self, value): self.FontAngle.append(value)
    def insert_FontAngle(self, index, value): self.FontAngle[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_RotateLabels(self): return self.RotateLabels
    def set_RotateLabels(self, RotateLabels): self.RotateLabels = RotateLabels
    def add_RotateLabels(self, value): self.RotateLabels.append(value)
    def insert_RotateLabels(self, index, value): self.RotateLabels[index] = value
    def get_ShowEndLabels(self): return self.ShowEndLabels
    def set_ShowEndLabels(self, ShowEndLabels): self.ShowEndLabels = ShowEndLabels
    def add_ShowEndLabels(self, value): self.ShowEndLabels.append(value)
    def insert_ShowEndLabels(self, index, value): self.ShowEndLabels[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_UseFontPercent(self): return self.UseFontPercent
    def set_UseFontPercent(self, UseFontPercent): self.UseFontPercent = UseFontPercent
    def add_UseFontPercent(self, value): self.UseFontPercent.append(value)
    def insert_UseFontPercent(self, index, value): self.UseFontPercent[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ScaleLabelsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScaleLabelsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScaleLabelsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ScaleLabelsType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
        for AllowUpsideDown_ in self.AllowUpsideDown:
            showIndent(outfile, level)
            outfile.write('<%sAllowUpsideDown>%s</%sAllowUpsideDown>\n' % (namespace_, self.gds_format_string(quote_xml(AllowUpsideDown_).encode(ExternalEncoding), input_name='AllowUpsideDown'), namespace_))
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for FontAngle_ in self.FontAngle:
            showIndent(outfile, level)
            outfile.write('<%sFontAngle>%s</%sFontAngle>\n' % (namespace_, self.gds_format_string(quote_xml(FontAngle_).encode(ExternalEncoding), input_name='FontAngle'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for RotateLabels_ in self.RotateLabels:
            showIndent(outfile, level)
            outfile.write('<%sRotateLabels>%s</%sRotateLabels>\n' % (namespace_, self.gds_format_string(quote_xml(RotateLabels_).encode(ExternalEncoding), input_name='RotateLabels'), namespace_))
        for ShowEndLabels_ in self.ShowEndLabels:
            showIndent(outfile, level)
            outfile.write('<%sShowEndLabels>%s</%sShowEndLabels>\n' % (namespace_, self.gds_format_string(quote_xml(ShowEndLabels_).encode(ExternalEncoding), input_name='ShowEndLabels'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('<%sUseFontPercent>%s</%sUseFontPercent>\n' % (namespace_, self.gds_format_string(quote_xml(UseFontPercent_).encode(ExternalEncoding), input_name='UseFontPercent'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.Interval or
            self.IntervalOffset or
            self.AllowUpsideDown or
            self.DistanceFromScale or
            self.FontAngle or
            self.Placement or
            self.RotateLabels or
            self.ShowEndLabels or
            self.Hidden or
            self.UseFontPercent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScaleLabelsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllowUpsideDown=[\n')
        level += 1
        for AllowUpsideDown_ in self.AllowUpsideDown:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllowUpsideDown_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontAngle=[\n')
        level += 1
        for FontAngle_ in self.FontAngle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontAngle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RotateLabels=[\n')
        level += 1
        for RotateLabels_ in self.RotateLabels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RotateLabels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ShowEndLabels=[\n')
        level += 1
        for ShowEndLabels_ in self.ShowEndLabels:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ShowEndLabels_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseFontPercent=[\n')
        level += 1
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseFontPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
        elif nodeName_ == 'AllowUpsideDown':
            AllowUpsideDown_ = child_.text
            AllowUpsideDown_ = self.gds_validate_string(AllowUpsideDown_, node, 'AllowUpsideDown')
            self.AllowUpsideDown.append(AllowUpsideDown_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'FontAngle':
            FontAngle_ = child_.text
            FontAngle_ = self.gds_validate_string(FontAngle_, node, 'FontAngle')
            self.FontAngle.append(FontAngle_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'RotateLabels':
            RotateLabels_ = child_.text
            RotateLabels_ = self.gds_validate_string(RotateLabels_, node, 'RotateLabels')
            self.RotateLabels.append(RotateLabels_)
        elif nodeName_ == 'ShowEndLabels':
            ShowEndLabels_ = child_.text
            ShowEndLabels_ = self.gds_validate_string(ShowEndLabels_, node, 'ShowEndLabels')
            self.ShowEndLabels.append(ShowEndLabels_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'UseFontPercent':
            UseFontPercent_ = child_.text
            UseFontPercent_ = self.gds_validate_string(UseFontPercent_, node, 'UseFontPercent')
            self.UseFontPercent.append(UseFontPercent_)
# end class ScaleLabelsType


class CustomLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Style=None, TickMarkStyle=None, Text=None, AllowUpsideDown=None, DistanceFromScale=None, FontAngle=None, Placement=None, RotateLabel=None, Value=None, Hidden=None, UseFontPercent=None):
        self.Name = _cast(None, Name)
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if TickMarkStyle is None:
            self.TickMarkStyle = []
        else:
            self.TickMarkStyle = TickMarkStyle
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if AllowUpsideDown is None:
            self.AllowUpsideDown = []
        else:
            self.AllowUpsideDown = AllowUpsideDown
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if FontAngle is None:
            self.FontAngle = []
        else:
            self.FontAngle = FontAngle
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if RotateLabel is None:
            self.RotateLabel = []
        else:
            self.RotateLabel = RotateLabel
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if UseFontPercent is None:
            self.UseFontPercent = []
        else:
            self.UseFontPercent = UseFontPercent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CustomLabelType.subclass:
            return CustomLabelType.subclass(*args_, **kwargs_)
        else:
            return CustomLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_TickMarkStyle(self): return self.TickMarkStyle
    def set_TickMarkStyle(self, TickMarkStyle): self.TickMarkStyle = TickMarkStyle
    def add_TickMarkStyle(self, value): self.TickMarkStyle.append(value)
    def insert_TickMarkStyle(self, index, value): self.TickMarkStyle[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_AllowUpsideDown(self): return self.AllowUpsideDown
    def set_AllowUpsideDown(self, AllowUpsideDown): self.AllowUpsideDown = AllowUpsideDown
    def add_AllowUpsideDown(self, value): self.AllowUpsideDown.append(value)
    def insert_AllowUpsideDown(self, index, value): self.AllowUpsideDown[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_FontAngle(self): return self.FontAngle
    def set_FontAngle(self, FontAngle): self.FontAngle = FontAngle
    def add_FontAngle(self, value): self.FontAngle.append(value)
    def insert_FontAngle(self, index, value): self.FontAngle[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_RotateLabel(self): return self.RotateLabel
    def set_RotateLabel(self, RotateLabel): self.RotateLabel = RotateLabel
    def add_RotateLabel(self, value): self.RotateLabel.append(value)
    def insert_RotateLabel(self, index, value): self.RotateLabel[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_UseFontPercent(self): return self.UseFontPercent
    def set_UseFontPercent(self, UseFontPercent): self.UseFontPercent = UseFontPercent
    def add_UseFontPercent(self, value): self.UseFontPercent.append(value)
    def insert_UseFontPercent(self, index, value): self.UseFontPercent[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CustomLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomLabelType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CustomLabelType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for TickMarkStyle_ in self.TickMarkStyle:
            TickMarkStyle_.export(outfile, level, namespace_, name_='TickMarkStyle')
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('<%sText>%s</%sText>\n' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_))
        for AllowUpsideDown_ in self.AllowUpsideDown:
            showIndent(outfile, level)
            outfile.write('<%sAllowUpsideDown>%s</%sAllowUpsideDown>\n' % (namespace_, self.gds_format_string(quote_xml(AllowUpsideDown_).encode(ExternalEncoding), input_name='AllowUpsideDown'), namespace_))
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for FontAngle_ in self.FontAngle:
            showIndent(outfile, level)
            outfile.write('<%sFontAngle>%s</%sFontAngle>\n' % (namespace_, self.gds_format_string(quote_xml(FontAngle_).encode(ExternalEncoding), input_name='FontAngle'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for RotateLabel_ in self.RotateLabel:
            showIndent(outfile, level)
            outfile.write('<%sRotateLabel>%s</%sRotateLabel>\n' % (namespace_, self.gds_format_string(quote_xml(RotateLabel_).encode(ExternalEncoding), input_name='RotateLabel'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('<%sUseFontPercent>%s</%sUseFontPercent>\n' % (namespace_, self.gds_format_string(quote_xml(UseFontPercent_).encode(ExternalEncoding), input_name='UseFontPercent'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.TickMarkStyle or
            self.Text or
            self.AllowUpsideDown or
            self.DistanceFromScale or
            self.FontAngle or
            self.Placement or
            self.RotateLabel or
            self.Value or
            self.Hidden or
            self.UseFontPercent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TickMarkStyle=[\n')
        level += 1
        for TickMarkStyle_ in self.TickMarkStyle:
            showIndent(outfile, level)
            outfile.write('model_.TickMarkStyleType(\n')
            TickMarkStyle_.exportLiteral(outfile, level, name_='TickMarkStyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllowUpsideDown=[\n')
        level += 1
        for AllowUpsideDown_ in self.AllowUpsideDown:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllowUpsideDown_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontAngle=[\n')
        level += 1
        for FontAngle_ in self.FontAngle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontAngle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RotateLabel=[\n')
        level += 1
        for RotateLabel_ in self.RotateLabel:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RotateLabel_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseFontPercent=[\n')
        level += 1
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseFontPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'TickMarkStyle':
            obj_ = TickMarkStyleType.factory()
            obj_.build(child_)
            self.TickMarkStyle.append(obj_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'AllowUpsideDown':
            AllowUpsideDown_ = child_.text
            AllowUpsideDown_ = self.gds_validate_string(AllowUpsideDown_, node, 'AllowUpsideDown')
            self.AllowUpsideDown.append(AllowUpsideDown_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'FontAngle':
            FontAngle_ = child_.text
            FontAngle_ = self.gds_validate_string(FontAngle_, node, 'FontAngle')
            self.FontAngle.append(FontAngle_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'RotateLabel':
            RotateLabel_ = child_.text
            RotateLabel_ = self.gds_validate_string(RotateLabel_, node, 'RotateLabel')
            self.RotateLabel.append(RotateLabel_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'UseFontPercent':
            UseFontPercent_ = child_.text
            UseFontPercent_ = self.gds_validate_string(UseFontPercent_, node, 'UseFontPercent')
            self.UseFontPercent.append(UseFontPercent_)
# end class CustomLabelType


class TickMarkStyleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, TickMarkImage=None, DistanceFromScale=None, Placement=None, EnableGradient=None, GradientDensity=None, Length=None, Width=None, Shape=None, Hidden=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if TickMarkImage is None:
            self.TickMarkImage = []
        else:
            self.TickMarkImage = TickMarkImage
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if EnableGradient is None:
            self.EnableGradient = []
        else:
            self.EnableGradient = EnableGradient
        if GradientDensity is None:
            self.GradientDensity = []
        else:
            self.GradientDensity = GradientDensity
        if Length is None:
            self.Length = []
        else:
            self.Length = Length
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if Shape is None:
            self.Shape = []
        else:
            self.Shape = Shape
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TickMarkStyleType.subclass:
            return TickMarkStyleType.subclass(*args_, **kwargs_)
        else:
            return TickMarkStyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_TickMarkImage(self): return self.TickMarkImage
    def set_TickMarkImage(self, TickMarkImage): self.TickMarkImage = TickMarkImage
    def add_TickMarkImage(self, value): self.TickMarkImage.append(value)
    def insert_TickMarkImage(self, index, value): self.TickMarkImage[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_EnableGradient(self): return self.EnableGradient
    def set_EnableGradient(self, EnableGradient): self.EnableGradient = EnableGradient
    def add_EnableGradient(self, value): self.EnableGradient.append(value)
    def insert_EnableGradient(self, index, value): self.EnableGradient[index] = value
    def get_GradientDensity(self): return self.GradientDensity
    def set_GradientDensity(self, GradientDensity): self.GradientDensity = GradientDensity
    def add_GradientDensity(self, value): self.GradientDensity.append(value)
    def insert_GradientDensity(self, index, value): self.GradientDensity[index] = value
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def add_Length(self, value): self.Length.append(value)
    def insert_Length(self, index, value): self.Length[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_Shape(self): return self.Shape
    def set_Shape(self, Shape): self.Shape = Shape
    def add_Shape(self, value): self.Shape.append(value)
    def insert_Shape(self, index, value): self.Shape[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TickMarkStyleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TickMarkStyleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TickMarkStyleType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TickMarkStyleType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for TickMarkImage_ in self.TickMarkImage:
            TickMarkImage_.export(outfile, level, namespace_, name_='TickMarkImage')
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for EnableGradient_ in self.EnableGradient:
            showIndent(outfile, level)
            outfile.write('<%sEnableGradient>%s</%sEnableGradient>\n' % (namespace_, self.gds_format_string(quote_xml(EnableGradient_).encode(ExternalEncoding), input_name='EnableGradient'), namespace_))
        for GradientDensity_ in self.GradientDensity:
            showIndent(outfile, level)
            outfile.write('<%sGradientDensity>%s</%sGradientDensity>\n' % (namespace_, self.gds_format_string(quote_xml(GradientDensity_).encode(ExternalEncoding), input_name='GradientDensity'), namespace_))
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('<%sLength>%s</%sLength>\n' % (namespace_, self.gds_format_string(quote_xml(Length_).encode(ExternalEncoding), input_name='Length'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for Shape_ in self.Shape:
            showIndent(outfile, level)
            outfile.write('<%sShape>%s</%sShape>\n' % (namespace_, self.gds_format_string(quote_xml(Shape_).encode(ExternalEncoding), input_name='Shape'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.TickMarkImage or
            self.DistanceFromScale or
            self.Placement or
            self.EnableGradient or
            self.GradientDensity or
            self.Length or
            self.Width or
            self.Shape or
            self.Hidden
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TickMarkStyleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TickMarkImage=[\n')
        level += 1
        for TickMarkImage_ in self.TickMarkImage:
            showIndent(outfile, level)
            outfile.write('model_.TopImageType(\n')
            TickMarkImage_.exportLiteral(outfile, level, name_='TopImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EnableGradient=[\n')
        level += 1
        for EnableGradient_ in self.EnableGradient:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EnableGradient_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GradientDensity=[\n')
        level += 1
        for GradientDensity_ in self.GradientDensity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GradientDensity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Length=[\n')
        level += 1
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Length_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Shape=[\n')
        level += 1
        for Shape_ in self.Shape:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Shape_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'TickMarkImage':
            obj_ = TopImageType.factory()
            obj_.build(child_)
            self.TickMarkImage.append(obj_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'EnableGradient':
            EnableGradient_ = child_.text
            EnableGradient_ = self.gds_validate_string(EnableGradient_, node, 'EnableGradient')
            self.EnableGradient.append(EnableGradient_)
        elif nodeName_ == 'GradientDensity':
            GradientDensity_ = child_.text
            GradientDensity_ = self.gds_validate_string(GradientDensity_, node, 'GradientDensity')
            self.GradientDensity.append(GradientDensity_)
        elif nodeName_ == 'Length':
            Length_ = child_.text
            Length_ = self.gds_validate_string(Length_, node, 'Length')
            self.Length.append(Length_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'Shape':
            Shape_ = child_.text
            Shape_ = self.gds_validate_string(Shape_, node, 'Shape')
            self.Shape.append(Shape_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
# end class TickMarkStyleType


class GaugeTickMarksType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, TickMarkImage=None, DistanceFromScale=None, Placement=None, EnableGradient=None, GradientDensity=None, Length=None, Width=None, Shape=None, Hidden=None, Interval=None, IntervalOffset=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if TickMarkImage is None:
            self.TickMarkImage = []
        else:
            self.TickMarkImage = TickMarkImage
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if EnableGradient is None:
            self.EnableGradient = []
        else:
            self.EnableGradient = EnableGradient
        if GradientDensity is None:
            self.GradientDensity = []
        else:
            self.GradientDensity = GradientDensity
        if Length is None:
            self.Length = []
        else:
            self.Length = Length
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if Shape is None:
            self.Shape = []
        else:
            self.Shape = Shape
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Interval is None:
            self.Interval = []
        else:
            self.Interval = Interval
        if IntervalOffset is None:
            self.IntervalOffset = []
        else:
            self.IntervalOffset = IntervalOffset
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeTickMarksType.subclass:
            return GaugeTickMarksType.subclass(*args_, **kwargs_)
        else:
            return GaugeTickMarksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_TickMarkImage(self): return self.TickMarkImage
    def set_TickMarkImage(self, TickMarkImage): self.TickMarkImage = TickMarkImage
    def add_TickMarkImage(self, value): self.TickMarkImage.append(value)
    def insert_TickMarkImage(self, index, value): self.TickMarkImage[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_EnableGradient(self): return self.EnableGradient
    def set_EnableGradient(self, EnableGradient): self.EnableGradient = EnableGradient
    def add_EnableGradient(self, value): self.EnableGradient.append(value)
    def insert_EnableGradient(self, index, value): self.EnableGradient[index] = value
    def get_GradientDensity(self): return self.GradientDensity
    def set_GradientDensity(self, GradientDensity): self.GradientDensity = GradientDensity
    def add_GradientDensity(self, value): self.GradientDensity.append(value)
    def insert_GradientDensity(self, index, value): self.GradientDensity[index] = value
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def add_Length(self, value): self.Length.append(value)
    def insert_Length(self, index, value): self.Length[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_Shape(self): return self.Shape
    def set_Shape(self, Shape): self.Shape = Shape
    def add_Shape(self, value): self.Shape.append(value)
    def insert_Shape(self, index, value): self.Shape[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def add_Interval(self, value): self.Interval.append(value)
    def insert_Interval(self, index, value): self.Interval[index] = value
    def get_IntervalOffset(self): return self.IntervalOffset
    def set_IntervalOffset(self, IntervalOffset): self.IntervalOffset = IntervalOffset
    def add_IntervalOffset(self, value): self.IntervalOffset.append(value)
    def insert_IntervalOffset(self, index, value): self.IntervalOffset[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeTickMarksType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeTickMarksType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeTickMarksType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeTickMarksType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for TickMarkImage_ in self.TickMarkImage:
            TickMarkImage_.export(outfile, level, namespace_, name_='TickMarkImage')
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for EnableGradient_ in self.EnableGradient:
            showIndent(outfile, level)
            outfile.write('<%sEnableGradient>%s</%sEnableGradient>\n' % (namespace_, self.gds_format_string(quote_xml(EnableGradient_).encode(ExternalEncoding), input_name='EnableGradient'), namespace_))
        for GradientDensity_ in self.GradientDensity:
            showIndent(outfile, level)
            outfile.write('<%sGradientDensity>%s</%sGradientDensity>\n' % (namespace_, self.gds_format_string(quote_xml(GradientDensity_).encode(ExternalEncoding), input_name='GradientDensity'), namespace_))
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('<%sLength>%s</%sLength>\n' % (namespace_, self.gds_format_string(quote_xml(Length_).encode(ExternalEncoding), input_name='Length'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for Shape_ in self.Shape:
            showIndent(outfile, level)
            outfile.write('<%sShape>%s</%sShape>\n' % (namespace_, self.gds_format_string(quote_xml(Shape_).encode(ExternalEncoding), input_name='Shape'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('<%sInterval>%s</%sInterval>\n' % (namespace_, self.gds_format_string(quote_xml(Interval_).encode(ExternalEncoding), input_name='Interval'), namespace_))
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('<%sIntervalOffset>%s</%sIntervalOffset>\n' % (namespace_, self.gds_format_string(quote_xml(IntervalOffset_).encode(ExternalEncoding), input_name='IntervalOffset'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.TickMarkImage or
            self.DistanceFromScale or
            self.Placement or
            self.EnableGradient or
            self.GradientDensity or
            self.Length or
            self.Width or
            self.Shape or
            self.Hidden or
            self.Interval or
            self.IntervalOffset
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeTickMarksType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TickMarkImage=[\n')
        level += 1
        for TickMarkImage_ in self.TickMarkImage:
            showIndent(outfile, level)
            outfile.write('model_.TopImageType(\n')
            TickMarkImage_.exportLiteral(outfile, level, name_='TopImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EnableGradient=[\n')
        level += 1
        for EnableGradient_ in self.EnableGradient:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EnableGradient_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GradientDensity=[\n')
        level += 1
        for GradientDensity_ in self.GradientDensity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GradientDensity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Length=[\n')
        level += 1
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Length_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Shape=[\n')
        level += 1
        for Shape_ in self.Shape:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Shape_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Interval=[\n')
        level += 1
        for Interval_ in self.Interval:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Interval_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IntervalOffset=[\n')
        level += 1
        for IntervalOffset_ in self.IntervalOffset:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IntervalOffset_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'TickMarkImage':
            obj_ = TopImageType.factory()
            obj_.build(child_)
            self.TickMarkImage.append(obj_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'EnableGradient':
            EnableGradient_ = child_.text
            EnableGradient_ = self.gds_validate_string(EnableGradient_, node, 'EnableGradient')
            self.EnableGradient.append(EnableGradient_)
        elif nodeName_ == 'GradientDensity':
            GradientDensity_ = child_.text
            GradientDensity_ = self.gds_validate_string(GradientDensity_, node, 'GradientDensity')
            self.GradientDensity.append(GradientDensity_)
        elif nodeName_ == 'Length':
            Length_ = child_.text
            Length_ = self.gds_validate_string(Length_, node, 'Length')
            self.Length.append(Length_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'Shape':
            Shape_ = child_.text
            Shape_ = self.gds_validate_string(Shape_, node, 'Shape')
            self.Shape.append(Shape_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval.append(Interval_)
        elif nodeName_ == 'IntervalOffset':
            IntervalOffset_ = child_.text
            IntervalOffset_ = self.gds_validate_string(IntervalOffset_, node, 'IntervalOffset')
            self.IntervalOffset.append(IntervalOffset_)
# end class GaugeTickMarksType


class ScalePinType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, TickMarkImage=None, DistanceFromScale=None, Placement=None, EnableGradient=None, GradientDensity=None, Length=None, Width=None, Shape=None, Hidden=None, Location=None, Enable=None, PinLabel=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if TickMarkImage is None:
            self.TickMarkImage = []
        else:
            self.TickMarkImage = TickMarkImage
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if EnableGradient is None:
            self.EnableGradient = []
        else:
            self.EnableGradient = EnableGradient
        if GradientDensity is None:
            self.GradientDensity = []
        else:
            self.GradientDensity = GradientDensity
        if Length is None:
            self.Length = []
        else:
            self.Length = Length
        if Width is None:
            self.Width = []
        else:
            self.Width = Width
        if Shape is None:
            self.Shape = []
        else:
            self.Shape = Shape
        if Hidden is None:
            self.Hidden = []
        else:
            self.Hidden = Hidden
        if Location is None:
            self.Location = []
        else:
            self.Location = Location
        if Enable is None:
            self.Enable = []
        else:
            self.Enable = Enable
        if PinLabel is None:
            self.PinLabel = []
        else:
            self.PinLabel = PinLabel
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ScalePinType.subclass:
            return ScalePinType.subclass(*args_, **kwargs_)
        else:
            return ScalePinType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_TickMarkImage(self): return self.TickMarkImage
    def set_TickMarkImage(self, TickMarkImage): self.TickMarkImage = TickMarkImage
    def add_TickMarkImage(self, value): self.TickMarkImage.append(value)
    def insert_TickMarkImage(self, index, value): self.TickMarkImage[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_EnableGradient(self): return self.EnableGradient
    def set_EnableGradient(self, EnableGradient): self.EnableGradient = EnableGradient
    def add_EnableGradient(self, value): self.EnableGradient.append(value)
    def insert_EnableGradient(self, index, value): self.EnableGradient[index] = value
    def get_GradientDensity(self): return self.GradientDensity
    def set_GradientDensity(self, GradientDensity): self.GradientDensity = GradientDensity
    def add_GradientDensity(self, value): self.GradientDensity.append(value)
    def insert_GradientDensity(self, index, value): self.GradientDensity[index] = value
    def get_Length(self): return self.Length
    def set_Length(self, Length): self.Length = Length
    def add_Length(self, value): self.Length.append(value)
    def insert_Length(self, index, value): self.Length[index] = value
    def get_Width(self): return self.Width
    def set_Width(self, Width): self.Width = Width
    def add_Width(self, value): self.Width.append(value)
    def insert_Width(self, index, value): self.Width[index] = value
    def get_Shape(self): return self.Shape
    def set_Shape(self, Shape): self.Shape = Shape
    def add_Shape(self, value): self.Shape.append(value)
    def insert_Shape(self, index, value): self.Shape[index] = value
    def get_Hidden(self): return self.Hidden
    def set_Hidden(self, Hidden): self.Hidden = Hidden
    def add_Hidden(self, value): self.Hidden.append(value)
    def insert_Hidden(self, index, value): self.Hidden[index] = value
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def add_Location(self, value): self.Location.append(value)
    def insert_Location(self, index, value): self.Location[index] = value
    def get_Enable(self): return self.Enable
    def set_Enable(self, Enable): self.Enable = Enable
    def add_Enable(self, value): self.Enable.append(value)
    def insert_Enable(self, index, value): self.Enable[index] = value
    def get_PinLabel(self): return self.PinLabel
    def set_PinLabel(self, PinLabel): self.PinLabel = PinLabel
    def add_PinLabel(self, value): self.PinLabel.append(value)
    def insert_PinLabel(self, index, value): self.PinLabel[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ScalePinType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScalePinType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScalePinType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ScalePinType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for TickMarkImage_ in self.TickMarkImage:
            TickMarkImage_.export(outfile, level, namespace_, name_='TickMarkImage')
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for EnableGradient_ in self.EnableGradient:
            showIndent(outfile, level)
            outfile.write('<%sEnableGradient>%s</%sEnableGradient>\n' % (namespace_, self.gds_format_string(quote_xml(EnableGradient_).encode(ExternalEncoding), input_name='EnableGradient'), namespace_))
        for GradientDensity_ in self.GradientDensity:
            showIndent(outfile, level)
            outfile.write('<%sGradientDensity>%s</%sGradientDensity>\n' % (namespace_, self.gds_format_string(quote_xml(GradientDensity_).encode(ExternalEncoding), input_name='GradientDensity'), namespace_))
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('<%sLength>%s</%sLength>\n' % (namespace_, self.gds_format_string(quote_xml(Length_).encode(ExternalEncoding), input_name='Length'), namespace_))
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('<%sWidth>%s</%sWidth>\n' % (namespace_, self.gds_format_string(quote_xml(Width_).encode(ExternalEncoding), input_name='Width'), namespace_))
        for Shape_ in self.Shape:
            showIndent(outfile, level)
            outfile.write('<%sShape>%s</%sShape>\n' % (namespace_, self.gds_format_string(quote_xml(Shape_).encode(ExternalEncoding), input_name='Shape'), namespace_))
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('<%sHidden>%s</%sHidden>\n' % (namespace_, self.gds_format_string(quote_xml(Hidden_).encode(ExternalEncoding), input_name='Hidden'), namespace_))
        for Location_ in self.Location:
            showIndent(outfile, level)
            outfile.write('<%sLocation>%s</%sLocation>\n' % (namespace_, self.gds_format_string(quote_xml(Location_).encode(ExternalEncoding), input_name='Location'), namespace_))
        for Enable_ in self.Enable:
            showIndent(outfile, level)
            outfile.write('<%sEnable>%s</%sEnable>\n' % (namespace_, self.gds_format_string(quote_xml(Enable_).encode(ExternalEncoding), input_name='Enable'), namespace_))
        for PinLabel_ in self.PinLabel:
            PinLabel_.export(outfile, level, namespace_, name_='PinLabel')
    def hasContent_(self):
        if (
            self.Style or
            self.TickMarkImage or
            self.DistanceFromScale or
            self.Placement or
            self.EnableGradient or
            self.GradientDensity or
            self.Length or
            self.Width or
            self.Shape or
            self.Hidden or
            self.Location or
            self.Enable or
            self.PinLabel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScalePinType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TickMarkImage=[\n')
        level += 1
        for TickMarkImage_ in self.TickMarkImage:
            showIndent(outfile, level)
            outfile.write('model_.TopImageType(\n')
            TickMarkImage_.exportLiteral(outfile, level, name_='TopImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EnableGradient=[\n')
        level += 1
        for EnableGradient_ in self.EnableGradient:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(EnableGradient_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GradientDensity=[\n')
        level += 1
        for GradientDensity_ in self.GradientDensity:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GradientDensity_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Length=[\n')
        level += 1
        for Length_ in self.Length:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Length_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Width=[\n')
        level += 1
        for Width_ in self.Width:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Width_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Shape=[\n')
        level += 1
        for Shape_ in self.Shape:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Shape_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hidden=[\n')
        level += 1
        for Hidden_ in self.Hidden:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Hidden_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Location=[\n')
        level += 1
        for Location_ in self.Location:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Location_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Enable=[\n')
        level += 1
        for Enable_ in self.Enable:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Enable_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PinLabel=[\n')
        level += 1
        for PinLabel_ in self.PinLabel:
            showIndent(outfile, level)
            outfile.write('model_.PinLabelType(\n')
            PinLabel_.exportLiteral(outfile, level, name_='PinLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'TickMarkImage':
            obj_ = TopImageType.factory()
            obj_.build(child_)
            self.TickMarkImage.append(obj_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'EnableGradient':
            EnableGradient_ = child_.text
            EnableGradient_ = self.gds_validate_string(EnableGradient_, node, 'EnableGradient')
            self.EnableGradient.append(EnableGradient_)
        elif nodeName_ == 'GradientDensity':
            GradientDensity_ = child_.text
            GradientDensity_ = self.gds_validate_string(GradientDensity_, node, 'GradientDensity')
            self.GradientDensity.append(GradientDensity_)
        elif nodeName_ == 'Length':
            Length_ = child_.text
            Length_ = self.gds_validate_string(Length_, node, 'Length')
            self.Length.append(Length_)
        elif nodeName_ == 'Width':
            Width_ = child_.text
            Width_ = self.gds_validate_string(Width_, node, 'Width')
            self.Width.append(Width_)
        elif nodeName_ == 'Shape':
            Shape_ = child_.text
            Shape_ = self.gds_validate_string(Shape_, node, 'Shape')
            self.Shape.append(Shape_)
        elif nodeName_ == 'Hidden':
            Hidden_ = child_.text
            Hidden_ = self.gds_validate_string(Hidden_, node, 'Hidden')
            self.Hidden.append(Hidden_)
        elif nodeName_ == 'Location':
            Location_ = child_.text
            Location_ = self.gds_validate_string(Location_, node, 'Location')
            self.Location.append(Location_)
        elif nodeName_ == 'Enable':
            Enable_ = child_.text
            Enable_ = self.gds_validate_string(Enable_, node, 'Enable')
            self.Enable.append(Enable_)
        elif nodeName_ == 'PinLabel':
            obj_ = PinLabelType.factory()
            obj_.build(child_)
            self.PinLabel.append(obj_)
# end class ScalePinType


class PinLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, Text=None, AllowUpsideDown=None, DistanceFromScale=None, FontAngle=None, Placement=None, RotateLabel=None, UseFontPercent=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if AllowUpsideDown is None:
            self.AllowUpsideDown = []
        else:
            self.AllowUpsideDown = AllowUpsideDown
        if DistanceFromScale is None:
            self.DistanceFromScale = []
        else:
            self.DistanceFromScale = DistanceFromScale
        if FontAngle is None:
            self.FontAngle = []
        else:
            self.FontAngle = FontAngle
        if Placement is None:
            self.Placement = []
        else:
            self.Placement = Placement
        if RotateLabel is None:
            self.RotateLabel = []
        else:
            self.RotateLabel = RotateLabel
        if UseFontPercent is None:
            self.UseFontPercent = []
        else:
            self.UseFontPercent = UseFontPercent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PinLabelType.subclass:
            return PinLabelType.subclass(*args_, **kwargs_)
        else:
            return PinLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_AllowUpsideDown(self): return self.AllowUpsideDown
    def set_AllowUpsideDown(self, AllowUpsideDown): self.AllowUpsideDown = AllowUpsideDown
    def add_AllowUpsideDown(self, value): self.AllowUpsideDown.append(value)
    def insert_AllowUpsideDown(self, index, value): self.AllowUpsideDown[index] = value
    def get_DistanceFromScale(self): return self.DistanceFromScale
    def set_DistanceFromScale(self, DistanceFromScale): self.DistanceFromScale = DistanceFromScale
    def add_DistanceFromScale(self, value): self.DistanceFromScale.append(value)
    def insert_DistanceFromScale(self, index, value): self.DistanceFromScale[index] = value
    def get_FontAngle(self): return self.FontAngle
    def set_FontAngle(self, FontAngle): self.FontAngle = FontAngle
    def add_FontAngle(self, value): self.FontAngle.append(value)
    def insert_FontAngle(self, index, value): self.FontAngle[index] = value
    def get_Placement(self): return self.Placement
    def set_Placement(self, Placement): self.Placement = Placement
    def add_Placement(self, value): self.Placement.append(value)
    def insert_Placement(self, index, value): self.Placement[index] = value
    def get_RotateLabel(self): return self.RotateLabel
    def set_RotateLabel(self, RotateLabel): self.RotateLabel = RotateLabel
    def add_RotateLabel(self, value): self.RotateLabel.append(value)
    def insert_RotateLabel(self, index, value): self.RotateLabel[index] = value
    def get_UseFontPercent(self): return self.UseFontPercent
    def set_UseFontPercent(self, UseFontPercent): self.UseFontPercent = UseFontPercent
    def add_UseFontPercent(self, value): self.UseFontPercent.append(value)
    def insert_UseFontPercent(self, index, value): self.UseFontPercent[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PinLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PinLabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PinLabelType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PinLabelType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('<%sText>%s</%sText>\n' % (namespace_, self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), namespace_))
        for AllowUpsideDown_ in self.AllowUpsideDown:
            showIndent(outfile, level)
            outfile.write('<%sAllowUpsideDown>%s</%sAllowUpsideDown>\n' % (namespace_, self.gds_format_string(quote_xml(AllowUpsideDown_).encode(ExternalEncoding), input_name='AllowUpsideDown'), namespace_))
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('<%sDistanceFromScale>%s</%sDistanceFromScale>\n' % (namespace_, self.gds_format_string(quote_xml(DistanceFromScale_).encode(ExternalEncoding), input_name='DistanceFromScale'), namespace_))
        for FontAngle_ in self.FontAngle:
            showIndent(outfile, level)
            outfile.write('<%sFontAngle>%s</%sFontAngle>\n' % (namespace_, self.gds_format_string(quote_xml(FontAngle_).encode(ExternalEncoding), input_name='FontAngle'), namespace_))
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('<%sPlacement>%s</%sPlacement>\n' % (namespace_, self.gds_format_string(quote_xml(Placement_).encode(ExternalEncoding), input_name='Placement'), namespace_))
        for RotateLabel_ in self.RotateLabel:
            showIndent(outfile, level)
            outfile.write('<%sRotateLabel>%s</%sRotateLabel>\n' % (namespace_, self.gds_format_string(quote_xml(RotateLabel_).encode(ExternalEncoding), input_name='RotateLabel'), namespace_))
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('<%sUseFontPercent>%s</%sUseFontPercent>\n' % (namespace_, self.gds_format_string(quote_xml(UseFontPercent_).encode(ExternalEncoding), input_name='UseFontPercent'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.Text or
            self.AllowUpsideDown or
            self.DistanceFromScale or
            self.FontAngle or
            self.Placement or
            self.RotateLabel or
            self.UseFontPercent
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PinLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllowUpsideDown=[\n')
        level += 1
        for AllowUpsideDown_ in self.AllowUpsideDown:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllowUpsideDown_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DistanceFromScale=[\n')
        level += 1
        for DistanceFromScale_ in self.DistanceFromScale:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DistanceFromScale_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FontAngle=[\n')
        level += 1
        for FontAngle_ in self.FontAngle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FontAngle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Placement=[\n')
        level += 1
        for Placement_ in self.Placement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Placement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RotateLabel=[\n')
        level += 1
        for RotateLabel_ in self.RotateLabel:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(RotateLabel_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('UseFontPercent=[\n')
        level += 1
        for UseFontPercent_ in self.UseFontPercent:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(UseFontPercent_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'AllowUpsideDown':
            AllowUpsideDown_ = child_.text
            AllowUpsideDown_ = self.gds_validate_string(AllowUpsideDown_, node, 'AllowUpsideDown')
            self.AllowUpsideDown.append(AllowUpsideDown_)
        elif nodeName_ == 'DistanceFromScale':
            DistanceFromScale_ = child_.text
            DistanceFromScale_ = self.gds_validate_string(DistanceFromScale_, node, 'DistanceFromScale')
            self.DistanceFromScale.append(DistanceFromScale_)
        elif nodeName_ == 'FontAngle':
            FontAngle_ = child_.text
            FontAngle_ = self.gds_validate_string(FontAngle_, node, 'FontAngle')
            self.FontAngle.append(FontAngle_)
        elif nodeName_ == 'Placement':
            Placement_ = child_.text
            Placement_ = self.gds_validate_string(Placement_, node, 'Placement')
            self.Placement.append(Placement_)
        elif nodeName_ == 'RotateLabel':
            RotateLabel_ = child_.text
            RotateLabel_ = self.gds_validate_string(RotateLabel_, node, 'RotateLabel')
            self.RotateLabel.append(RotateLabel_)
        elif nodeName_ == 'UseFontPercent':
            UseFontPercent_ = child_.text
            UseFontPercent_ = self.gds_validate_string(UseFontPercent_, node, 'UseFontPercent')
            self.UseFontPercent.append(UseFontPercent_)
# end class PinLabelType


class TopImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Value=None, MIMEType=None, TransparentColor=None, HueColor=None):
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if HueColor is None:
            self.HueColor = []
        else:
            self.HueColor = HueColor
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TopImageType.subclass:
            return TopImageType.subclass(*args_, **kwargs_)
        else:
            return TopImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_HueColor(self): return self.HueColor
    def set_HueColor(self, HueColor): self.HueColor = HueColor
    def add_HueColor(self, value): self.HueColor.append(value)
    def insert_HueColor(self, index, value): self.HueColor[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='TopImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TopImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TopImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TopImageType', fromsubclass_=False):
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('<%sHueColor>%s</%sHueColor>\n' % (namespace_, self.gds_format_string(quote_xml(HueColor_).encode(ExternalEncoding), input_name='HueColor'), namespace_))
    def hasContent_(self):
        if (
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.HueColor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TopImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HueColor=[\n')
        level += 1
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HueColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'HueColor':
            HueColor_ = child_.text
            HueColor_ = self.gds_validate_string(HueColor_, node, 'HueColor')
            self.HueColor.append(HueColor_)
# end class TopImageType


class StateImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Value=None, MIMEType=None, TransparentColor=None, HueColor=None, Transparency=None):
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if HueColor is None:
            self.HueColor = []
        else:
            self.HueColor = HueColor
        if Transparency is None:
            self.Transparency = []
        else:
            self.Transparency = Transparency
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if StateImageType.subclass:
            return StateImageType.subclass(*args_, **kwargs_)
        else:
            return StateImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_HueColor(self): return self.HueColor
    def set_HueColor(self, HueColor): self.HueColor = HueColor
    def add_HueColor(self, value): self.HueColor.append(value)
    def insert_HueColor(self, index, value): self.HueColor[index] = value
    def get_Transparency(self): return self.Transparency
    def set_Transparency(self, Transparency): self.Transparency = Transparency
    def add_Transparency(self, value): self.Transparency.append(value)
    def insert_Transparency(self, index, value): self.Transparency[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='StateImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StateImageType', fromsubclass_=False):
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('<%sHueColor>%s</%sHueColor>\n' % (namespace_, self.gds_format_string(quote_xml(HueColor_).encode(ExternalEncoding), input_name='HueColor'), namespace_))
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('<%sTransparency>%s</%sTransparency>\n' % (namespace_, self.gds_format_string(quote_xml(Transparency_).encode(ExternalEncoding), input_name='Transparency'), namespace_))
    def hasContent_(self):
        if (
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.HueColor or
            self.Transparency
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HueColor=[\n')
        level += 1
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HueColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Transparency=[\n')
        level += 1
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transparency_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'HueColor':
            HueColor_ = child_.text
            HueColor_ = self.gds_validate_string(HueColor_, node, 'HueColor')
            self.HueColor.append(HueColor_)
        elif nodeName_ == 'Transparency':
            Transparency_ = child_.text
            Transparency_ = self.gds_validate_string(Transparency_, node, 'Transparency')
            self.Transparency.append(Transparency_)
# end class StateImageType


class PointerImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Value=None, MIMEType=None, TransparentColor=None, HueColor=None, Transparency=None, OffsetX=None, OffsetY=None):
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if HueColor is None:
            self.HueColor = []
        else:
            self.HueColor = HueColor
        if Transparency is None:
            self.Transparency = []
        else:
            self.Transparency = Transparency
        if OffsetX is None:
            self.OffsetX = []
        else:
            self.OffsetX = OffsetX
        if OffsetY is None:
            self.OffsetY = []
        else:
            self.OffsetY = OffsetY
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PointerImageType.subclass:
            return PointerImageType.subclass(*args_, **kwargs_)
        else:
            return PointerImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_HueColor(self): return self.HueColor
    def set_HueColor(self, HueColor): self.HueColor = HueColor
    def add_HueColor(self, value): self.HueColor.append(value)
    def insert_HueColor(self, index, value): self.HueColor[index] = value
    def get_Transparency(self): return self.Transparency
    def set_Transparency(self, Transparency): self.Transparency = Transparency
    def add_Transparency(self, value): self.Transparency.append(value)
    def insert_Transparency(self, index, value): self.Transparency[index] = value
    def get_OffsetX(self): return self.OffsetX
    def set_OffsetX(self, OffsetX): self.OffsetX = OffsetX
    def add_OffsetX(self, value): self.OffsetX.append(value)
    def insert_OffsetX(self, index, value): self.OffsetX[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_OffsetY(self): return self.OffsetY
    def set_OffsetY(self, OffsetY): self.OffsetY = OffsetY
    def add_OffsetY(self, value): self.OffsetY.append(value)
    def insert_OffsetY(self, index, value): self.OffsetY[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='PointerImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointerImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointerImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PointerImageType', fromsubclass_=False):
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('<%sHueColor>%s</%sHueColor>\n' % (namespace_, self.gds_format_string(quote_xml(HueColor_).encode(ExternalEncoding), input_name='HueColor'), namespace_))
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('<%sTransparency>%s</%sTransparency>\n' % (namespace_, self.gds_format_string(quote_xml(Transparency_).encode(ExternalEncoding), input_name='Transparency'), namespace_))
        for OffsetX_ in self.OffsetX:
            showIndent(outfile, level)
            outfile.write('<%sOffsetX>%s</%sOffsetX>\n' % (namespace_, self.gds_format_string(quote_xml(OffsetX_).encode(ExternalEncoding), input_name='OffsetX'), namespace_))
        for OffsetY_ in self.OffsetY:
            showIndent(outfile, level)
            outfile.write('<%sOffsetY>%s</%sOffsetY>\n' % (namespace_, self.gds_format_string(quote_xml(OffsetY_).encode(ExternalEncoding), input_name='OffsetY'), namespace_))
    def hasContent_(self):
        if (
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.HueColor or
            self.Transparency or
            self.OffsetX or
            self.OffsetY
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointerImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HueColor=[\n')
        level += 1
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HueColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Transparency=[\n')
        level += 1
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transparency_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffsetX=[\n')
        level += 1
        for OffsetX_ in self.OffsetX:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OffsetX_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffsetY=[\n')
        level += 1
        for OffsetY_ in self.OffsetY:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OffsetY_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'HueColor':
            HueColor_ = child_.text
            HueColor_ = self.gds_validate_string(HueColor_, node, 'HueColor')
            self.HueColor.append(HueColor_)
        elif nodeName_ == 'Transparency':
            Transparency_ = child_.text
            Transparency_ = self.gds_validate_string(Transparency_, node, 'Transparency')
            self.Transparency.append(Transparency_)
        elif nodeName_ == 'OffsetX':
            OffsetX_ = child_.text
            OffsetX_ = self.gds_validate_string(OffsetX_, node, 'OffsetX')
            self.OffsetX.append(OffsetX_)
            self.validate_SizeType(self.OffsetX)    # validate type SizeType
        elif nodeName_ == 'OffsetY':
            OffsetY_ = child_.text
            OffsetY_ = self.gds_validate_string(OffsetY_, node, 'OffsetY')
            self.OffsetY.append(OffsetY_)
            self.validate_SizeType(self.OffsetY)    # validate type SizeType
# end class PointerImageType


class CapImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Value=None, MIMEType=None, TransparentColor=None, HueColor=None, OffsetX=None, OffsetY=None):
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if HueColor is None:
            self.HueColor = []
        else:
            self.HueColor = HueColor
        if OffsetX is None:
            self.OffsetX = []
        else:
            self.OffsetX = OffsetX
        if OffsetY is None:
            self.OffsetY = []
        else:
            self.OffsetY = OffsetY
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CapImageType.subclass:
            return CapImageType.subclass(*args_, **kwargs_)
        else:
            return CapImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_HueColor(self): return self.HueColor
    def set_HueColor(self, HueColor): self.HueColor = HueColor
    def add_HueColor(self, value): self.HueColor.append(value)
    def insert_HueColor(self, index, value): self.HueColor[index] = value
    def get_OffsetX(self): return self.OffsetX
    def set_OffsetX(self, OffsetX): self.OffsetX = OffsetX
    def add_OffsetX(self, value): self.OffsetX.append(value)
    def insert_OffsetX(self, index, value): self.OffsetX[index] = value
    def validate_SizeType(self, value):
        # Validate type SizeType, a restriction on xsd:normalizedString.
        pass
    def get_OffsetY(self): return self.OffsetY
    def set_OffsetY(self, OffsetY): self.OffsetY = OffsetY
    def add_OffsetY(self, value): self.OffsetY.append(value)
    def insert_OffsetY(self, index, value): self.OffsetY[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CapImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CapImageType', fromsubclass_=False):
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('<%sHueColor>%s</%sHueColor>\n' % (namespace_, self.gds_format_string(quote_xml(HueColor_).encode(ExternalEncoding), input_name='HueColor'), namespace_))
        for OffsetX_ in self.OffsetX:
            showIndent(outfile, level)
            outfile.write('<%sOffsetX>%s</%sOffsetX>\n' % (namespace_, self.gds_format_string(quote_xml(OffsetX_).encode(ExternalEncoding), input_name='OffsetX'), namespace_))
        for OffsetY_ in self.OffsetY:
            showIndent(outfile, level)
            outfile.write('<%sOffsetY>%s</%sOffsetY>\n' % (namespace_, self.gds_format_string(quote_xml(OffsetY_).encode(ExternalEncoding), input_name='OffsetY'), namespace_))
    def hasContent_(self):
        if (
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.HueColor or
            self.OffsetX or
            self.OffsetY
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CapImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HueColor=[\n')
        level += 1
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HueColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffsetX=[\n')
        level += 1
        for OffsetX_ in self.OffsetX:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OffsetX_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OffsetY=[\n')
        level += 1
        for OffsetY_ in self.OffsetY:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OffsetY_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'HueColor':
            HueColor_ = child_.text
            HueColor_ = self.gds_validate_string(HueColor_, node, 'HueColor')
            self.HueColor.append(HueColor_)
        elif nodeName_ == 'OffsetX':
            OffsetX_ = child_.text
            OffsetX_ = self.gds_validate_string(OffsetX_, node, 'OffsetX')
            self.OffsetX.append(OffsetX_)
            self.validate_SizeType(self.OffsetX)    # validate type SizeType
        elif nodeName_ == 'OffsetY':
            OffsetY_ = child_.text
            OffsetY_ = self.gds_validate_string(OffsetY_, node, 'OffsetY')
            self.OffsetY.append(OffsetY_)
            self.validate_SizeType(self.OffsetY)    # validate type SizeType
# end class CapImageType


class FrameImageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Source=None, Value=None, MIMEType=None, TransparentColor=None, HueColor=None, Transparency=None, ClipImage=None):
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if MIMEType is None:
            self.MIMEType = []
        else:
            self.MIMEType = MIMEType
        if TransparentColor is None:
            self.TransparentColor = []
        else:
            self.TransparentColor = TransparentColor
        if HueColor is None:
            self.HueColor = []
        else:
            self.HueColor = HueColor
        if Transparency is None:
            self.Transparency = []
        else:
            self.Transparency = Transparency
        if ClipImage is None:
            self.ClipImage = []
        else:
            self.ClipImage = ClipImage
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if FrameImageType.subclass:
            return FrameImageType.subclass(*args_, **kwargs_)
        else:
            return FrameImageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source(self, index, value): self.Source[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value(self, index, value): self.Value[index] = value
    def get_MIMEType(self): return self.MIMEType
    def set_MIMEType(self, MIMEType): self.MIMEType = MIMEType
    def add_MIMEType(self, value): self.MIMEType.append(value)
    def insert_MIMEType(self, index, value): self.MIMEType[index] = value
    def get_TransparentColor(self): return self.TransparentColor
    def set_TransparentColor(self, TransparentColor): self.TransparentColor = TransparentColor
    def add_TransparentColor(self, value): self.TransparentColor.append(value)
    def insert_TransparentColor(self, index, value): self.TransparentColor[index] = value
    def get_HueColor(self): return self.HueColor
    def set_HueColor(self, HueColor): self.HueColor = HueColor
    def add_HueColor(self, value): self.HueColor.append(value)
    def insert_HueColor(self, index, value): self.HueColor[index] = value
    def get_Transparency(self): return self.Transparency
    def set_Transparency(self, Transparency): self.Transparency = Transparency
    def add_Transparency(self, value): self.Transparency.append(value)
    def insert_Transparency(self, index, value): self.Transparency[index] = value
    def get_ClipImage(self): return self.ClipImage
    def set_ClipImage(self, ClipImage): self.ClipImage = ClipImage
    def add_ClipImage(self, value): self.ClipImage.append(value)
    def insert_ClipImage(self, index, value): self.ClipImage[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='FrameImageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrameImageType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FrameImageType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FrameImageType', fromsubclass_=False):
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(Source_).encode(ExternalEncoding), input_name='Source'), namespace_))
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_))
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('<%sMIMEType>%s</%sMIMEType>\n' % (namespace_, self.gds_format_string(quote_xml(MIMEType_).encode(ExternalEncoding), input_name='MIMEType'), namespace_))
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('<%sTransparentColor>%s</%sTransparentColor>\n' % (namespace_, self.gds_format_string(quote_xml(TransparentColor_).encode(ExternalEncoding), input_name='TransparentColor'), namespace_))
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('<%sHueColor>%s</%sHueColor>\n' % (namespace_, self.gds_format_string(quote_xml(HueColor_).encode(ExternalEncoding), input_name='HueColor'), namespace_))
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('<%sTransparency>%s</%sTransparency>\n' % (namespace_, self.gds_format_string(quote_xml(Transparency_).encode(ExternalEncoding), input_name='Transparency'), namespace_))
        for ClipImage_ in self.ClipImage:
            showIndent(outfile, level)
            outfile.write('<%sClipImage>%s</%sClipImage>\n' % (namespace_, self.gds_format_string(quote_xml(ClipImage_).encode(ExternalEncoding), input_name='ClipImage'), namespace_))
    def hasContent_(self):
        if (
            self.Source or
            self.Value or
            self.MIMEType or
            self.TransparentColor or
            self.HueColor or
            self.Transparency or
            self.ClipImage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FrameImageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MIMEType=[\n')
        level += 1
        for MIMEType_ in self.MIMEType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MIMEType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('TransparentColor=[\n')
        level += 1
        for TransparentColor_ in self.TransparentColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(TransparentColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HueColor=[\n')
        level += 1
        for HueColor_ in self.HueColor:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HueColor_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Transparency=[\n')
        level += 1
        for Transparency_ in self.Transparency:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Transparency_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ClipImage=[\n')
        level += 1
        for ClipImage_ in self.ClipImage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ClipImage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source.append(Source_)
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
        elif nodeName_ == 'MIMEType':
            MIMEType_ = child_.text
            MIMEType_ = self.gds_validate_string(MIMEType_, node, 'MIMEType')
            self.MIMEType.append(MIMEType_)
        elif nodeName_ == 'TransparentColor':
            TransparentColor_ = child_.text
            TransparentColor_ = self.gds_validate_string(TransparentColor_, node, 'TransparentColor')
            self.TransparentColor.append(TransparentColor_)
        elif nodeName_ == 'HueColor':
            HueColor_ = child_.text
            HueColor_ = self.gds_validate_string(HueColor_, node, 'HueColor')
            self.HueColor.append(HueColor_)
        elif nodeName_ == 'Transparency':
            Transparency_ = child_.text
            Transparency_ = self.gds_validate_string(Transparency_, node, 'Transparency')
            self.Transparency.append(Transparency_)
        elif nodeName_ == 'ClipImage':
            ClipImage_ = child_.text
            ClipImage_ = self.gds_validate_string(ClipImage_, node, 'ClipImage')
            self.ClipImage.append(ClipImage_)
# end class FrameImageType


class BackFrameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None, FrameBackground=None, FrameImage=None, FrameStyle=None, FrameShape=None, FrameWidth=None, GlassEffect=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
        if FrameBackground is None:
            self.FrameBackground = []
        else:
            self.FrameBackground = FrameBackground
        if FrameImage is None:
            self.FrameImage = []
        else:
            self.FrameImage = FrameImage
        if FrameStyle is None:
            self.FrameStyle = []
        else:
            self.FrameStyle = FrameStyle
        if FrameShape is None:
            self.FrameShape = []
        else:
            self.FrameShape = FrameShape
        if FrameWidth is None:
            self.FrameWidth = []
        else:
            self.FrameWidth = FrameWidth
        if GlassEffect is None:
            self.GlassEffect = []
        else:
            self.GlassEffect = GlassEffect
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BackFrameType.subclass:
            return BackFrameType.subclass(*args_, **kwargs_)
        else:
            return BackFrameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def get_FrameBackground(self): return self.FrameBackground
    def set_FrameBackground(self, FrameBackground): self.FrameBackground = FrameBackground
    def add_FrameBackground(self, value): self.FrameBackground.append(value)
    def insert_FrameBackground(self, index, value): self.FrameBackground[index] = value
    def get_FrameImage(self): return self.FrameImage
    def set_FrameImage(self, FrameImage): self.FrameImage = FrameImage
    def add_FrameImage(self, value): self.FrameImage.append(value)
    def insert_FrameImage(self, index, value): self.FrameImage[index] = value
    def get_FrameStyle(self): return self.FrameStyle
    def set_FrameStyle(self, FrameStyle): self.FrameStyle = FrameStyle
    def add_FrameStyle(self, value): self.FrameStyle.append(value)
    def insert_FrameStyle(self, index, value): self.FrameStyle[index] = value
    def get_FrameShape(self): return self.FrameShape
    def set_FrameShape(self, FrameShape): self.FrameShape = FrameShape
    def add_FrameShape(self, value): self.FrameShape.append(value)
    def insert_FrameShape(self, index, value): self.FrameShape[index] = value
    def get_FrameWidth(self): return self.FrameWidth
    def set_FrameWidth(self, FrameWidth): self.FrameWidth = FrameWidth
    def add_FrameWidth(self, value): self.FrameWidth.append(value)
    def insert_FrameWidth(self, index, value): self.FrameWidth[index] = value
    def get_GlassEffect(self): return self.GlassEffect
    def set_GlassEffect(self, GlassEffect): self.GlassEffect = GlassEffect
    def add_GlassEffect(self, value): self.GlassEffect.append(value)
    def insert_GlassEffect(self, index, value): self.GlassEffect[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='BackFrameType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BackFrameType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BackFrameType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BackFrameType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
        for FrameBackground_ in self.FrameBackground:
            FrameBackground_.export(outfile, level, namespace_, name_='FrameBackground')
        for FrameImage_ in self.FrameImage:
            FrameImage_.export(outfile, level, namespace_, name_='FrameImage')
        for FrameStyle_ in self.FrameStyle:
            showIndent(outfile, level)
            outfile.write('<%sFrameStyle>%s</%sFrameStyle>\n' % (namespace_, self.gds_format_string(quote_xml(FrameStyle_).encode(ExternalEncoding), input_name='FrameStyle'), namespace_))
        for FrameShape_ in self.FrameShape:
            showIndent(outfile, level)
            outfile.write('<%sFrameShape>%s</%sFrameShape>\n' % (namespace_, self.gds_format_string(quote_xml(FrameShape_).encode(ExternalEncoding), input_name='FrameShape'), namespace_))
        for FrameWidth_ in self.FrameWidth:
            showIndent(outfile, level)
            outfile.write('<%sFrameWidth>%s</%sFrameWidth>\n' % (namespace_, self.gds_format_string(quote_xml(FrameWidth_).encode(ExternalEncoding), input_name='FrameWidth'), namespace_))
        for GlassEffect_ in self.GlassEffect:
            showIndent(outfile, level)
            outfile.write('<%sGlassEffect>%s</%sGlassEffect>\n' % (namespace_, self.gds_format_string(quote_xml(GlassEffect_).encode(ExternalEncoding), input_name='GlassEffect'), namespace_))
    def hasContent_(self):
        if (
            self.Style or
            self.FrameBackground or
            self.FrameImage or
            self.FrameStyle or
            self.FrameShape or
            self.FrameWidth or
            self.GlassEffect
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BackFrameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FrameBackground=[\n')
        level += 1
        for FrameBackground_ in self.FrameBackground:
            showIndent(outfile, level)
            outfile.write('model_.FrameBackgroundType(\n')
            FrameBackground_.exportLiteral(outfile, level, name_='FrameBackgroundType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FrameImage=[\n')
        level += 1
        for FrameImage_ in self.FrameImage:
            showIndent(outfile, level)
            outfile.write('model_.FrameImageType(\n')
            FrameImage_.exportLiteral(outfile, level, name_='FrameImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FrameStyle=[\n')
        level += 1
        for FrameStyle_ in self.FrameStyle:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FrameStyle_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FrameShape=[\n')
        level += 1
        for FrameShape_ in self.FrameShape:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FrameShape_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FrameWidth=[\n')
        level += 1
        for FrameWidth_ in self.FrameWidth:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(FrameWidth_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('GlassEffect=[\n')
        level += 1
        for GlassEffect_ in self.GlassEffect:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(GlassEffect_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
        elif nodeName_ == 'FrameBackground':
            obj_ = FrameBackgroundType.factory()
            obj_.build(child_)
            self.FrameBackground.append(obj_)
        elif nodeName_ == 'FrameImage':
            obj_ = FrameImageType.factory()
            obj_.build(child_)
            self.FrameImage.append(obj_)
        elif nodeName_ == 'FrameStyle':
            FrameStyle_ = child_.text
            FrameStyle_ = self.gds_validate_string(FrameStyle_, node, 'FrameStyle')
            self.FrameStyle.append(FrameStyle_)
        elif nodeName_ == 'FrameShape':
            FrameShape_ = child_.text
            FrameShape_ = self.gds_validate_string(FrameShape_, node, 'FrameShape')
            self.FrameShape.append(FrameShape_)
        elif nodeName_ == 'FrameWidth':
            FrameWidth_ = child_.text
            FrameWidth_ = self.gds_validate_string(FrameWidth_, node, 'FrameWidth')
            self.FrameWidth.append(FrameWidth_)
        elif nodeName_ == 'GlassEffect':
            GlassEffect_ = child_.text
            GlassEffect_ = self.gds_validate_string(GlassEffect_, node, 'GlassEffect')
            self.GlassEffect.append(GlassEffect_)
# end class BackFrameType


class FrameBackgroundType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Style=None):
        if Style is None:
            self.Style = []
        else:
            self.Style = Style
    def factory(*args_, **kwargs_):
        if FrameBackgroundType.subclass:
            return FrameBackgroundType.subclass(*args_, **kwargs_)
        else:
            return FrameBackgroundType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Style(self): return self.Style
    def set_Style(self, Style): self.Style = Style
    def add_Style(self, value): self.Style.append(value)
    def insert_Style(self, index, value): self.Style[index] = value
    def export(self, outfile, level, namespace_='', name_='FrameBackgroundType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrameBackgroundType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FrameBackgroundType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FrameBackgroundType', fromsubclass_=False):
        for Style_ in self.Style:
            Style_.export(outfile, level, namespace_, name_='Style')
    def hasContent_(self):
        if (
            self.Style
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FrameBackgroundType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Style=[\n')
        level += 1
        for Style_ in self.Style:
            showIndent(outfile, level)
            outfile.write('model_.StyleType(\n')
            Style_.exportLiteral(outfile, level, name_='StyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Style':
            obj_ = StyleType.factory()
            obj_.build(child_)
            self.Style.append(obj_)
# end class FrameBackgroundType


class RadialGaugesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RadialGauge=None):
        if RadialGauge is None:
            self.RadialGauge = []
        else:
            self.RadialGauge = RadialGauge
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RadialGaugesType.subclass:
            return RadialGaugesType.subclass(*args_, **kwargs_)
        else:
            return RadialGaugesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RadialGauge(self): return self.RadialGauge
    def set_RadialGauge(self, RadialGauge): self.RadialGauge = RadialGauge
    def add_RadialGauge(self, value): self.RadialGauge.append(value)
    def insert_RadialGauge(self, index, value): self.RadialGauge[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RadialGaugesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialGaugesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialGaugesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RadialGaugesType', fromsubclass_=False):
        for RadialGauge_ in self.RadialGauge:
            RadialGauge_.export(outfile, level, namespace_, name_='RadialGauge')
    def hasContent_(self):
        if (
            self.RadialGauge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RadialGaugesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RadialGauge=[\n')
        level += 1
        for RadialGauge_ in self.RadialGauge:
            showIndent(outfile, level)
            outfile.write('model_.RadialGaugeType(\n')
            RadialGauge_.exportLiteral(outfile, level, name_='RadialGaugeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RadialGauge':
            obj_ = RadialGaugeType.factory()
            obj_.build(child_)
            self.RadialGauge.append(obj_)
# end class RadialGaugesType


class LinearGaugesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinearGauge=None):
        if LinearGauge is None:
            self.LinearGauge = []
        else:
            self.LinearGauge = LinearGauge
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LinearGaugesType.subclass:
            return LinearGaugesType.subclass(*args_, **kwargs_)
        else:
            return LinearGaugesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinearGauge(self): return self.LinearGauge
    def set_LinearGauge(self, LinearGauge): self.LinearGauge = LinearGauge
    def add_LinearGauge(self, value): self.LinearGauge.append(value)
    def insert_LinearGauge(self, index, value): self.LinearGauge[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LinearGaugesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearGaugesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearGaugesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinearGaugesType', fromsubclass_=False):
        for LinearGauge_ in self.LinearGauge:
            LinearGauge_.export(outfile, level, namespace_, name_='LinearGauge')
    def hasContent_(self):
        if (
            self.LinearGauge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearGaugesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LinearGauge=[\n')
        level += 1
        for LinearGauge_ in self.LinearGauge:
            showIndent(outfile, level)
            outfile.write('model_.LinearGaugeType(\n')
            LinearGauge_.exportLiteral(outfile, level, name_='LinearGaugeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinearGauge':
            obj_ = LinearGaugeType.factory()
            obj_.build(child_)
            self.LinearGauge.append(obj_)
# end class LinearGaugesType


class NumericIndicatorsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumericIndicator=None):
        if NumericIndicator is None:
            self.NumericIndicator = []
        else:
            self.NumericIndicator = NumericIndicator
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NumericIndicatorsType.subclass:
            return NumericIndicatorsType.subclass(*args_, **kwargs_)
        else:
            return NumericIndicatorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumericIndicator(self): return self.NumericIndicator
    def set_NumericIndicator(self, NumericIndicator): self.NumericIndicator = NumericIndicator
    def add_NumericIndicator(self, value): self.NumericIndicator.append(value)
    def insert_NumericIndicator(self, index, value): self.NumericIndicator[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NumericIndicatorsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumericIndicatorsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumericIndicatorsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NumericIndicatorsType', fromsubclass_=False):
        for NumericIndicator_ in self.NumericIndicator:
            NumericIndicator_.export(outfile, level, namespace_, name_='NumericIndicator')
    def hasContent_(self):
        if (
            self.NumericIndicator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumericIndicatorsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NumericIndicator=[\n')
        level += 1
        for NumericIndicator_ in self.NumericIndicator:
            showIndent(outfile, level)
            outfile.write('model_.NumericIndicatorType(\n')
            NumericIndicator_.exportLiteral(outfile, level, name_='NumericIndicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumericIndicator':
            obj_ = NumericIndicatorType.factory()
            obj_.build(child_)
            self.NumericIndicator.append(obj_)
# end class NumericIndicatorsType


class StateIndicatorsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StateIndicator=None):
        if StateIndicator is None:
            self.StateIndicator = []
        else:
            self.StateIndicator = StateIndicator
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if StateIndicatorsType.subclass:
            return StateIndicatorsType.subclass(*args_, **kwargs_)
        else:
            return StateIndicatorsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StateIndicator(self): return self.StateIndicator
    def set_StateIndicator(self, StateIndicator): self.StateIndicator = StateIndicator
    def add_StateIndicator(self, value): self.StateIndicator.append(value)
    def insert_StateIndicator(self, index, value): self.StateIndicator[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='StateIndicatorsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateIndicatorsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateIndicatorsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StateIndicatorsType', fromsubclass_=False):
        for StateIndicator_ in self.StateIndicator:
            StateIndicator_.export(outfile, level, namespace_, name_='StateIndicator')
    def hasContent_(self):
        if (
            self.StateIndicator
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateIndicatorsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StateIndicator=[\n')
        level += 1
        for StateIndicator_ in self.StateIndicator:
            showIndent(outfile, level)
            outfile.write('model_.StateIndicatorType(\n')
            StateIndicator_.exportLiteral(outfile, level, name_='StateIndicatorType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StateIndicator':
            obj_ = StateIndicatorType.factory()
            obj_.build(child_)
            self.StateIndicator.append(obj_)
# end class StateIndicatorsType


class GaugeImagesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GaugeImage=None):
        if GaugeImage is None:
            self.GaugeImage = []
        else:
            self.GaugeImage = GaugeImage
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeImagesType.subclass:
            return GaugeImagesType.subclass(*args_, **kwargs_)
        else:
            return GaugeImagesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GaugeImage(self): return self.GaugeImage
    def set_GaugeImage(self, GaugeImage): self.GaugeImage = GaugeImage
    def add_GaugeImage(self, value): self.GaugeImage.append(value)
    def insert_GaugeImage(self, index, value): self.GaugeImage[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeImagesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeImagesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeImagesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeImagesType', fromsubclass_=False):
        for GaugeImage_ in self.GaugeImage:
            GaugeImage_.export(outfile, level, namespace_, name_='GaugeImage')
    def hasContent_(self):
        if (
            self.GaugeImage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeImagesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('GaugeImage=[\n')
        level += 1
        for GaugeImage_ in self.GaugeImage:
            showIndent(outfile, level)
            outfile.write('model_.GaugeImageType(\n')
            GaugeImage_.exportLiteral(outfile, level, name_='GaugeImageType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GaugeImage':
            obj_ = GaugeImageType.factory()
            obj_.build(child_)
            self.GaugeImage.append(obj_)
# end class GaugeImagesType


class GaugeLabelsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GaugeLabel=None):
        if GaugeLabel is None:
            self.GaugeLabel = []
        else:
            self.GaugeLabel = GaugeLabel
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if GaugeLabelsType.subclass:
            return GaugeLabelsType.subclass(*args_, **kwargs_)
        else:
            return GaugeLabelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GaugeLabel(self): return self.GaugeLabel
    def set_GaugeLabel(self, GaugeLabel): self.GaugeLabel = GaugeLabel
    def add_GaugeLabel(self, value): self.GaugeLabel.append(value)
    def insert_GaugeLabel(self, index, value): self.GaugeLabel[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='GaugeLabelsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GaugeLabelsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GaugeLabelsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GaugeLabelsType', fromsubclass_=False):
        for GaugeLabel_ in self.GaugeLabel:
            GaugeLabel_.export(outfile, level, namespace_, name_='GaugeLabel')
    def hasContent_(self):
        if (
            self.GaugeLabel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GaugeLabelsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('GaugeLabel=[\n')
        level += 1
        for GaugeLabel_ in self.GaugeLabel:
            showIndent(outfile, level)
            outfile.write('model_.GaugeLabelType(\n')
            GaugeLabel_.exportLiteral(outfile, level, name_='GaugeLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GaugeLabel':
            obj_ = GaugeLabelType.factory()
            obj_.build(child_)
            self.GaugeLabel.append(obj_)
# end class GaugeLabelsType


class RadialScalesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RadialScale=None):
        if RadialScale is None:
            self.RadialScale = []
        else:
            self.RadialScale = RadialScale
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RadialScalesType.subclass:
            return RadialScalesType.subclass(*args_, **kwargs_)
        else:
            return RadialScalesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RadialScale(self): return self.RadialScale
    def set_RadialScale(self, RadialScale): self.RadialScale = RadialScale
    def add_RadialScale(self, value): self.RadialScale.append(value)
    def insert_RadialScale(self, index, value): self.RadialScale[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RadialScalesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialScalesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialScalesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RadialScalesType', fromsubclass_=False):
        for RadialScale_ in self.RadialScale:
            RadialScale_.export(outfile, level, namespace_, name_='RadialScale')
    def hasContent_(self):
        if (
            self.RadialScale
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RadialScalesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RadialScale=[\n')
        level += 1
        for RadialScale_ in self.RadialScale:
            showIndent(outfile, level)
            outfile.write('model_.RadialScaleType(\n')
            RadialScale_.exportLiteral(outfile, level, name_='RadialScaleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RadialScale':
            obj_ = RadialScaleType.factory()
            obj_.build(child_)
            self.RadialScale.append(obj_)
# end class RadialScalesType


class LinearScalesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinearScale=None):
        if LinearScale is None:
            self.LinearScale = []
        else:
            self.LinearScale = LinearScale
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LinearScalesType.subclass:
            return LinearScalesType.subclass(*args_, **kwargs_)
        else:
            return LinearScalesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinearScale(self): return self.LinearScale
    def set_LinearScale(self, LinearScale): self.LinearScale = LinearScale
    def add_LinearScale(self, value): self.LinearScale.append(value)
    def insert_LinearScale(self, index, value): self.LinearScale[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LinearScalesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearScalesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearScalesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinearScalesType', fromsubclass_=False):
        for LinearScale_ in self.LinearScale:
            LinearScale_.export(outfile, level, namespace_, name_='LinearScale')
    def hasContent_(self):
        if (
            self.LinearScale
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearScalesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LinearScale=[\n')
        level += 1
        for LinearScale_ in self.LinearScale:
            showIndent(outfile, level)
            outfile.write('model_.LinearScaleType(\n')
            LinearScale_.exportLiteral(outfile, level, name_='LinearScaleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinearScale':
            obj_ = LinearScaleType.factory()
            obj_.build(child_)
            self.LinearScale.append(obj_)
# end class LinearScalesType


class NumericIndicatorRangesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NumericIndicatorRange=None):
        if NumericIndicatorRange is None:
            self.NumericIndicatorRange = []
        else:
            self.NumericIndicatorRange = NumericIndicatorRange
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NumericIndicatorRangesType.subclass:
            return NumericIndicatorRangesType.subclass(*args_, **kwargs_)
        else:
            return NumericIndicatorRangesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumericIndicatorRange(self): return self.NumericIndicatorRange
    def set_NumericIndicatorRange(self, NumericIndicatorRange): self.NumericIndicatorRange = NumericIndicatorRange
    def add_NumericIndicatorRange(self, value): self.NumericIndicatorRange.append(value)
    def insert_NumericIndicatorRange(self, index, value): self.NumericIndicatorRange[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='NumericIndicatorRangesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NumericIndicatorRangesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NumericIndicatorRangesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NumericIndicatorRangesType', fromsubclass_=False):
        for NumericIndicatorRange_ in self.NumericIndicatorRange:
            NumericIndicatorRange_.export(outfile, level, namespace_, name_='NumericIndicatorRange')
    def hasContent_(self):
        if (
            self.NumericIndicatorRange
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NumericIndicatorRangesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NumericIndicatorRange=[\n')
        level += 1
        for NumericIndicatorRange_ in self.NumericIndicatorRange:
            showIndent(outfile, level)
            outfile.write('model_.NumericIndicatorRangeType(\n')
            NumericIndicatorRange_.exportLiteral(outfile, level, name_='NumericIndicatorRangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumericIndicatorRange':
            obj_ = NumericIndicatorRangeType.factory()
            obj_.build(child_)
            self.NumericIndicatorRange.append(obj_)
# end class NumericIndicatorRangesType


class IndicatorStatesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IndicatorState=None):
        if IndicatorState is None:
            self.IndicatorState = []
        else:
            self.IndicatorState = IndicatorState
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IndicatorStatesType.subclass:
            return IndicatorStatesType.subclass(*args_, **kwargs_)
        else:
            return IndicatorStatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndicatorState(self): return self.IndicatorState
    def set_IndicatorState(self, IndicatorState): self.IndicatorState = IndicatorState
    def add_IndicatorState(self, value): self.IndicatorState.append(value)
    def insert_IndicatorState(self, index, value): self.IndicatorState[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='IndicatorStatesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndicatorStatesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndicatorStatesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IndicatorStatesType', fromsubclass_=False):
        for IndicatorState_ in self.IndicatorState:
            IndicatorState_.export(outfile, level, namespace_, name_='IndicatorState')
    def hasContent_(self):
        if (
            self.IndicatorState
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndicatorStatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IndicatorState=[\n')
        level += 1
        for IndicatorState_ in self.IndicatorState:
            showIndent(outfile, level)
            outfile.write('model_.IndicatorStateType(\n')
            IndicatorState_.exportLiteral(outfile, level, name_='IndicatorStateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndicatorState':
            obj_ = IndicatorStateType.factory()
            obj_.build(child_)
            self.IndicatorState.append(obj_)
# end class IndicatorStatesType


class RadialPointersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RadialPointer=None):
        if RadialPointer is None:
            self.RadialPointer = []
        else:
            self.RadialPointer = RadialPointer
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RadialPointersType.subclass:
            return RadialPointersType.subclass(*args_, **kwargs_)
        else:
            return RadialPointersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RadialPointer(self): return self.RadialPointer
    def set_RadialPointer(self, RadialPointer): self.RadialPointer = RadialPointer
    def add_RadialPointer(self, value): self.RadialPointer.append(value)
    def insert_RadialPointer(self, index, value): self.RadialPointer[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='RadialPointersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RadialPointersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RadialPointersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RadialPointersType', fromsubclass_=False):
        for RadialPointer_ in self.RadialPointer:
            RadialPointer_.export(outfile, level, namespace_, name_='RadialPointer')
    def hasContent_(self):
        if (
            self.RadialPointer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RadialPointersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RadialPointer=[\n')
        level += 1
        for RadialPointer_ in self.RadialPointer:
            showIndent(outfile, level)
            outfile.write('model_.RadialPointerType(\n')
            RadialPointer_.exportLiteral(outfile, level, name_='RadialPointerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RadialPointer':
            obj_ = RadialPointerType.factory()
            obj_.build(child_)
            self.RadialPointer.append(obj_)
# end class RadialPointersType


class LinearPointersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LinearPointer=None):
        if LinearPointer is None:
            self.LinearPointer = []
        else:
            self.LinearPointer = LinearPointer
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LinearPointersType.subclass:
            return LinearPointersType.subclass(*args_, **kwargs_)
        else:
            return LinearPointersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LinearPointer(self): return self.LinearPointer
    def set_LinearPointer(self, LinearPointer): self.LinearPointer = LinearPointer
    def add_LinearPointer(self, value): self.LinearPointer.append(value)
    def insert_LinearPointer(self, index, value): self.LinearPointer[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='LinearPointersType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearPointersType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearPointersType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinearPointersType', fromsubclass_=False):
        for LinearPointer_ in self.LinearPointer:
            LinearPointer_.export(outfile, level, namespace_, name_='LinearPointer')
    def hasContent_(self):
        if (
            self.LinearPointer
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LinearPointersType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LinearPointer=[\n')
        level += 1
        for LinearPointer_ in self.LinearPointer:
            showIndent(outfile, level)
            outfile.write('model_.LinearPointerType(\n')
            LinearPointer_.exportLiteral(outfile, level, name_='LinearPointerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LinearPointer':
            obj_ = LinearPointerType.factory()
            obj_.build(child_)
            self.LinearPointer.append(obj_)
# end class LinearPointersType


class ScaleRangesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ScaleRange=None):
        if ScaleRange is None:
            self.ScaleRange = []
        else:
            self.ScaleRange = ScaleRange
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ScaleRangesType.subclass:
            return ScaleRangesType.subclass(*args_, **kwargs_)
        else:
            return ScaleRangesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ScaleRange(self): return self.ScaleRange
    def set_ScaleRange(self, ScaleRange): self.ScaleRange = ScaleRange
    def add_ScaleRange(self, value): self.ScaleRange.append(value)
    def insert_ScaleRange(self, index, value): self.ScaleRange[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='ScaleRangesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScaleRangesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScaleRangesType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ScaleRangesType', fromsubclass_=False):
        for ScaleRange_ in self.ScaleRange:
            ScaleRange_.export(outfile, level, namespace_, name_='ScaleRange')
    def hasContent_(self):
        if (
            self.ScaleRange
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScaleRangesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ScaleRange=[\n')
        level += 1
        for ScaleRange_ in self.ScaleRange:
            showIndent(outfile, level)
            outfile.write('model_.ScaleRangeType(\n')
            ScaleRange_.exportLiteral(outfile, level, name_='ScaleRangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScaleRange':
            obj_ = ScaleRangeType.factory()
            obj_.build(child_)
            self.ScaleRange.append(obj_)
# end class ScaleRangesType


class CustomLabelsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CustomLabel=None):
        if CustomLabel is None:
            self.CustomLabel = []
        else:
            self.CustomLabel = CustomLabel
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CustomLabelsType.subclass:
            return CustomLabelsType.subclass(*args_, **kwargs_)
        else:
            return CustomLabelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomLabel(self): return self.CustomLabel
    def set_CustomLabel(self, CustomLabel): self.CustomLabel = CustomLabel
    def add_CustomLabel(self, value): self.CustomLabel.append(value)
    def insert_CustomLabel(self, index, value): self.CustomLabel[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='', name_='CustomLabelsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomLabelsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomLabelsType'):
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                if name not in already_processed:
                    already_processed.append(name)
                    outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CustomLabelsType', fromsubclass_=False):
        for CustomLabel_ in self.CustomLabel:
            CustomLabel_.export(outfile, level, namespace_, name_='CustomLabel')
    def hasContent_(self):
        if (
            self.CustomLabel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CustomLabelsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CustomLabel=[\n')
        level += 1
        for CustomLabel_ in self.CustomLabel:
            showIndent(outfile, level)
            outfile.write('model_.CustomLabelType(\n')
            CustomLabel_.exportLiteral(outfile, level, name_='CustomLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomLabel':
            obj_ = CustomLabelType.factory()
            obj_.build(child_)
            self.CustomLabel.append(obj_)
# end class CustomLabelsType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Report'
        rootClass = Report
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Report'
        rootClass = Report
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Report",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Report'
        rootClass = Report
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from ssrsStruct import *\n\n')
    sys.stdout.write('import ssrsStruct as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccentSensitivity",
    "ActionInfoType",
    "ActionType",
    "ActionsType",
    "BackFrameType",
    "BackgroundImageType",
    "BodyType",
    "BorderType",
    "BreakLocation",
    "CapImageType",
    "CaseSensitivity",
    "CellContentsType",
    "CellType",
    "ChartAlignTypeType",
    "ChartAnnotationType",
    "ChartAnnotationsType",
    "ChartAreaType",
    "ChartAreasType",
    "ChartAxisScaleBreakType",
    "ChartAxisTitleType",
    "ChartAxisType",
    "ChartBorderSkinType",
    "ChartCategoryAxesType",
    "ChartCodeParameterType",
    "ChartCodeParametersType",
    "ChartCustomPaletteColorsType",
    "ChartDataLabelType",
    "ChartDataPointType",
    "ChartDataPointValuesType",
    "ChartDataPointsType",
    "ChartDataType",
    "ChartDerivedSeriesCollectionType",
    "ChartDerivedSeriesType",
    "ChartElementPositionType",
    "ChartEmptyPointsType",
    "ChartFormulaParameterType",
    "ChartFormulaParametersType",
    "ChartGridLinesType",
    "ChartHierarchyType",
    "ChartItemInLegendType",
    "ChartLegendColumnHeaderType",
    "ChartLegendColumnType",
    "ChartLegendColumnsType",
    "ChartLegendCustomItemCellType",
    "ChartLegendCustomItemCellsType",
    "ChartLegendCustomItemType",
    "ChartLegendCustomItemsType",
    "ChartLegendTitleType",
    "ChartLegendType",
    "ChartLegendsType",
    "ChartMarkerType",
    "ChartMemberType",
    "ChartMembersType",
    "ChartNoMoveDirectionsType",
    "ChartSeriesCollectionType",
    "ChartSeriesType",
    "ChartSmartLabelType",
    "ChartStripLineType",
    "ChartStripLinesType",
    "ChartThreeDPropertiesType",
    "ChartTickMarksType",
    "ChartTitleType",
    "ChartTitlesType",
    "ChartType",
    "ChartValueAxesType",
    "ClassType",
    "ClassesType",
    "CodeLanguage",
    "CodeModulesType",
    "ColumnType",
    "CommandType",
    "ConnectionPropertiesType",
    "CustomDataType",
    "CustomLabelType",
    "CustomLabelsType",
    "CustomPropertiesType",
    "CustomPropertyType",
    "CustomReportItemType",
    "DataCellType",
    "DataColumnHierarchyType",
    "DataElementOutput",
    "DataElementStyle",
    "DataMemberType",
    "DataMembersType",
    "DataRowHierarchyType",
    "DataRowType",
    "DataRowsType",
    "DataSetReferenceType",
    "DataSetType",
    "DataSetsType",
    "DataSourceType",
    "DataSourcesType",
    "DataType",
    "DataValueType",
    "DefaultValueType",
    "DerivedSeriesFormula",
    "Direction",
    "DrillthroughType",
    "EmbeddedImageType",
    "EmbeddedImagesType",
    "FieldType",
    "FieldsType",
    "FilterType",
    "FilterValuesType",
    "FiltersType",
    "FrameBackgroundType",
    "FrameImageType",
    "GaugeImageType",
    "GaugeImagesType",
    "GaugeInputValueType",
    "GaugeLabelType",
    "GaugeLabelsType",
    "GaugeMemberType",
    "GaugePanelType",
    "GaugeTickMarksType",
    "GroupExpressionsType",
    "GroupType",
    "ImageType",
    "IndicatorStateType",
    "IndicatorStatesType",
    "InterpretSubtotalsAsDetails",
    "KanatypeSensitivity",
    "KeepWithGroup",
    "LayoutDirection",
    "LineType",
    "LinearGaugeType",
    "LinearGaugesType",
    "LinearPointerType",
    "LinearPointersType",
    "LinearScaleType",
    "LinearScalesType",
    "ListStyle",
    "LocIDStringWithDataTypeAttribute",
    "NumericIndicatorRangeType",
    "NumericIndicatorRangesType",
    "NumericIndicatorType",
    "NumericIndicatorsType",
    "Operator",
    "PageBreakType",
    "PageSectionType",
    "PageType",
    "ParagraphType",
    "ParagraphsType",
    "ParameterType",
    "ParameterValueType",
    "ParameterValuesType",
    "ParametersType",
    "PinLabelType",
    "PointerCapType",
    "PointerImageType",
    "QueryParameterType",
    "QueryParametersType",
    "QueryType",
    "RadialGaugeType",
    "RadialGaugesType",
    "RadialPointerType",
    "RadialPointersType",
    "RadialScaleType",
    "RadialScalesType",
    "RectangleType",
    "Report",
    "ReportItemsType",
    "ReportParameterType",
    "ReportParametersType",
    "ScaleLabelsType",
    "ScalePinType",
    "ScaleRangeType",
    "ScaleRangesType",
    "Sizing",
    "SortExpressionType",
    "SortExpressionsType",
    "Source",
    "StateImageType",
    "StateIndicatorType",
    "StateIndicatorsType",
    "StringLocIDType",
    "StringWithDataTypeAttribute",
    "StyleType",
    "SubreportType",
    "TablixBodyType",
    "TablixCellType",
    "TablixCellsType",
    "TablixColumnType",
    "TablixColumnsType",
    "TablixCornerCellType",
    "TablixCornerRowType",
    "TablixCornerRowsType",
    "TablixCornerType",
    "TablixHeaderType",
    "TablixHierarchyType",
    "TablixMemberType",
    "TablixMembersType",
    "TablixRowType",
    "TablixRowsType",
    "TablixType",
    "TextRunType",
    "TextRunsType",
    "TextboxType",
    "ThermometerType",
    "TickMarkStyleType",
    "ToggleImageType",
    "TopImageType",
    "UsedInQuery",
    "UserSortType",
    "ValidValuesType",
    "ValuesType",
    "VariableType",
    "VariablesType",
    "VisibilityType",
    "WidthSensitivity"
    ]
